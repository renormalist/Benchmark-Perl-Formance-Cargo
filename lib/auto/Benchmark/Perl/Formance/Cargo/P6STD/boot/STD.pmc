use 5.010;
use utf8;
{ package STD;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('Cursor');
our $ALLROLES = { 'STD', 1 };
our $REGEXES = {
ALL => [ qw/alnumint apostrophe babble backslash begid binint binints category charname charnames charspec circumfix comment dec_number decint decints dotty embeddedblock endid escale escape hexint hexints ident identifier infix infix_circumfix_meta_operator infix_postfix_meta_operator infix_prefix_meta_operator initializer integer is_ok keyspace liststopper longname module_name morename multi_declarator name nibbler nofun numeric octint octints opener package_declarator pod_comment postcircumfix postfix postfix_prefix_meta_operator prefix prefix_circumfix_meta_operator prefix_postfix_meta_operator quibble quote quote_mod quotepair rad_number radint regex_declarator routine_declarator scope_declarator sigil spacey special_variable starter statement_control statement_mod_cond statement_mod_loop statement_prefix stdstopper stopper term terminator trait_mod twigil type_declarator unitstopper unsp unspacey unv value version vws ws/ ],
category => [ qw/category__S_000category__PEEK category__S_001sigil__PEEK category__S_002twigil__PEEK category__S_003special_variable__PEEK category__S_004comment__PEEK category__S_005version__PEEK category__S_006module_name__PEEK category__S_007value__PEEK category__S_008term__PEEK category__S_009numeric__PEEK category__S_010quote__PEEK category__S_011prefix__PEEK category__S_012infix__PEEK category__S_013postfix__PEEK category__S_014dotty__PEEK category__S_015circumfix__PEEK category__S_016postcircumfix__PEEK category__S_017quote_mod__PEEK category__S_018trait_mod__PEEK category__S_019initializer__PEEK category__S_020type_declarator__PEEK category__S_021scope_declarator__PEEK category__S_022package_declarator__PEEK category__S_023multi_declarator__PEEK category__S_024routine_declarator__PEEK category__S_025regex_declarator__PEEK category__S_026statement_prefix__PEEK category__S_027statement_control__PEEK category__S_028statement_mod_cond__PEEK category__S_029statement_mod_loop__PEEK category__S_030infix_prefix_meta_operator__PEEK category__S_031infix_postfix_meta_operator__PEEK category__S_032infix_circumfix_meta_operator__PEEK category__S_033postfix_prefix_meta_operator__PEEK category__S_034prefix_postfix_meta_operator__PEEK category__S_035prefix_circumfix_meta_operator__PEEK category__S_036terminator__PEEK/ ],
circumfix => [ qw/circumfix__S_052Fre_Nch__PEEK circumfix__S_053LtLt_GtGt__PEEK circumfix__S_054Lt_Gt__PEEK/ ],
comment => [ qw/comment__S_055SharpGraveParenDotDotDotThesis__PEEK comment__S_056SharpParenDotDotDotThesis__PEEK comment__S_057SharpEqualParenDotDotDotThesis__PEEK comment__S_058SharpEqual__PEEK comment__S_059Sharp__PEEK/ ],
escape => [ qw/escape__S_049none__PEEK/ ],
quote => [ qw/quote__S_050Single_Single__PEEK quote__S_051Double_Double__PEEK/ ],
sigil => [ qw/sigil__S_037Dollar__PEEK sigil__S_038At__PEEK sigil__S_039Percent__PEEK sigil__S_040Amp__PEEK/ ],
term => [ qw/term__S_063miscbad__PEEK/ ],
terminator => [ qw/terminator__S_060Thesis__PEEK terminator__S_061Ket__PEEK terminator__S_062Ly__PEEK/ ],
twigil => [ qw/twigil__S_041Dot__PEEK twigil__S_042Bang__PEEK twigil__S_043Caret__PEEK twigil__S_044Colon__PEEK twigil__S_045Star__PEEK twigil__S_046Question__PEEK twigil__S_047Equal__PEEK twigil__S_048Tilde__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
alnumint: !!perl/hash:RE_ast
  dba: alnumint
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_cclass
          i: 0
          text: '[ 0..9 a..z A..Z ]'
        quant:
        - +
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: _
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_cclass
                i: 0
                text: '[ 0..9 a..z A..Z ]'
              quant:
              - +
        quant:
        - '*'
apostrophe: !!perl/hash:RE_ast
  dba: apostrophe
  dic: STD
  re: !!perl/hash:RE_cclass
    i: 0
    text: '[ '' \- ]'
babble: !!perl/hash:RE_ast
  dba: babble
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
backslash:*:
  dic: STD
begid: !!perl/hash:RE_ast
  dba: begid
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_meta
        min: 1
        text: \w
binint: !!perl/hash:RE_ast
  dba: binint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..1 ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..1 ]'
            quant:
            - +
      quant:
      - '*'
binints: !!perl/hash:RE_ast
  dba: binints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: binint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
category:*:
  dic: STD
category__S_000category: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: category
category__S_001sigil: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: sigil
category__S_002twigil: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: twigil
category__S_003special_variable: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: special_variable
category__S_004comment: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: comment
category__S_005version: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: version
category__S_006module_name: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: module_name
category__S_007value: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: value
category__S_008term: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: term
category__S_009numeric: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: numeric
category__S_010quote: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quote
category__S_011prefix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix
category__S_012infix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix
category__S_013postfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postfix
category__S_014dotty: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: dotty
category__S_015circumfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: trait_mod
category__S_019initializer: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: initializer
category__S_020type_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: type_declarator
category__S_021scope_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: scope_declarator
category__S_022package_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: package_declarator
category__S_023multi_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: multi_declarator
category__S_024routine_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: routine_declarator
category__S_025regex_declarator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: regex_declarator
category__S_026statement_prefix: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_prefix
category__S_027statement_control: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_control
category__S_028statement_mod_cond: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_mod_cond
category__S_029statement_mod_loop: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: statement_mod_loop
category__S_030infix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_prefix_meta_operator
category__S_031infix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_postfix_meta_operator
category__S_032infix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: infix_circumfix_meta_operator
category__S_033postfix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: postfix_prefix_meta_operator
category__S_034prefix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix_postfix_meta_operator
category__S_035prefix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: prefix_circumfix_meta_operator
category__S_036terminator: !!perl/hash:RE_ast
  dba: category
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: terminator
charname: !!perl/hash:RE_ast
  dba: charname
  dic: STD
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: charname_0
        dba: charname
        dic: STD
        zyg:
        - !!perl/hash:RE_method
          alt: charname_0 0
          name: radint
          rest: ''
        - !!perl/hash:RE_sequence
          alt: charname_0 1
          zyg:
          - !!perl/hash:RE_method
            name: alpha
            rest: ''
          - !!perl/hash:RE_meta
            text: .*?
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &2 !!perl/hash:RE_any
                    altname: charname_1
                    dba: charname
                    dic: STD
                    zyg:
                    - !!perl/hash:RE_string
                      alt: charname_1 0
                      i: 0
                      text: ','
                    - !!perl/hash:RE_string
                      alt: charname_1 1
                      i: 0
                      text: '#'
                    - !!perl/hash:RE_string
                      alt: charname_1 2
                      i: 0
                      text: ']'
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: sorry
        rest: 1
      - !!perl/hash:RE_meta
        text: .*?
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method
          name: terminator
          rest: ''
charname_0: *1
charname_1: *2
charnames: !!perl/hash:RE_ast
  dba: charnames
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: charname
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - +
charspec: !!perl/hash:RE_ast
  dba: charspec
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &3 !!perl/hash:RE_any
      altname: charspec_0
      dba: character name
      dic: STD
      zyg:
      - !!perl/hash:RE_bracket
        alt: charspec_0 0
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: charnames
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ']'
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_quantified_atom
        alt: charspec_0 1
        atom: !!perl/hash:RE_meta
          min: 1
          text: \d
        quant:
        - +
      - !!perl/hash:RE_cclass
        alt: charspec_0 2
        i: 0
        text: '[ ?..Z \\.._ ]'
      - !!perl/hash:RE_sequence
        alt: charspec_0 3
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_noop
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
        - !!perl/hash:RE_meta
          min: 1
          text: .
charspec_0: *3
circumfix:*:
  dic: STD
circumfix__S_052Fre_Nch: !!perl/hash:RE_ast
  dba: shell-quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: «
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: »
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
circumfix__S_053LtLt_GtGt: !!perl/hash:RE_ast
  dba: shell-quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: <<
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '>>'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
circumfix__S_054Lt_Gt: !!perl/hash:RE_ast
  dba: quote words
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: <
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: STDIN>
                - !!perl/hash:RE_method
                  name: obs
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '>'
                - !!perl/hash:RE_method
                  name: obs
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: nibble
            rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '>'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
comment:*:
  dic: STD
comment__S_055SharpGraveParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#`'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: opener
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
comment__S_056SharpParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: opener
        rest: ''
    - !!perl/hash:RE_method_re
      name: suppose
      nobind: 1
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: quibble
          rest: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: '[,;:]'
                quant:
                - '*'
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_bracket
                re: &4 !!perl/hash:RE_any
                  altname: comment__S_056SharpParenDotDotDotThesis_0
                  dba: comment
                  dic: STD
                  zyg:
                  - !!perl/hash:RE_string
                    alt: comment__S_056SharpParenDotDotDotThesis_0 0
                    i: 0
                    text: '#'
                  - !!perl/hash:RE_meta
                    alt: comment__S_056SharpParenDotDotDotThesis_0 1
                    text: $$
    - !!perl/hash:RE_method
      name: worry
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_noop
        nobind: 1
comment__S_056SharpParenDotDotDotThesis_0: *4
comment__S_057SharpEqualParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#='
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: opener
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
comment__S_058SharpEqual: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#='
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \N
          quant:
          - '*'
comment__S_059Sharp: !!perl/hash:RE_ast
  dba: comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \N
      quant:
      - '*'
dec_number: !!perl/hash:RE_ast
  dba: decimal number
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &5 !!perl/hash:RE_any
        altname: dec_number_0
        dba: decimal number
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: dec_number_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: escale
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: escale
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 2
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: decint
                  rest: ''
          - !!perl/hash:RE_method
            name: escale
            rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \d
                  quant:
                  - +
            quant:
            - +
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
dec_number_0: *5
decint: !!perl/hash:RE_ast
  dba: decint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - +
      quant:
      - '*'
decints: !!perl/hash:RE_ast
  dba: decints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: decint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
dotty:*:
  dic: STD
embeddedblock: !!perl/hash:RE_ast
  dba: embedded block
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: finishlex
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: statementlist
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '}'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
endid: !!perl/hash:RE_ast
  dba: endid
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        text: -[ \- \' \w ]
escale: !!perl/hash:RE_ast
  dba: escale
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_cclass
      i: 0
      text: '[Ee]'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: decint
      rest: ''
escape:*:
  dic: STD
escape__S_049none: !!perl/hash:RE_ast
  dba: escape
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
hexint: !!perl/hash:RE_ast
  dba: hexint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..9 a..f A..F ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..9 a..f A..F ]'
            quant:
            - +
      quant:
      - '*'
hexints: !!perl/hash:RE_ast
  dba: hexints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: hexint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
ident: !!perl/hash:RE_ast
  dba: ident
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: alpha
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \w
      quant:
      - '*'
identifier: !!perl/hash:RE_ast
  dba: identifier
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ident
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: apostrophe
            rest: ''
          - !!perl/hash:RE_method
            name: ident
            rest: ''
      quant:
      - '*'
infix:*:
  dic: STD
infix_circumfix_meta_operator:*:
  dic: STD
infix_postfix_meta_operator:*:
  dic: STD
infix_prefix_meta_operator:*:
  dic: STD
initializer:*:
  dic: STD
integer: !!perl/hash:RE_ast
  dba: integer
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &6 !!perl/hash:RE_any
        altname: integer_0
        dba: integer
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: integer_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '0'
          - !!perl/hash:RE_bracket
            re: &7 !!perl/hash:RE_any
              altname: integer_1
              dba: integer
              dic: STD
              zyg:
              - !!perl/hash:RE_sequence
                alt: integer_1 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: b
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: binint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: o
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: octint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: x
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: hexint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: d
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: decint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 4
                zyg:
                - !!perl/hash:RE_method
                  name: decint
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_assertion
                    assert: '!'
                    nobind: 1
                    re: !!perl/hash:RE_block
                      nobind: 1
        - !!perl/hash:RE_method
          alt: integer_0 1
          name: decint
          rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_assertion
        assert: '!'
        nobind: 1
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: &8 !!perl/hash:RE_any
                      altname: integer_2
                      dba: integer
                      dic: STD
                      zyg:
                      - !!perl/hash:RE_meta
                        alt: integer_2 0
                        min: 1
                        text: \s
                      - !!perl/hash:RE_string
                        alt: integer_2 1
                        i: 0
                        text: ','
                      - !!perl/hash:RE_string
                        alt: integer_2 2
                        i: 0
                        text: =
                      - !!perl/hash:RE_method
                        alt: integer_2 3
                        name: terminator
                        rest: ''
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: _
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
integer_0: *6
integer_1: *7
integer_2: *8
is_ok: !!perl/hash:RE_ast
  dba: is_ok
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \N
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: '#OK'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \N
          quant:
          - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_meta
      text: $$
keyspace: !!perl/hash:RE_ast
  dba: keyspace
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_cclass
              i: 0
              text: '[ \s \# ]'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
liststopper: !!perl/hash:RE_ast
  dba: liststopper
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &9 !!perl/hash:RE_any
      altname: liststopper_0
      dba: liststopper
      dic: STD
      zyg:
      - !!perl/hash:RE_method
        alt: liststopper_0 0
        name: stdstopper
        rest: ''
      - !!perl/hash:RE_string
        alt: liststopper_0 1
        i: 0
        text: ==>
      - !!perl/hash:RE_string
        alt: liststopper_0 2
        i: 0
        text: ==>>
      - !!perl/hash:RE_string
        alt: liststopper_0 3
        i: 0
        text: <==
      - !!perl/hash:RE_string
        alt: liststopper_0 4
        i: 0
        text: <<==
liststopper_0: *9
longname: !!perl/hash:RE_ast
  dba: longname
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: name
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ':'
                - !!perl/hash:RE_cclass
                  i: 0
                  text: '[ a..z A..Z _ \< \[ \« ]'
          - !!perl/hash:RE_method
            name: colonpair
            rest: ''
      quant:
      - '*'
module_name:*:
  dic: STD
morename: !!perl/hash:RE_ast
  dba: morename
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: &10 !!perl/hash:RE_any
                  altname: morename_0
                  dba: morename
                  dic: STD
                  zyg:
                  - !!perl/hash:RE_string
                    alt: morename_0 0
                    i: 0
                    text: (
                  - !!perl/hash:RE_method
                    alt: morename_0 1
                    name: alpha
                    rest: ''
            - !!perl/hash:RE_bracket
              re: &11 !!perl/hash:RE_any
                altname: morename_1
                dba: indirect name
                dic: STD
                zyg:
                - !!perl/hash:RE_method
                  alt: morename_1 0
                  name: identifier
                  rest: ''
                - !!perl/hash:RE_bracket
                  alt: morename_1 1
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: (
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: EXPR
                      rest: ''
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: )
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
          - !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_string
                  i: 0
                  text: '::'
            - !!perl/hash:RE_method
              name: panic
              rest: 1
      quant:
      - '?'
morename_0: *10
morename_1: *11
multi_declarator:*:
  dic: STD
name: !!perl/hash:RE_ast
  dba: name
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &12 !!perl/hash:RE_any
      altname: name_0
      dba: name
      dic: STD
      zyg:
      - !!perl/hash:RE_sequence
        alt: name_0 0
        zyg:
        - !!perl/hash:RE_method
          name: identifier
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: morename
            rest: ''
          quant:
          - '*'
      - !!perl/hash:RE_quantified_atom
        alt: name_0 1
        atom: !!perl/hash:RE_method
          name: morename
          rest: ''
        quant:
        - +
name_0: *12
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                name: stopper
                rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: starter
                  rest: ''
                - !!perl/hash:RE_method
                  name: nibbler
                  rest: ''
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: escape
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: .
                - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_block {}
nofun: !!perl/hash:RE_ast
  dba: nofun
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: &13 !!perl/hash:RE_any
        altname: nofun_0
        dba: nofun
        dic: STD
        zyg:
        - !!perl/hash:RE_string
          alt: nofun_0 0
          i: 0
          text: (
        - !!perl/hash:RE_string
          alt: nofun_0 1
          i: 0
          text: .(
        - !!perl/hash:RE_string
          alt: nofun_0 2
          i: 0
          text: \
        - !!perl/hash:RE_string
          alt: nofun_0 3
          i: 0
          text: ''''
        - !!perl/hash:RE_string
          alt: nofun_0 4
          i: 0
          text: '-'
        - !!perl/hash:RE_double
          alt: nofun_0 5
          i: 0
          text: ''''
        - !!perl/hash:RE_meta
          alt: nofun_0 6
          min: 1
          text: \w
nofun_0: *13
numeric:*:
  dic: STD
octint: !!perl/hash:RE_ast
  dba: octint
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[ 0..7 ]'
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ 0..7 ]'
            quant:
            - +
      quant:
      - '*'
octints: !!perl/hash:RE_ast
  dba: octints
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          name: octint
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
opener: !!perl/hash:RE_ast
  dba: opener
  dic: STD
  re: !!perl/hash:RE_cclass
    i: 0
    text: "[\n\\x{0028} \\x{003C} \\x{005B} \\x{007B} \\x{00AB} \\x{0F3A} \\x{0F3C}
      \\x{169B} \\x{2018} \\x{201A} \\x{201B}\n\\x{201C} \\x{201E} \\x{201F} \\x{2039}
      \\x{2045} \\x{207D} \\x{208D} \\x{2208} \\x{2209} \\x{220A} \\x{2215}\n\\x{223C}
      \\x{2243} \\x{2252} \\x{2254} \\x{2264} \\x{2266} \\x{2268} \\x{226A} \\x{226E}
      \\x{2270} \\x{2272}\n\\x{2274} \\x{2276} \\x{2278} \\x{227A} \\x{227C} \\x{227E}
      \\x{2280} \\x{2282} \\x{2284} \\x{2286} \\x{2288}\n\\x{228A} \\x{228F} \\x{2291}
      \\x{2298} \\x{22A2} \\x{22A6} \\x{22A8} \\x{22A9} \\x{22AB} \\x{22B0} \\x{22B2}\n\\x{22B4}
      \\x{22B6} \\x{22C9} \\x{22CB} \\x{22D0} \\x{22D6} \\x{22D8} \\x{22DA} \\x{22DC}
      \\x{22DE} \\x{22E0}\n\\x{22E2} \\x{22E4} \\x{22E6} \\x{22E8} \\x{22EA} \\x{22EC}
      \\x{22F0} \\x{22F2} \\x{22F3} \\x{22F4} \\x{22F6}\n\\x{22F7} \\x{2308} \\x{230A}
      \\x{2329} \\x{23B4} \\x{2768} \\x{276A} \\x{276C} \\x{276E} \\x{2770} \\x{2772}\n\\x{2774}
      \\x{27C3} \\x{27C5} \\x{27D5} \\x{27DD} \\x{27E2} \\x{27E4} \\x{27E6} \\x{27E8}
      \\x{27EA} \\x{2983}\n\\x{2985} \\x{2987} \\x{2989} \\x{298B} \\x{298D} \\x{298F}
      \\x{2991} \\x{2993} \\x{2995} \\x{2997} \\x{29C0}\n\\x{29C4} \\x{29CF} \\x{29D1}
      \\x{29D4} \\x{29D8} \\x{29DA} \\x{29F8} \\x{29FC} \\x{2A2B} \\x{2A2D} \\x{2A34}\n\\x{2A3C}
      \\x{2A64} \\x{2A79} \\x{2A7D} \\x{2A7F} \\x{2A81} \\x{2A83} \\x{2A8B} \\x{2A91}
      \\x{2A93} \\x{2A95}\n\\x{2A97} \\x{2A99} \\x{2A9B} \\x{2AA1} \\x{2AA6} \\x{2AA8}
      \\x{2AAA} \\x{2AAC} \\x{2AAF} \\x{2AB3} \\x{2ABB}\n\\x{2ABD} \\x{2ABF} \\x{2AC1}
      \\x{2AC3} \\x{2AC5} \\x{2ACD} \\x{2ACF} \\x{2AD1} \\x{2AD3} \\x{2AD5} \\x{2AEC}\n\\x{2AF7}
      \\x{2AF9} \\x{2E02} \\x{2E04} \\x{2E09} \\x{2E0C} \\x{2E1C} \\x{2E20} \\x{3008}
      \\x{300A} \\x{300C}\n\\x{300E} \\x{3010} \\x{3014} \\x{3016} \\x{3018} \\x{301A}
      \\x{301D} \\x{FD3E} \\x{FE17} \\x{FE35} \\x{FE37}\n\\x{FE39} \\x{FE3B} \\x{FE3D}
      \\x{FE3F} \\x{FE41} \\x{FE43} \\x{FE47} \\x{FE59} \\x{FE5B} \\x{FE5D} \\x{FF08}\n\\x{FF1C}
      \\x{FF3B} \\x{FF5B} \\x{FF5F} \\x{FF62}\n  ]"
package_declarator:*:
  dic: STD
pod_comment: !!perl/hash:RE_ast
  dba: pod_comment
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      text: ^^
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: &14 !!perl/hash:RE_any
        altname: pod_comment_0
        dba: pod_comment
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: begin
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - +
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  text: '

'
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - '*'
                    - !!perl/hash:RE_string
                      i: 0
                      text: =
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        name: unsp
                        rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_string
                      i: 0
                      text: end
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - +
                    - !!perl/hash:RE_var
                      var: $M->{'identifier'}
                    - !!perl/hash:RE_meta
                      text: »
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \N
                      quant:
                      - '*'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: .
                  quant:
                  - '*'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: begin
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_meta
                text: $$
              - !!perl/hash:RE_string
                i: 0
                text: '#'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  text: '

'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_string
                  i: 0
                  text: end
                - !!perl/hash:RE_meta
                  text: »
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: for
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: identifier
                rest: ''
              - !!perl/hash:RE_meta
                text: $$
              - !!perl/hash:RE_string
                i: 0
                text: '#'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  text: .*?
                - !!perl/hash:RE_meta
                  text: ^^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_meta
                  text: $$
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: .
                quant:
                - '*'
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 3
          zyg:
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        text: .*?
                      - !!perl/hash:RE_meta
                        text: ^^
                      - !!perl/hash:RE_string
                        i: 0
                        text: =cut
                      - !!perl/hash:RE_meta
                        text: »
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: alpha
                rest: ''
              - !!perl/hash:RE_meta
                min: 1
                text: \s
              - !!perl/hash:RE_method
                name: sorry
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \N
            quant:
            - '*'
pod_comment_0: *14
postcircumfix:*:
  dic: STD
postfix:*:
  dic: STD
postfix_prefix_meta_operator:*:
  dic: STD
prefix:*:
  dic: STD
prefix_circumfix_meta_operator:*:
  dic: STD
prefix_postfix_meta_operator:*:
  dic: STD
quibble: !!perl/hash:RE_ast
  dba: quibble
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_block {}
quote:*:
  dic: STD
quote__S_050Single_Single: !!perl/hash:RE_ast
  dba: single quotes
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_double
        i: 0
        text: ''''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ''''
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
quote__S_051Double_Double: !!perl/hash:RE_ast
  dba: double quotes
  dic: STD
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: '"'
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '"'
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
quote_mod:*:
  dic: STD
quotepair: !!perl/hash:RE_ast
  dba: colon pair (restricted)
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &15 !!perl/hash:RE_any
        altname: quotepair_0
        dba: colon pair (restricted)
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: quotepair_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: quotepair_0 1
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: quotepair_0 2
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: '[a..z]'
                quant:
                - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: (
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
quotepair_0: *15
rad_number: !!perl/hash:RE_ast
  dba: number in radix notation
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: <
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: &16 !!perl/hash:RE_any
              altname: rad_number_0
              dba: number in radix notation
              dic: STD
              zyg:
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 0
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: .
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 1
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_string
                      i: 0
                      text: .
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 2
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: alnumint
                        rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: radint
                    rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '**'
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          name: radint
                          rest: ''
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: sorry
                        rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            text: '>'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: circumfix
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: circumfix
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
rad_number_0: *16
radint: !!perl/hash:RE_ast
  dba: radint
  dic: STD
  re: !!perl/hash:RE_bracket
    re: &17 !!perl/hash:RE_any
      altname: radint_0
      dba: radint
      dic: STD
      zyg:
      - !!perl/hash:RE_method
        alt: radint_0 0
        name: integer
        rest: ''
      - !!perl/hash:RE_sequence
        alt: radint_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ':'
              - !!perl/hash:RE_meta
                min: 1
                text: \d
        - !!perl/hash:RE_method
          name: rad_number
          rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
radint_0: *17
regex_declarator:*:
  dic: STD
routine_declarator:*:
  dic: STD
scope_declarator:*:
  dic: STD
sigil:*:
  dic: STD
sigil__S_037Dollar: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: $
sigil__S_038At: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '@'
sigil__S_039Percent: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '%'
sigil__S_040Amp: !!perl/hash:RE_ast
  dba: sigil
  dic: STD
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '&'
spacey: !!perl/hash:RE_ast
  dba: spacey
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        text: '[ \s \# ]'
special_variable:*:
  dic: STD
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
statement_control:*:
  dic: STD
statement_mod_cond:*:
  dic: STD
statement_mod_loop:*:
  dic: STD
statement_prefix:*:
  dic: STD
stdstopper: !!perl/hash:RE_ast
  dba: standard stopper
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &18 !!perl/hash:RE_any
        altname: stdstopper_0
        dba: standard stopper
        dic: STD
        zyg:
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 0
          assert: '?'
          re: !!perl/hash:RE_method
            name: terminator
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 1
          assert: '?'
          re: !!perl/hash:RE_method
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 2
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              name: stopper
              rest: ''
        - !!perl/hash:RE_meta
          alt: stdstopper_0 3
          text: $
    - !!perl/hash:RE_block {}
stdstopper_0: *18
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
term:*:
  dic: STD
term__S_063miscbad: !!perl/hash:RE_ast
  dba: term
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_noop
        nobind: 1
terminator:*:
  dic: STD
terminator__S_060Thesis: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: )
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_061Ket: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ']'
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_062Ly: !!perl/hash:RE_ast
  dba: terminator
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_method
      name: O
      rest: 1
trait_mod:*:
  dic: STD
twigil:*:
  dic: STD
twigil__S_041Dot: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_042Bang: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_043Caret: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_044Colon: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_045Star: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_046Question: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_047Equal: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_method
      name: begid
      rest: ''
twigil__S_048Tilde: !!perl/hash:RE_ast
  dba: twigil
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: begid
      rest: ''
type_declarator:*:
  dic: STD
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  dic: STD
  re: !!perl/hash:RE_meta
    text: $
unsp: !!perl/hash:RE_ast
  dba: unspace
  dic: STD
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      min: 1
      text: \\
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_bracket
          re: &19 !!perl/hash:RE_any
            altname: unsp_0
            dba: unsp
            dic: STD
            zyg:
            - !!perl/hash:RE_meta
              alt: unsp_0 0
              min: 1
              text: \s
            - !!perl/hash:RE_string
              alt: unsp_0 1
              i: 0
              text: '#'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &20 !!perl/hash:RE_any
          altname: unsp_1
          dba: unspace
          dic: STD
          zyg:
          - !!perl/hash:RE_method
            alt: unsp_1 0
            name: vws
            rest: ''
          - !!perl/hash:RE_method
            alt: unsp_1 1
            name: unv
            rest: ''
          - !!perl/hash:RE_sequence
            alt: unsp_1 2
            zyg:
            - !!perl/hash:RE_meta
              text: $
            - !!perl/hash:RE_block {}
      quant:
      - '*'
unsp_0: *19
unsp_1: *20
unspacey: !!perl/hash:RE_ast
  dba: unspacey
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      name: unsp
      rest: ''
    quant:
    - '?'
unv: !!perl/hash:RE_ast
  dba: horizontal whitespace
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: &21 !!perl/hash:RE_any
        altname: unv_0
        dba: horizontal whitespace
        dic: STD
        zyg:
        - !!perl/hash:RE_quantified_atom
          alt: unv_0 0
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - +
        - !!perl/hash:RE_sequence
          alt: unv_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_bracket
                  re: &22 !!perl/hash:RE_any
                    altname: unv_1
                    dba: horizontal whitespace
                    dic: STD
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: unv_1 0
                      min: 1
                      text: \w
                    - !!perl/hash:RE_string
                      alt: unv_1 1
                      i: 0
                      text: \
          - !!perl/hash:RE_meta
            text: ^^
          - !!perl/hash:RE_method
            name: pod_comment
            rest: ''
        - !!perl/hash:RE_sequence
          alt: unv_0 2
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: comment
            rest: ''
    quant:
    - +
unv_0: *21
unv_1: *22
value:*:
  dic: STD
version:*:
  dic: STD
vws: !!perl/hash:RE_ast
  dba: vertical whitespace
  dic: STD
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_bracket
        re: &23 !!perl/hash:RE_any
          altname: vws_0
          dba: vertical whitespace
          dic: STD
          zyg:
          - !!perl/hash:RE_meta
            alt: vws_0 0
            min: 1
            text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '#DEBUG -1'
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: <<<<<<<
            - !!perl/hash:RE_meta
              text: '::'
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        text: .*?
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \v
                      - !!perl/hash:RE_string
                        i: 0
                        text: =======
                  - !!perl/hash:RE_meta
                    text: .*?
                  - !!perl/hash:RE_meta
                    min: 1
                    text: \v
                  - !!perl/hash:RE_string
                    i: 0
                    text: '>>>>>>>'
            - !!perl/hash:RE_method
              name: sorry
              rest: 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 3
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: =======
            - !!perl/hash:RE_meta
              text: '::'
            - !!perl/hash:RE_meta
              text: .*?
            - !!perl/hash:RE_meta
              min: 1
              text: \v
            - !!perl/hash:RE_string
              i: 0
              text: '>>>>>>>'
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
    quant:
    - +
vws_0: *23
ws: !!perl/hash:RE_ast
  dba: whitespace
  dic: STD
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_bracket
      re: &24 !!perl/hash:RE_any
        altname: ws_0
        dba: whitespace
        dic: STD
        zyg:
        - !!perl/hash:RE_sequence
          alt: ws_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - +
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_cclass
              i: 0
              nobind: 1
              text: '[\#\s\\]'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: ws_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: after
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_meta
            text: ':::'
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          re: &25 !!perl/hash:RE_any
            altname: ws_1
            dba: whitespace
            dic: STD
            zyg:
            - !!perl/hash:RE_method
              alt: ws_1 0
              name: unsp
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 1
              zyg:
              - !!perl/hash:RE_method
                name: vws
                rest: ''
              - !!perl/hash:RE_method
                name: heredoc
                rest: ''
            - !!perl/hash:RE_method
              alt: ws_1 2
              name: unv
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 3
              zyg:
              - !!perl/hash:RE_meta
                text: $
              - !!perl/hash:RE_block {}
        quant:
        - '*'
      - !!perl/hash:RE_block {}
ws_0: *24
ws_1: *25
RETREE_END
;
use DEBUG;
use NAME;
use Stash;
use Cursor;
our $ALL;
## method p6class ()
sub p6class {
no warnings 'recursion';
my $self = shift;
'STD::P6' };
## method TOP ($STOP = '')
sub TOP {
no warnings 'recursion';
my $self = shift;
my $STOP = @_ ? shift() : '';
my $lang = $self->cursor_fresh( $self->p6class );
if ($STOP) {
local $::GOAL = $STOP;
$lang->unitstop($STOP)->comp_unit;
}
else {
$lang->comp_unit};
};
our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1, 'pure' => 0);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non', 'pure' => 0);
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right', 'pure' => 1);
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left', 'pure' => 1);
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left', 'pure' => 1);
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left', 'pure' => 1);
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list', 'pure' => 1);
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list', 'pure' => 1);
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list', 'pure' => 1);
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %structural      = ('dba' => ('structural infix'), 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1, 'pure' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right', 'pure' => 0);
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'fiddly' => 1, 'pure' => 0);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1, 'pure' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list', 'pure' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');
our $LOOSEST = "a=!";
our $item_assignment_prec = 'i=';
our $methodcall_prec = 'y=';
local $::endsym = "null";
local $::endargs = -1;
## token category {*}
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE category');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT category';
}
else {
$x = 'ALTLTM category';
}
}
else {
$x = 'ALTLTM category';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "category", @gather);
};
@result;
}
;
## token category:category { <sym> }
sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category', $retree) }
sub category__S_000category {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000category");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "category";
$self->_MATCHIFYr($S, "category__S_000category", $C->_EXACT("category"));
}
;
## token category:sigil { <sym> }
sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil', $retree) }
sub category__S_001sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "category__S_001sigil", $C->_EXACT("sigil"));
}
;
## token sigil {*}
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE sigil');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sigil';
}
else {
$x = 'ALTLTM sigil';
}
}
else {
$x = 'ALTLTM sigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "sigil", @gather);
};
@result;
}
;
## token category:twigil { <sym> }
sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil', $retree) }
sub category__S_002twigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002twigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "twigil";
$self->_MATCHIFYr($S, "category__S_002twigil", $C->_EXACT("twigil"));
}
;
## token twigil is endsym<begid> {*}
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE twigil');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT twigil';
}
else {
$x = 'ALTLTM twigil';
}
}
else {
$x = 'ALTLTM twigil';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "twigil", @gather);
};
@result;
}
;
## token category:special_variable { <sym> }
sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable', $retree) }
sub category__S_003special_variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003special_variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "special_variable";
$self->_MATCHIFYr($S, "category__S_003special_variable", $C->_EXACT("special_variable"));
}
;
## token special_variable {*}
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE special_variable');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable';
}
else {
$x = 'ALTLTM special_variable';
}
}
else {
$x = 'ALTLTM special_variable';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "special_variable", @gather);
};
@result;
}
;
## token category:comment { <sym> }
sub category__S_004comment__PEEK { $_[0]->_AUTOLEXpeek('category__S_004comment', $retree) }
sub category__S_004comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "comment";
$self->_MATCHIFYr($S, "category__S_004comment", $C->_EXACT("comment"));
}
;
## token comment {*}
sub comment__PEEK { $_[0]->_AUTOLEXpeek('comment:*',$retree); }
sub comment {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE comment');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'comment') {
$C->deb("Fate passed to comment: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT comment';
}
else {
$x = 'ALTLTM comment';
}
}
else {
$x = 'ALTLTM comment';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'comment:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("comment trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "comment", @gather);
};
@result;
}
;
## token category:version { <sym> }
sub category__S_005version__PEEK { $_[0]->_AUTOLEXpeek('category__S_005version', $retree) }
sub category__S_005version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_005version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "category__S_005version", $C->_EXACT("version"));
}
;
## token version {*}
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE version');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT version';
}
else {
$x = 'ALTLTM version';
}
}
else {
$x = 'ALTLTM version';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "version", @gather);
};
@result;
}
;
## token category:module_name { <sym> }
sub category__S_006module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_006module_name', $retree) }
sub category__S_006module_name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_006module_name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module_name";
$self->_MATCHIFYr($S, "category__S_006module_name", $C->_EXACT("module_name"));
}
;
## token module_name {*}
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE module_name');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT module_name';
}
else {
$x = 'ALTLTM module_name';
}
}
else {
$x = 'ALTLTM module_name';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "module_name", @gather);
};
@result;
}
;
## token category:value { <sym> }
sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value', $retree) }
sub category__S_007value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_007value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "category__S_007value", $C->_EXACT("value"));
}
;
## token value {*}
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE value');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'value') {
$C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT value';
}
else {
$x = 'ALTLTM value';
}
}
else {
$x = 'ALTLTM value';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'value:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "value", @gather);
};
@result;
}
;
## token category:term { <sym> }
sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term', $retree) }
sub category__S_008term {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_008term");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "term";
$self->_MATCHIFYr($S, "category__S_008term", $C->_EXACT("term"));
}
;
## token term {*}
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE term');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term';
}
else {
$x = 'ALTLTM term';
}
}
else {
$x = 'ALTLTM term';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "term", @gather);
};
@result;
}
;
## token category:numeric { <sym> }
sub category__S_009numeric__PEEK { $_[0]->_AUTOLEXpeek('category__S_009numeric', $retree) }
sub category__S_009numeric {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_009numeric");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "numeric";
$self->_MATCHIFYr($S, "category__S_009numeric", $C->_EXACT("numeric"));
}
;
## token numeric {*}
sub numeric__PEEK { $_[0]->_AUTOLEXpeek('numeric:*',$retree); }
sub numeric {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE numeric');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'numeric') {
$C->deb("Fate passed to numeric: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT numeric';
}
else {
$x = 'ALTLTM numeric';
}
}
else {
$x = 'ALTLTM numeric';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'numeric:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("numeric trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "numeric", @gather);
};
@result;
}
;
## token category:quote { <sym> }
sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote', $retree) }
sub category__S_010quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_010quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "category__S_010quote", $C->_EXACT("quote"));
}
;
## token quote () {*}
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote';
}
else {
$x = 'ALTLTM quote';
}
}
else {
$x = 'ALTLTM quote';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quote", @gather);
};
@result;
}
;
## token category:prefix { <sym> }
sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix', $retree) }
sub category__S_011prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_011prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix";
$self->_MATCHIFYr($S, "category__S_011prefix", $C->_EXACT("prefix"));
}
;
## token prefix is unary is defequiv(%symbolic_unary) {*}
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix';
}
else {
$x = 'ALTLTM prefix';
}
}
else {
$x = 'ALTLTM prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix", @gather);
};
@result;
}
;
## token category:infix { <sym> }
sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix', $retree) }
sub category__S_012infix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_012infix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix";
$self->_MATCHIFYr($S, "category__S_012infix", $C->_EXACT("infix"));
}
;
## token infix is binary is defequiv(%additive) {*}
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix';
}
else {
$x = 'ALTLTM infix';
}
}
else {
$x = 'ALTLTM infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix", @gather);
};
@result;
}
;
## token category:postfix { <sym> }
sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix', $retree) }
sub category__S_013postfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_013postfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix";
$self->_MATCHIFYr($S, "category__S_013postfix", $C->_EXACT("postfix"));
}
;
## token postfix is unary is defequiv(%autoincrement) {*}
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix';
}
else {
$x = 'ALTLTM postfix';
}
}
else {
$x = 'ALTLTM postfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postfix", @gather);
};
@result;
}
;
## token category:dotty { <sym> }
sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty', $retree) }
sub category__S_014dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_014dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "category__S_014dotty", $C->_EXACT("dotty"));
}
;
## token dotty is endsym<unspacey> {*}
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE dotty');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty';
}
else {
$x = 'ALTLTM dotty';
}
}
else {
$x = 'ALTLTM dotty';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "dotty", @gather);
};
@result;
}
;
## token category:circumfix { <sym> }
sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix', $retree) }
sub category__S_015circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_015circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "category__S_015circumfix", $C->_EXACT("circumfix"));
}
;
## token circumfix {*}
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE circumfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT circumfix';
}
else {
$x = 'ALTLTM circumfix';
}
}
else {
$x = 'ALTLTM circumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "circumfix", @gather);
};
@result;
}
;
## token category:postcircumfix { <sym> }
sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix', $retree) }
sub category__S_016postcircumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_016postcircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postcircumfix";
$self->_MATCHIFYr($S, "category__S_016postcircumfix", $C->_EXACT("postcircumfix"));
}
;
## token postcircumfix is unary {*}  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postcircumfix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix';
}
else {
$x = 'ALTLTM postcircumfix';
}
}
else {
$x = 'ALTLTM postcircumfix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postcircumfix", @gather);
};
@result;
}
;
## token category:quote_mod { <sym> }
sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod', $retree) }
sub category__S_017quote_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_017quote_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote_mod";
$self->_MATCHIFYr($S, "category__S_017quote_mod", $C->_EXACT("quote_mod"));
}
;
## token quote_mod {*}
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quote_mod');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote_mod';
}
else {
$x = 'ALTLTM quote_mod';
}
}
else {
$x = 'ALTLTM quote_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quote_mod", @gather);
};
@result;
}
;
## token category:trait_mod { <sym> }
sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod', $retree) }
sub category__S_018trait_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_018trait_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trait_mod";
$self->_MATCHIFYr($S, "category__S_018trait_mod", $C->_EXACT("trait_mod"));
}
;
## token trait_mod is endsym<keyspace> {*}
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE trait_mod');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'trait_mod') {
$C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod';
}
else {
$x = 'ALTLTM trait_mod';
}
}
else {
$x = 'ALTLTM trait_mod';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "trait_mod", @gather);
};
@result;
}
;
## token category:initializer { <sym> }
sub category__S_019initializer__PEEK { $_[0]->_AUTOLEXpeek('category__S_019initializer', $retree) }
sub category__S_019initializer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_019initializer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "initializer";
$self->_MATCHIFYr($S, "category__S_019initializer", $C->_EXACT("initializer"));
}
;
## token initializer is endsym<ws> {*}
sub initializer__PEEK { $_[0]->_AUTOLEXpeek('initializer:*',$retree); }
sub initializer {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE initializer');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'initializer') {
$C->deb("Fate passed to initializer: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT initializer';
}
else {
$x = 'ALTLTM initializer';
}
}
else {
$x = 'ALTLTM initializer';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'initializer:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("initializer trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "initializer", @gather);
};
@result;
}
;
## token category:type_declarator { <sym> }
sub category__S_020type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020type_declarator', $retree) }
sub category__S_020type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_020type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "category__S_020type_declarator", $C->_EXACT("type_declarator"));
}
;
## token type_declarator is endsym<keyspace> {*}
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE type_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator';
}
else {
$x = 'ALTLTM type_declarator';
}
}
else {
$x = 'ALTLTM type_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "type_declarator", @gather);
};
@result;
}
;
## token category:scope_declarator { <sym> }
sub category__S_021scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021scope_declarator', $retree) }
sub category__S_021scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_021scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "category__S_021scope_declarator", $C->_EXACT("scope_declarator"));
}
;
## token scope_declarator is endsym<nofun> {*}
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE scope_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scope_declarator';
}
else {
$x = 'ALTLTM scope_declarator';
}
}
else {
$x = 'ALTLTM scope_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "scope_declarator", @gather);
};
@result;
}
;
## token category:package_declarator { <sym> }
sub category__S_022package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022package_declarator', $retree) }
sub category__S_022package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_022package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "category__S_022package_declarator", $C->_EXACT("package_declarator"));
}
;
## token package_declarator is endsym<keyspace> {*}
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE package_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT package_declarator';
}
else {
$x = 'ALTLTM package_declarator';
}
}
else {
$x = 'ALTLTM package_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "package_declarator", @gather);
};
@result;
}
;
## token category:multi_declarator { <sym> }
sub category__S_023multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023multi_declarator', $retree) }
sub category__S_023multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_023multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "category__S_023multi_declarator", $C->_EXACT("multi_declarator"));
}
;
## token multi_declarator is endsym<keyspace> {*}
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE multi_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT multi_declarator';
}
else {
$x = 'ALTLTM multi_declarator';
}
}
else {
$x = 'ALTLTM multi_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "multi_declarator", @gather);
};
@result;
}
;
## token category:routine_declarator { <sym> }
sub category__S_024routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024routine_declarator', $retree) }
sub category__S_024routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_024routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "category__S_024routine_declarator", $C->_EXACT("routine_declarator"));
}
;
## token routine_declarator is endsym<nofun> {*}
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE routine_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_declarator';
}
else {
$x = 'ALTLTM routine_declarator';
}
}
else {
$x = 'ALTLTM routine_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "routine_declarator", @gather);
};
@result;
}
;
## token category:regex_declarator { <sym> }
sub category__S_025regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_025regex_declarator', $retree) }
sub category__S_025regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_025regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "category__S_025regex_declarator", $C->_EXACT("regex_declarator"));
}
;
## token regex_declarator is endsym<keyspace> {*}
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_declarator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_declarator';
}
else {
$x = 'ALTLTM regex_declarator';
}
}
else {
$x = 'ALTLTM regex_declarator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "regex_declarator", @gather);
};
@result;
}
;
## token category:statement_prefix { <sym> }
sub category__S_026statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_prefix', $retree) }
sub category__S_026statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_026statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "category__S_026statement_prefix", $C->_EXACT("statement_prefix"));
}
;
## rule  statement_prefix () {*}
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_prefix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_prefix';
}
else {
$x = 'ALTLTM statement_prefix';
}
}
else {
$x = 'ALTLTM statement_prefix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_prefix", @gather);
};
@result;
}
;
## token category:statement_control { <sym> }
sub category__S_027statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_control', $retree) }
sub category__S_027statement_control {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_027statement_control");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_control";
$self->_MATCHIFYr($S, "category__S_027statement_control", $C->_EXACT("statement_control"));
}
;
## rule  statement_control is endsym<keyspace> {*}
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_control');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control';
}
else {
$x = 'ALTLTM statement_control';
}
}
else {
$x = 'ALTLTM statement_control';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_control", @gather);
};
@result;
}
;
## token category:statement_mod_cond { <sym> }
sub category__S_028statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_cond', $retree) }
sub category__S_028statement_mod_cond {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_028statement_mod_cond");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_cond";
$self->_MATCHIFYr($S, "category__S_028statement_mod_cond", $C->_EXACT("statement_mod_cond"));
}
;
## rule  statement_mod_cond is endsym<nofun> {*}
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_cond');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_cond';
}
else {
$x = 'ALTLTM statement_mod_cond';
}
}
else {
$x = 'ALTLTM statement_mod_cond';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_mod_cond", @gather);
};
@result;
}
;
## token category:statement_mod_loop { <sym> }
sub category__S_029statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_029statement_mod_loop', $retree) }
sub category__S_029statement_mod_loop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_029statement_mod_loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_loop";
$self->_MATCHIFYr($S, "category__S_029statement_mod_loop", $C->_EXACT("statement_mod_loop"));
}
;
## rule  statement_mod_loop is endsym<nofun> {*}
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE statement_mod_loop');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_mod_loop';
}
else {
$x = 'ALTLTM statement_mod_loop';
}
}
else {
$x = 'ALTLTM statement_mod_loop';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "statement_mod_loop", @gather);
};
@result;
}
;
## token category:infix_prefix_meta_operator { <sym> }
sub category__S_030infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_prefix_meta_operator', $retree) }
sub category__S_030infix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_030infix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_030infix_prefix_meta_operator", $C->_EXACT("infix_prefix_meta_operator"));
}
;
## token infix_prefix_meta_operator is binary {*}
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_prefix_meta_operator';
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_prefix_meta_operator", @gather);
};
@result;
}
;
## token category:infix_postfix_meta_operator { <sym> }
sub category__S_031infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_postfix_meta_operator', $retree) }
sub category__S_031infix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_031infix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_031infix_postfix_meta_operator", $C->_EXACT("infix_postfix_meta_operator"));
}
;
## token infix_postfix_meta_operator ($op) is binary {*}
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_postfix_meta_operator';
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_postfix_meta_operator", @gather);
};
@result;
}
;
## token category:infix_circumfix_meta_operator { <sym> }
sub category__S_032infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032infix_circumfix_meta_operator', $retree) }
sub category__S_032infix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_032infix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_032infix_circumfix_meta_operator", $C->_EXACT("infix_circumfix_meta_operator"));
}
;
## token infix_circumfix_meta_operator is binary {*}
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE infix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator", @gather);
};
@result;
}
;
## token category:postfix_prefix_meta_operator { <sym> }
sub category__S_033postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033postfix_prefix_meta_operator', $retree) }
sub category__S_033postfix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_033postfix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_033postfix_prefix_meta_operator", $C->_EXACT("postfix_prefix_meta_operator"));
}
;
## token postfix_prefix_meta_operator is unary {*}
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE postfix_prefix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator';
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator", @gather);
};
@result;
}
;
## token category:prefix_postfix_meta_operator { <sym> }
sub category__S_034prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_postfix_meta_operator', $retree) }
sub category__S_034prefix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_034prefix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_034prefix_postfix_meta_operator", $C->_EXACT("prefix_postfix_meta_operator"));
}
;
## token prefix_postfix_meta_operator is unary {*}
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_postfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator", @gather);
};
@result;
}
;
## token category:prefix_circumfix_meta_operator { <sym> }
sub category__S_035prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035prefix_circumfix_meta_operator', $retree) }
sub category__S_035prefix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_035prefix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_035prefix_circumfix_meta_operator", $C->_EXACT("prefix_circumfix_meta_operator"));
}
;
## token prefix_circumfix_meta_operator is unary {*}
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE prefix_circumfix_meta_operator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_circumfix_meta_operator';
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
}
else {
$x = 'ALTLTM prefix_circumfix_meta_operator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "prefix_circumfix_meta_operator", @gather);
};
@result;
}
;
## token category:terminator { <sym> }
sub category__S_036terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_036terminator', $retree) }
sub category__S_036terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_036terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "terminator";
$self->_MATCHIFYr($S, "category__S_036terminator", $C->_EXACT("terminator"));
}
;
## token terminator {*}
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE terminator');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT terminator';
}
else {
$x = 'ALTLTM terminator';
}
}
else {
$x = 'ALTLTM terminator';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "terminator", @gather);
};
@result;
}
;
## token unspacey { <.unsp>? }
sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey', $retree) }
sub unspacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unspacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unspacey", $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}));
}
;
## token begid { <?before \w> }
sub begid__PEEK { $_[0]->_AUTOLEXpeek('begid', $retree) }
sub begid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE begid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "begid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}));
}
;
## token endid { <?before <-[ \- \' \w ]> > }
sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid', $retree) }
sub endid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE endid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "endid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
}))) { ($C) } else { () }
}));
}
;
## token spacey { <?before <[ \s \# ]> > }
sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey', $retree) }
sub spacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE spacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "spacey", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
}))) { ($C) } else { () }
}));
}
;
## token keyspace { <!before '('> [ <?before <[ \s \# ]> > || <.panic: "Whitespace required after keywo
sub keyspace__PEEK { $_[0]->_AUTOLEXpeek('keyspace', $retree) }
sub keyspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE keyspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "keyspace", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Whitespace required after keyword"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token nofun { <!before '(' | '.(' | '\\' | '\'' | '-' | "'" | \w > }
sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun', $retree) }
sub nofun {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nofun");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nofun", $C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_0') {
$C->deb("Fate passed to nofun_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nofun_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nofun_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'nofun_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("nofun_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}));
}
;
## token sigil:sym<$>  { <sym> }
sub sigil__S_037Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_037Dollar', $retree) }
sub sigil__S_037Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_037Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "sigil__S_037Dollar", $C->_EXACT("\$"));
}
;
## token sigil:sym<@>  { <sym> }
sub sigil__S_038At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_038At', $retree) }
sub sigil__S_038At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_038At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "sigil__S_038At", $C->_EXACT("\@"));
}
;
## token sigil:sym<%>  { <sym> }
sub sigil__S_039Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_039Percent', $retree) }
sub sigil__S_039Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_039Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "sigil__S_039Percent", $C->_EXACT("\%"));
}
;
## token sigil:sym<&>  { <sym> }
sub sigil__S_040Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_040Amp', $retree) }
sub sigil__S_040Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_040Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "sigil__S_040Amp", $C->_EXACT("\&"));
}
;
## token twigil:sym<.> { <sym> }
sub twigil__S_041Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_041Dot', $retree) }
sub twigil__S_041Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_041Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "twigil__S_041Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<!> { <sym> }
sub twigil__S_042Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_042Bang', $retree) }
sub twigil__S_042Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_042Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "twigil__S_042Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<^> { <sym> }
sub twigil__S_043Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_043Caret', $retree) }
sub twigil__S_043Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_043Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "twigil__S_043Caret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<:> { <sym> }
sub twigil__S_044Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_044Colon', $retree) }
sub twigil__S_044Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_044Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "twigil__S_044Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<*> { <sym> }
sub twigil__S_045Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_045Star', $retree) }
sub twigil__S_045Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_045Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "twigil__S_045Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<?> { <sym> }
sub twigil__S_046Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_046Question', $retree) }
sub twigil__S_046Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_046Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "twigil__S_046Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<=> { <sym> }
sub twigil__S_047Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_047Equal', $retree) }
sub twigil__S_047Equal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_047Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "twigil__S_047Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token twigil:sym<~> { <sym> }
sub twigil__S_048Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_048Tilde', $retree) }
sub twigil__S_048Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_048Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "twigil__S_048Tilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~"))
and ($C) = ($C->begid)) {
$C
} else { () }

});
}
;
## token stopper { <!> }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## regex liststopper {
sub liststopper__PEEK { $_[0]->_AUTOLEXpeek('liststopper', $retree) }
sub liststopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE liststopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "liststopper", $C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'liststopper_0') {
$C->deb("Fate passed to liststopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT liststopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM liststopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'liststopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("liststopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUME(['stdstopper'], sub {
my $C = shift;
$C->stdstopper
})
},
sub {
my $C=shift;
$C->_EXACT("\=\=\>")
},
sub {
my $C=shift;
$C->_EXACT("\=\=\>\>")
},
sub {
my $C=shift;
$C->_EXACT("\<\=\=")
},
sub {
my $C=shift;
$C->_EXACT("\<\<\=\=")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## regex stdstopper {
sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper', $retree) }
sub stdstopper {
no warnings 'recursion';
my $self = shift;

local $::STUB = $::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'endstmt'};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stdstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "stdstopper", LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} ||= 1}, $C)
},
$C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_0') {
$C->deb("Fate passed to stdstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT stdstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM stdstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("stdstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->terminator
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->unitstopper
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})));
}
;
## token longname {
sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname', $retree) }
sub longname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE longname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "longname", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))
and ($C) = (scalar(do {
}, $C))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:[a-zA-Z_\<\[\«]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token name {
sub name__PEEK { $_[0]->_AUTOLEXpeek('name', $retree) }
sub name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'morename'} = [];
$self->_MATCHIFYr($S, "name", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_0') {
$C->deb("Fate passed to name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
} else { () }
},
sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token morename {
sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename', $retree) }
sub morename {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE morename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'identifier'} = [];
$self->_MATCHIFYr($S, "morename", do {
if (my ($C) = ($C->_EXACT("\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_0') {
$C->deb("Fate passed to morename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'morename_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("morename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_1') {
$C->deb("Fate passed to morename_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT morename_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM morename_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'morename_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("morename_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'indirect name', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Name component may not be null"))) {
$C
} else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## method peek_delimiters
sub peek_delimiters {
no warnings 'recursion';
my $self = shift;
my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($self->orig,$pos++,1);
if ($char =~ /^\s$/) {
$self->panic("Whitespace character is not allowed as delimiter")}
elsif ($char =~ /^\w$/) {
$self->panic("Alphanumeric character is not allowed as delimiter")}
elsif ($char eq '') {
$self->panic("No delimiter found")}
elsif (not ord $char) {
$self->panic("Null character is not allowed as delimiter")}
elsif ($STD::close2open{$char}) {
$self->panic("Use of a closing delimiter for an opener is reserved")}
elsif ($char eq ':') {
$self->panic("Colons may not be used to delimit quoting constructs")};
my $rightbrack = $STD::open2close{$char};
if (not defined $rightbrack) {
return $char, $char};
while (substr($self->orig,$pos,1) eq $char) {
$pos++}
;
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
};
{     package STD::startstop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($start, $stop) = @_;
my $mangle = ::mangle($start, $stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$start' => $start, '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::startstop', 1 };
our $REGEXES = {
ALL => [ qw/starter stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD::startstop
  re: !!perl/hash:RE_var
    var: $start
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::startstop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token starter { $start }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_EXACT($start));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
{     package STD::stop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::stop', 1 };
our $REGEXES = {
ALL => [ qw/starter stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  dic: STD::stop
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::stop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
{     package STD::unitstop;
require "mangle.pl";
our %INSTANTIATED;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::unitstop', 1 };
our $REGEXES = {
ALL => [ qw/unitstopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  dic: STD::unitstop
  re: !!perl/hash:RE_var
    var: $stop
RETREE_END
## token unitstopper { $stop }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_EXACT($stop));
}
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
}
1; };
## token unitstopper { $ }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_PATTERN(qr/\G\z/));
}
;
## method balanced ($start,$stop)
sub balanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument start omitted' unless @_;
my $start = @_ ? shift() : undef;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::startstop->__instantiate__($start,$stop) )};
## method unbalanced ($stop)
sub unbalanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::stop->__instantiate__($stop) )};
## method unitstop ($stop)
sub unitstop {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::unitstop->__instantiate__($stop) )};
## method truly ($bool,$opt)
sub truly {
no warnings 'recursion';
my $self = shift;
die 'Required argument bool omitted' unless @_;
my $bool = @_ ? shift() : undef;
die 'Required argument opt omitted' unless @_;
my $opt = @_ ? shift() : undef;
return $self if $bool;
$self->sorry("Cannot negate $opt adverb");
$self;
};
## token charname {
sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname', $retree) }
sub charname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charname", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_0') {
$C->deb("Fate passed to charname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_PATTERN(qr/\G[_[:alpha:]]/))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_1') {
$C->deb("Fate passed to charname_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charname_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charname_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charname_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charname_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\#")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
if (my ($C) = ($C->sorry("Unrecognized character name"))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }

}
};
@gather;
});
}
;
## token charnames { \s* [<charname><.ws>] +% [','\s*] }
sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames', $retree) }
sub charnames {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charnames");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'charname'} = [];
$self->_MATCHIFYr($S, "charnames", do {
if (my ($C) = ($C->_PATTERN(qr/\G\s*+/))) {
$C->_REPSEPr( sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\,\s*+/)
}))) { ($C) } else { () }
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token charspec {
sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec', $retree) }
sub charspec {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charspec");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charspec", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_0') {
$C->deb("Fate passed to charspec_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT charspec_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM charspec_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'charspec_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("charspec_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['charnames'], sub {
my $C = shift;
$C->charnames
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'character name', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->sorry("Unrecognized \\c character"))) {
$C->cursor_incr()
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token backslash {*}
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}
;
## token escape {*}
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE escape');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape';
}
else {
$x = 'ALTLTM escape';
}
}
else {
$x = 'ALTLTM escape';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "escape", @gather);
};
@result;
}
;
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token escape:none { <!> }
sub escape__S_049none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_049none', $retree) }
sub escape__S_049none {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_049none");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "none";
$self->_MATCHIFYr($S, "escape__S_049none", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## method nibble ($lang)
sub nibble {
no warnings 'recursion';
my $self = shift;
die 'Required argument lang omitted' unless @_;
my $lang = @_ ? shift() : undef;
$self->cursor_fresh($lang)->nibbler};
## token nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

my $text = '';my $from = $self->{'_pos'};my $to = $from;my @nibbles = ();my $multiline = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escape'} = [];
$C->{'nibbler'} = [];
$C->{'starter'} = [];
$C->{'stopper'} = [];
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = (scalar(do {
$self->from = $self->{'_pos'}}, $C))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'stopper'} = [];
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C;
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
my $n = $M->{'nibbler'}->[-1]->{'nibbles'};
my @n = @$n;
push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};
$text = '';
$to = $from = $C->{'_pos'};
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C;
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
push @nibbles, $M->{'escape'}->[-1];
$text = '';
$to = $from = $C->{'_pos'};
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->cursor_incr())) {
scalar(do {
my $ch = substr($self->orig, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++};
}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;
$M->{'nibbles'} = \@nibbles;
$self->pos = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$::LAST_NIBBLE = $C;
$::LAST_NIBBLE_MULTILINE = $C if $multiline;
}, $C)
} else { () }

});
}
;
## token babble ($l) {
sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble', $retree) }
sub babble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang = $l;my $start;my $stop;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE babble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "babble", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak( ($kv->{'k'} => $kv->{'v'}))
or $lang->sorry("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEblock('B', sub {
my $C = shift;
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
[$lang,$start,$stop];
})
} else { () }

});
}
;
our @herestub_queue;
{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Herestub', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

moose_has 'delim' => (isa => 'Str', is => 'rw');
moose_has 'orignode' => (is => 'rw');
moose_has 'lang' => (is => 'rw');
1; };
{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::herestop', 1 };
our $REGEXES = {
ALL => [ qw/stopper/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::herestop
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      text: ^^
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - '*'
    - !!perl/hash:RE_var
      var: $::DELIM
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unv
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \v
      quant:
      - '?'
RETREE_END
## token stopper { ^^ {} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['ws'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})

})
}))
and ($C) = ($C->_EXACT($::DELIM))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)\n?+/)
},
$C->_OPTf(sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
}))
} else { () }

});
}
1; };
## method heredoc ()
sub heredoc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found")};
}
;
return $self->cursor($here->{'_pos'});
};
## token quibble ($l) {
sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble', $retree) }
sub quibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my ($lang, $start, $stop);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
if ($lang->{'_herelang'}) {
push @herestub_queue,
'STD::Herestub'->new(
delim => $M->{'nibble'}->{'nibbles'}->[0]->{'TEXT'},
orignode => $C,
lang => $lang->{'_herelang'},
)}}, $C)
} else { () }

});
}
;
## token quotepair {
sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair', $retree) }
sub quotepair {
no warnings 'recursion';
my $self = shift;

my $key;my $value;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quotepair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$self->_MATCHIFYr($S, "quotepair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_0') {
$C->deb("Fate passed to quotepair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quotepair_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quotepair_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'quotepair_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quotepair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Argument not allowed on negated pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;
$value = $M->{'circumfix'}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['n'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_SUBSUMEr(['id'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[a-z])++/)

})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("2nd argument not allowed on pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'id'}->Str;
$value = $M->{'n'}->Str;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_SUBSUMEblock('k', sub {
my $C = shift;
$key}))) {
$C->_SUBSUMEblock('v', sub {
my $C = shift;
$value})
} else { () }

});
}
;
## token quote:sym<' '>   { :dba('single quotes') "'" ~ "'" <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_050Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_050Single_Single', $retree) }
sub quote__S_050Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_050Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "quote__S_050Single_Single", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\'";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\'"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\'")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'single quotes', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token quote:sym<" ">   { :dba('double quotes') '"' ~ '"' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_051Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_051Double_Double', $retree) }
sub quote__S_051Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_051Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "quote__S_051Double_Double", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\"";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\""))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\"")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'double quotes', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym<« »>   { :dba('shell-quote words') '«' ~ '»' <nibble($¢.cursor_fresh( %*LANG<Q> 
sub circumfix__S_052Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_052Fre_Nch', $retree) }
sub circumfix__S_052Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_052Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "circumfix__S_052Fre_Nch", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "»";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("«"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«<< >>» { :dba('shell-quote words') '<<' ~ '>>' <nibble($¢.cursor_fresh( %*LANG<Q
sub circumfix__S_053LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_053LtLt_GtGt', $retree) }
sub circumfix__S_053LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_053LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "circumfix__S_053LtLt_GtGt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«< >»   { :dba('quote words') '<' ~ '>'
sub circumfix__S_054Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_054Lt_Gt', $retree) }
sub circumfix__S_054Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_054Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "circumfix__S_054Lt_Gt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("STDIN\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<STDIN>', '$' . '*IN.lines (or add whitespace to suppress warning)'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<>', "lines() to read input,\n  or ('') to represent the null string,\n  or () to represent Nil"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
})
} else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'quote words', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token ws {
sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }
sub ws {
no warnings 'recursion';
my $self = shift;

local $::STUB = $::STUB = return $self if exists $::MEMOS[$self->{'_pos'}]->{'ws'};my $startpos = $self->{'_pos'};local $::HIGHEXPECT = {
};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ws", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {
$C->deb("Fate passed to ws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'ws_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("ws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]++/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITRULE())
and ($C) = (scalar(do {
delete $::MEMOS[$startpos]->{'ws'}}, $C))
and ($C) = ($C->sorry("Whitespace is required between alphanumeric tokens"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_1') {
$C->deb("Fate passed to ws_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT ws_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM ws_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'ws_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("ws_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->vws)
and ($C) = ($C->heredoc)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) {
scalar(do {
if (($C->{'_pos'} == $startpos)) {
delete $::MEMOS[$C->{'_pos'}]->{'ws'}}
else {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = $::MEMOS[$startpos]->{'endstmt'}
if exists $::MEMOS[$startpos]->{'endstmt'};
}}, $C)
} else { () }

}
};
@gather;
});
}
;
## token unsp {
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
$C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unsp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_1') {
$C->deb("Fate passed to unsp_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unsp_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->vws)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token vws {
sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws', $retree) }
sub vws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vws", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vws_0') {
$C->deb("Fate passed to vws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT vws_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM vws_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'vws_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("vws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\n/)
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\#DEBUG\ \-1"))
and ($C) = (scalar(do {
say "DEBUG";
$::DEBUG = -1;
}, $C))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\<\<\<\<\<\<"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\=\=\=\=\=\=\=/)
},
$C->_SCANf())
}))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>/)
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry('Found a version control conflict marker'))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\=\=\=\=\=\="))
and ($C) = ($C->_COMMITLTM())) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>[^\n]*+\n/)
},
$C->_SCANf())
} else { () }

})) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))) { ($C) } else { () }
}));
}
;
## method moreinput ()
sub moreinput {
no warnings 'recursion';
my $self = shift;
$::moreinput->() if $::moreinput;
$self;
};
## token unv {
sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv', $retree) }
sub unv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'comment'} = [];
$self->_MATCHIFYr($S, "unv", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_0') {
$C->deb("Fate passed to unv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unv_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]++/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_1') {
$C->deb("Fate passed to unv_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unv_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unv_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'unv_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unv_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = ($C->pod_comment)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
$C->_SUBSUMEr(['comment'], sub {
my $C = shift;
$C->comment
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}));
}
;
## token comment:sym<#`(...)> {
sub comment__S_055SharpGraveParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_055SharpGraveParenDotDotDotThesis', $retree) }
sub comment__S_055SharpGraveParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_055SharpGraveParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\`\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_055SharpGraveParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Opening bracket is required for #` comment"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->quibble($C->cursor_fresh( $::LANG{'Q'} )))) {
$C
} else { () }

});
}
;
## token comment:sym<#(...)> {
sub comment__S_056SharpParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_056SharpParenDotDotDotThesis', $retree) }
sub comment__S_056SharpParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_056SharpParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_056SharpParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->suppose(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[,;:])*+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'comment__S_056SharpParenDotDotDotThesis_0') {
$C->deb("Fate passed to comment__S_056SharpParenDotDotDotThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT comment__S_056SharpParenDotDotDotThesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM comment__S_056SharpParenDotDotDotThesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'comment__S_056SharpParenDotDotDotThesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("comment__S_056SharpParenDotDotDotThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\#")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))
and ($C) = ($C->worry("Embedded comment seems to be missing backtick"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

});
}
;
## token comment:sym<#=(...)> {
sub comment__S_057SharpEqualParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_057SharpEqualParenDotDotDotThesis', $retree) }
sub comment__S_057SharpEqualParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_057SharpEqualParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_057SharpEqualParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }

});
}
;
## token comment:sym<#=> {
sub comment__S_058SharpEqual__PEEK { $_[0]->_AUTOLEXpeek('comment__S_058SharpEqual', $retree) }
sub comment__S_058SharpEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_058SharpEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=";
$self->_MATCHIFYr($S, "comment__S_058SharpEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['attachment'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
})
} else { () }

});
}
;
## token comment:sym<#> {
sub comment__S_059Sharp__PEEK { $_[0]->_AUTOLEXpeek('comment__S_059Sharp', $retree) }
sub comment__S_059Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_059Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "comment__S_059Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = (scalar(do {
}, $C))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

});
}
;
## token ident {
sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident', $retree) }
sub ident {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ident");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ident", $C->_PATTERN(qr/\G[_[:alpha:]]\w*+/));
}
;
## token apostrophe {
sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe', $retree) }
sub apostrophe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE apostrophe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "apostrophe", $C->_PATTERN(qr/\G['\-]/));
}
;
## token identifier {
sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier', $retree) }
sub identifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "identifier", do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->apostrophe)
and ($C) = ($C->ident)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token pod_comment {
sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment', $retree) }
sub pod_comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pod_comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pod_comment", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_0') {
$C->deb("Fate passed to pod_comment_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pod_comment_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pod_comment_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pod_comment_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend[\x20\t\r]++/))
and ($C) = ($C->_BACKREFn('identifier'))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) {
$C
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'identifier'}->Str eq 'END'})
}))) {
$C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
my $id = $M->{'identifier'}->Str;
$self->panic("=begin $id without matching =end $id");
}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =begin"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$self->panic("=begin without matching =end")}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =for"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+(?m:$)/)
},
$C->_SCANf()))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)\=cut\b/)
},
$C->_SCANf()))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Obsolescent pod format, please use =begin/=end instead"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G[_[:alpha:]]/)
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\s/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Illegal pod directive"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token embeddedblock {
sub embeddedblock__PEEK { $_[0]->_AUTOLEXpeek('embeddedblock', $retree) }
sub embeddedblock {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local $::SIGNUM;local $::GOAL = '}';local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE embeddedblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "embeddedblock", do {
my $C = $C;
if (($C) = ($C->newlex)
and ($C) = ($C->finishlex)
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse statement list; couldn't find right brace"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token binints { [<.ws><binint><.ws>] +% ',' }
sub binints__PEEK { $_[0]->_AUTOLEXpeek('binints', $retree) }
sub binints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'binint'} = [];
$self->_MATCHIFYr($S, "binints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token binint {
sub binint__PEEK { $_[0]->_AUTOLEXpeek('binint', $retree) }
sub binint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "binint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-1])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-1])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token octints { [<.ws><octint><.ws>] +% ',' }
sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints', $retree) }
sub octints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'octint'} = [];
$self->_MATCHIFYr($S, "octints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token octint {
sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint', $retree) }
sub octint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "octint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-7])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-7])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token hexints { [<.ws><hexint><.ws>] +% ',' }
sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints', $retree) }
sub hexints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];
$self->_MATCHIFYr($S, "hexints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token hexint {
sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint', $retree) }
sub hexint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "hexint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-fA-F])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-fA-F])++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token decints { [<.ws><decint><.ws>] +% ',' }
sub decints__PEEK { $_[0]->_AUTOLEXpeek('decints', $retree) }
sub decints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'decint'} = [];
$self->_MATCHIFYr($S, "decints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token decint {
sub decint__PEEK { $_[0]->_AUTOLEXpeek('decint', $retree) }
sub decint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "decint", do {
if (my ($C) = ($C->_PATTERN(qr/\G\d++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_\d++/)
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token integer {
sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer', $retree) }
sub integer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE integer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "integer", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_0') {
$C->deb("Fate passed to integer_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_1') {
$C->deb("Fate passed to integer_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gb_?+/))) {
$C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Go_?+/))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gx_?+/))) {
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\Gd_?+/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$C->worry("Leading 0 does not indicate octal in Perl 6; please use 0o" . $M->{'decint'}->Str . " if you mean that") })
}))) { ($C) } else { () }
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'terminator'} = [];
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_2') {
$C->deb("Fate passed to integer_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT integer_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM integer_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'integer_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("integer_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Decimal point must be followed by digit"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token radint {
sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint', $retree) }
sub radint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE radint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "radint", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_0') {
$C->deb("Fate passed to radint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT radint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM radint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'radint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("radint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
defined $M->{'rad_number'}->{'intpart'}
and
not defined $M->{'rad_number'}->{'fracpart'}
})
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token escale {
sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale', $retree) }
sub escale {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escale");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "escale", do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee](?:[+\-])?+/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }

});
}
;
## token dec_number {
sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number', $retree) }
sub dec_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dec_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escale'} = [];
$self->_MATCHIFYr($S, "dec_number", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_0') {
$C->deb("Fate passed to dec_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dec_number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dec_number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'dec_number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dec_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
})
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Number contains two decimal points (missing 'v' for version number?)"))) {
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d++/)
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token alnumint {
sub alnumint__PEEK { $_[0]->_AUTOLEXpeek('alnumint', $retree) }
sub alnumint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE alnumint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "alnumint", $C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-zA-Z])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-zA-Z])++/)
}))) { ($C) } else { () }
})
} else { () }
}));
}
;
## token rad_number {
sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number', $retree) }
sub rad_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE rad_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'base'} = [];
$C->{'exp'} = [];
$self->_MATCHIFYr($S, "rad_number", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'rad_number_0') {
$C->deb("Fate passed to rad_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT rad_number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM rad_number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD', 'rad_number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("rad_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\."))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->sorry("Base is missing ** exponent part"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\>"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed radix number"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token terminator:sym<)>
sub terminator__S_060Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_060Thesis', $retree) }
sub terminator__S_060Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_060Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "terminator__S_060Thesis", do {
if (my ($C) = ($C->_EXACT("\)"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<]>
sub terminator__S_061Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_061Ket', $retree) }
sub terminator__S_061Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_061Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "terminator__S_061Ket", do {
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<}>
sub terminator__S_062Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_062Ly', $retree) }
sub terminator__S_062Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_062Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\}";
$self->_MATCHIFYr($S, "terminator__S_062Ly", do {
if (my ($C) = ($C->_EXACT("\}"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);
our %close2open = reverse %open2close;
## token opener {
sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener', $retree) }
sub opener {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE opener");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "opener", $C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/));
}
;
{ package STD::P6;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::P6', 1 };
our $REGEXES = {
ALL => [ qw/POST PRE arglist args blast block blockoid capterm capture circumfix coloncircumfix colonpair comp_unit curlycheck declarator default_value deflongname defterm desigilname dotty dottyop dottyopish dumbsmart eat_terminator fakesignature fatarrow infix infix_circumfix_meta_operator infix_postfix_meta_operator infix_prefix_meta_operator infixish infixstopper initializer label lambda macro_def method_def methodop modifier_expr module_name multi_declarator multisig named_param named_param_term nullterm nulltermish number numeric old_rx_mods old_tr_mods package_declarator package_def param_sep param_var parameter pblock post_constraint postcircumfix postfix postfix_prefix_meta_operator postop prefix prefix_postfix_meta_operator privop quasiquibble quote quote_mod regex_block regex_declarator regex_def routine_declarator routine_def scope_declarator scoped semiarglist semilist sibble signature sigterm special_variable statement statement_control statement_mod_cond statement_mod_loop statement_prefix statementlist sublongname subshortname term terminator termish trait trait_mod tribble type_constraint type_declarator typename unitstart value variable variable_declarator version vnum xblock/ ],
circumfix => [ qw/circumfix__S_191sigil__PEEK circumfix__S_192Paren_Thesis__PEEK circumfix__S_193Bra_Ket__PEEK circumfix__S_214Cur_Ly__PEEK/ ],
dotty => [ qw/dotty__S_194DotStar__PEEK dotty__S_195Dot__PEEK/ ],
infix => [ qw/infix__S_190lambda__PEEK infix__S_216Dot__PEEK infix__S_222StarStar__PEEK infix__S_237Star__PEEK infix__S_238Slash__PEEK infix__S_239div__PEEK infix__S_240Percent__PEEK infix__S_241PercentPercent__PEEK infix__S_242mod__PEEK infix__S_243gcd__PEEK infix__S_244lcm__PEEK infix__S_245PlusAmp__PEEK infix__S_246LtLt__PEEK infix__S_247GtGt__PEEK infix__S_248TildeAmp__PEEK infix__S_249QuestionAmp__PEEK infix__S_250TildeLt__PEEK infix__S_251TildeGt__PEEK infix__S_252PlusLt__PEEK infix__S_253PlusGt__PEEK infix__S_254Plus__PEEK infix__S_255Minus__PEEK infix__S_256PlusVert__PEEK infix__S_257PlusCaret__PEEK infix__S_258TildeVert__PEEK infix__S_259TildeCaret__PEEK infix__S_260QuestionVert__PEEK infix__S_261QuestionCaret__PEEK infix__S_262x__PEEK infix__S_263xx__PEEK infix__S_264Tilde__PEEK infix__S_265Amp__PEEK infix__S_266Vert__PEEK infix__S_267Caret__PEEK infix__S_272LtEqualGt__PEEK infix__S_273cmp__PEEK infix__S_274leg__PEEK infix__S_275but__PEEK infix__S_276does__PEEK infix__S_277DotDot__PEEK infix__S_278CaretDotDot__PEEK infix__S_279DotDotCaret__PEEK infix__S_280CaretDotDotCaret__PEEK infix__S_281EqualEqual__PEEK infix__S_282BangEqual__PEEK infix__S_283Lt__PEEK infix__S_284LtEqual__PEEK infix__S_285Gt__PEEK infix__S_286GtEqual__PEEK infix__S_287TildeTilde__PEEK infix__S_288BangTilde__PEEK infix__S_289EqualTilde__PEEK infix__S_290eq__PEEK infix__S_291ne__PEEK infix__S_292lt__PEEK infix__S_293le__PEEK infix__S_294gt__PEEK infix__S_295ge__PEEK infix__S_296EqualColonEqual__PEEK infix__S_297EqualEqualEqual__PEEK infix__S_298eqv__PEEK infix__S_299before__PEEK infix__S_300after__PEEK infix__S_301AmpAmp__PEEK infix__S_302VertVert__PEEK infix__S_303CaretCaret__PEEK infix__S_304SlashSlash__PEEK infix__S_305min__PEEK infix__S_306max__PEEK infix__S_307QuestionQuestion_BangBang__PEEK infix__S_308BangBang__PEEK infix__S_309Question__PEEK infix__S_310ff__PEEK infix__S_311Caretff__PEEK infix__S_312ffCaret__PEEK infix__S_313CaretffCaret__PEEK infix__S_314fff__PEEK infix__S_315Caretfff__PEEK infix__S_316fffCaret__PEEK infix__S_317CaretfffCaret__PEEK infix__S_318Equal__PEEK infix__S_319ColonEqual__PEEK infix__S_320ColonColonEqual__PEEK infix__S_321DotEqual__PEEK infix__S_322EqualGt__PEEK infix__S_325Comma__PEEK infix__S_326Colon__PEEK infix__S_327X__PEEK infix__S_328Z__PEEK infix__S_329minmax__PEEK infix__S_330DotDotDot__PEEK infix__S_336and__PEEK infix__S_337andthen__PEEK infix__S_338or__PEEK infix__S_339orelse__PEEK infix__S_340xor__PEEK infix__S_341LtEqualEqual__PEEK infix__S_342EqualEqualGt__PEEK infix__S_343LtLtEqualEqual__PEEK infix__S_344EqualEqualGtGt__PEEK/ ],
infix_circumfix_meta_operator => [ qw/infix_circumfix_meta_operator__S_204Fre_Nch__PEEK infix_circumfix_meta_operator__S_205LtLt_GtGt__PEEK/ ],
infix_postfix_meta_operator => [ qw/infix_postfix_meta_operator__S_206Equal__PEEK/ ],
infix_prefix_meta_operator => [ qw/infix_prefix_meta_operator__S_199Bang__PEEK infix_prefix_meta_operator__S_200R__PEEK infix_prefix_meta_operator__S_201S__PEEK infix_prefix_meta_operator__S_202X__PEEK infix_prefix_meta_operator__S_203Z__PEEK/ ],
initializer => [ qw/initializer__S_165Equal__PEEK initializer__S_166ColonEqual__PEEK initializer__S_167ColonColonEqual__PEEK initializer__S_168DotEqual__PEEK/ ],
module_name => [ qw/module_name__S_038normal__PEEK/ ],
multi_declarator => [ qw/multi_declarator__S_057multi__PEEK multi_declarator__S_058proto__PEEK multi_declarator__S_059only__PEEK multi_declarator__S_060null__PEEK/ ],
numeric => [ qw/numeric__S_136rational__PEEK numeric__S_137complex__PEEK numeric__S_138number__PEEK/ ],
package_declarator => [ qw/package_declarator__S_047class__PEEK package_declarator__S_048grammar__PEEK package_declarator__S_049module__PEEK package_declarator__S_050package__PEEK package_declarator__S_051role__PEEK package_declarator__S_052knowhow__PEEK package_declarator__S_053slang__PEEK package_declarator__S_054require__PEEK package_declarator__S_055trusts__PEEK package_declarator__S_056also__PEEK/ ],
postcircumfix => [ qw/postcircumfix__S_207Paren_Thesis__PEEK postcircumfix__S_208Bra_Ket__PEEK postcircumfix__S_209Cur_Ly__PEEK postcircumfix__S_210Lt_Gt__PEEK postcircumfix__S_211LtLt_GtGt__PEEK postcircumfix__S_212Fre_Nch__PEEK/ ],
postfix => [ qw/postfix__S_215i__PEEK postfix__S_217MinusGt__PEEK postfix__S_218PlusPlus__PEEK postfix__S_219MinusMinus__PEEK/ ],
postfix_prefix_meta_operator => [ qw/postfix_prefix_meta_operator__S_198Nch__PEEK/ ],
prefix => [ qw/prefix__S_220PlusPlus__PEEK prefix__S_221MinusMinus__PEEK prefix__S_223Bang__PEEK prefix__S_224Plus__PEEK prefix__S_225Minus__PEEK prefix__S_226TildeTilde__PEEK prefix__S_227Tilde__PEEK prefix__S_228QuestionQuestion__PEEK prefix__S_229Question__PEEK prefix__S_230TildeCaret__PEEK prefix__S_231PlusCaret__PEEK prefix__S_232QuestionCaret__PEEK prefix__S_233CaretCaret__PEEK prefix__S_234Caret__PEEK prefix__S_235VertVert__PEEK prefix__S_236Vert__PEEK prefix__S_268sleep__PEEK prefix__S_269abs__PEEK prefix__S_270let__PEEK prefix__S_271temp__PEEK prefix__S_323so__PEEK prefix__S_324not__PEEK/ ],
prefix_postfix_meta_operator => [ qw/prefix_postfix_meta_operator__S_197Fre__PEEK/ ],
quote => [ qw/quote__S_139SlashSlash__PEEK quote__S_140Slash_Slash__PEEK quote__S_141qq__PEEK quote__S_142q__PEEK quote__S_143Q__PEEK quote__S_155rx__PEEK quote__S_156m__PEEK quote__S_157ms__PEEK quote__S_158s__PEEK quote__S_159ss__PEEK quote__S_160tr__PEEK quote__S_161quasi__PEEK/ ],
quote_mod => [ qw/quote_mod__S_144w__PEEK quote_mod__S_145ww__PEEK quote_mod__S_146p__PEEK quote_mod__S_147x__PEEK quote_mod__S_148to__PEEK quote_mod__S_149s__PEEK quote_mod__S_150a__PEEK quote_mod__S_151h__PEEK quote_mod__S_152f__PEEK quote_mod__S_153c__PEEK quote_mod__S_154b__PEEK/ ],
regex_declarator => [ qw/regex_declarator__S_065regex__PEEK regex_declarator__S_066token__PEEK regex_declarator__S_067rule__PEEK/ ],
routine_declarator => [ qw/routine_declarator__S_061sub__PEEK routine_declarator__S_062method__PEEK routine_declarator__S_063submethod__PEEK routine_declarator__S_064macro__PEEK/ ],
scope_declarator => [ qw/scope_declarator__S_040my__PEEK scope_declarator__S_041our__PEEK scope_declarator__S_042anon__PEEK scope_declarator__S_043state__PEEK scope_declarator__S_044augment__PEEK scope_declarator__S_045supersede__PEEK scope_declarator__S_046has__PEEK/ ],
special_variable => [ qw/special_variable__S_089Dollar_a2___PEEK special_variable__S_090DollarBang__PEEK special_variable__S_091DollarBangCur_Ly__PEEK special_variable__S_092DollarSlash__PEEK special_variable__S_093DollarTilde__PEEK special_variable__S_094DollarGrave__PEEK special_variable__S_095DollarAt__PEEK special_variable__S_096DollarSharp__PEEK special_variable__S_097DollarDollar__PEEK special_variable__S_098DollarPercent__PEEK special_variable__S_099DollarCaretX__PEEK special_variable__S_100DollarCaret__PEEK special_variable__S_101DollarAmp__PEEK special_variable__S_102DollarStar__PEEK special_variable__S_103DollarThesis__PEEK special_variable__S_104DollarMinus__PEEK special_variable__S_105DollarEqual__PEEK special_variable__S_106AtPlus__PEEK special_variable__S_107PercentPlus__PEEK special_variable__S_108DollarPlusBra_Ket__PEEK special_variable__S_109AtPlusBra_Ket__PEEK special_variable__S_110AtPlusCur_Ly__PEEK special_variable__S_111AtMinus__PEEK special_variable__S_112PercentMinus__PEEK special_variable__S_113DollarMinusBra_Ket__PEEK special_variable__S_114AtMinusBra_Ket__PEEK special_variable__S_115PercentMinusCur_Ly__PEEK special_variable__S_116DollarPlus__PEEK special_variable__S_117DollarCurCaret_Ly__PEEK special_variable__S_118ColonColonCur_Ly__PEEK special_variable__S_119DollarCur_Ly__PEEK special_variable__S_120DollarBra__PEEK special_variable__S_121DollarKet__PEEK special_variable__S_122DollarBack__PEEK special_variable__S_123DollarVert__PEEK special_variable__S_124DollarColon__PEEK special_variable__S_125DollarSemi__PEEK special_variable__S_126DollarSingle__PEEK special_variable__S_127DollarDouble__PEEK special_variable__S_128DollarComma__PEEK special_variable__S_129DollarLt__PEEK special_variable__S_130DollarGt__PEEK special_variable__S_131DollarDot__PEEK special_variable__S_132DollarQuestion__PEEK/ ],
statement_control => [ qw/statement_control__S_000need__PEEK statement_control__S_001import__PEEK statement_control__S_002use__PEEK statement_control__S_003no__PEEK statement_control__S_004if__PEEK statement_control__S_005unless__PEEK statement_control__S_006while__PEEK statement_control__S_007until__PEEK statement_control__S_008repeat__PEEK statement_control__S_009loop__PEEK statement_control__S_010for__PEEK statement_control__S_011given__PEEK statement_control__S_012when__PEEK statement_control__S_013default__PEEK statement_control__S_028CATCH__PEEK statement_control__S_029CONTROL__PEEK statement_control__S_030TEMP__PEEK/ ],
statement_mod_cond => [ qw/statement_mod_cond__S_031if__PEEK statement_mod_cond__S_032unless__PEEK statement_mod_cond__S_033when__PEEK/ ],
statement_mod_loop => [ qw/statement_mod_loop__S_034while__PEEK statement_mod_loop__S_035until__PEEK statement_mod_loop__S_036for__PEEK statement_mod_loop__S_037given__PEEK/ ],
statement_prefix => [ qw/statement_prefix__S_014BEGIN__PEEK statement_prefix__S_015CHECK__PEEK statement_prefix__S_016INIT__PEEK statement_prefix__S_017START__PEEK statement_prefix__S_018ENTER__PEEK statement_prefix__S_019FIRST__PEEK statement_prefix__S_020END__PEEK statement_prefix__S_021LEAVE__PEEK statement_prefix__S_022KEEP__PEEK statement_prefix__S_023UNDO__PEEK statement_prefix__S_024NEXT__PEEK statement_prefix__S_025LAST__PEEK statement_prefix__S_026PRE__PEEK statement_prefix__S_027POST__PEEK statement_prefix__S_169sink__PEEK statement_prefix__S_170try__PEEK statement_prefix__S_171quietly__PEEK statement_prefix__S_172gather__PEEK statement_prefix__S_173contend__PEEK statement_prefix__S_174async__PEEK statement_prefix__S_175maybe__PEEK statement_prefix__S_176lazy__PEEK statement_prefix__S_177do__PEEK statement_prefix__S_178lift__PEEK/ ],
term => [ qw/term__S_074fatarrow__PEEK term__S_075variable__PEEK term__S_076package_declarator__PEEK term__S_077scope_declarator__PEEK term__S_078multi_declarator__PEEK term__S_079routine_declarator__PEEK term__S_080regex_declarator__PEEK term__S_081type_declarator__PEEK term__S_082circumfix__PEEK term__S_083dotty__PEEK term__S_084value__PEEK term__S_085capterm__PEEK term__S_086sigterm__PEEK term__S_087statement_prefix__PEEK term__S_088colonpair__PEEK term__S_179new__PEEK term__S_180ColonColonQuestionIDENT__PEEK term__S_181undef__PEEK term__S_182proceed__PEEK term__S_183time__PEEK term__S_184now__PEEK term__S_185self__PEEK term__S_186defer__PEEK term__S_187rand__PEEK term__S_188Star__PEEK term__S_189StarStar__PEEK term__S_196reduce__PEEK term__S_213lambda__PEEK term__S_331DotDotDot__PEEK term__S_332QuestionQuestionQuestion__PEEK term__S_333BangBangBang__PEEK term__S_334identifier__PEEK term__S_335name__PEEK/ ],
terminator => [ qw/terminator__S_345Semi__PEEK terminator__S_346if__PEEK terminator__S_347unless__PEEK terminator__S_348while__PEEK terminator__S_349until__PEEK terminator__S_350for__PEEK terminator__S_351given__PEEK terminator__S_352when__PEEK terminator__S_353MinusMinusGt__PEEK terminator__S_354BangBang__PEEK/ ],
trait_mod => [ qw/trait_mod__S_068is__PEEK trait_mod__S_069hides__PEEK trait_mod__S_070does__PEEK trait_mod__S_071will__PEEK trait_mod__S_072of__PEEK trait_mod__S_073handles__PEEK/ ],
type_declarator => [ qw/type_declarator__S_162subset__PEEK type_declarator__S_163enum__PEEK type_declarator__S_164constant__PEEK/ ],
value => [ qw/value__S_133quote__PEEK value__S_134number__PEEK value__S_135version__PEEK/ ],
version => [ qw/version__S_039v__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
POST: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &1 !!perl/hash:RE_any
          altname: POST_0
          dba: POST
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_method
            alt: POST_0 0
            name: unsp
            rest: ''
          - !!perl/hash:RE_string
            alt: POST_0 1
            i: 0
            text: \
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: postfix_prefix_meta_operator
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: POST_1
        dba: postfix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: POST_1 0
          zyg:
          - !!perl/hash:RE_method
            name: dotty
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: POST_1 1
          zyg:
          - !!perl/hash:RE_method
            name: privop
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: POST_1 2
          zyg:
          - !!perl/hash:RE_method
            name: postop
            rest: ''
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
POST_0: *1
POST_1: *2
PRE: !!perl/hash:RE_ast
  dba: prefix or meta-prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: PRE_0
        dba: prefix or meta-prefix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: PRE_0 0
          zyg:
          - !!perl/hash:RE_method
            name: prefix
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: PRE_0 1
          zyg:
          - !!perl/hash:RE_method
            name: prefix_circumfix_meta_operator
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: prefix_postfix_meta_operator
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
PRE_0: *3
arglist: !!perl/hash:RE_ast
  dba: argument list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &4 !!perl/hash:RE_any
        altname: arglist_0
        dba: argument list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_assertion
          alt: arglist_0 0
          assert: '?'
          re: !!perl/hash:RE_method
            name: stdstopper
            rest: ''
        - !!perl/hash:RE_sequence
          alt: arglist_0 1
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
          - !!perl/hash:RE_block {}
arglist_0: *4
args: !!perl/hash:RE_ast
  dba: 'extra arglist after (...):'
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &5 !!perl/hash:RE_any
        altname: args_0
        dba: argument list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_bracket
          alt: args_0 0
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: semiarglist
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 1
          zyg:
          - !!perl/hash:RE_method
            name: unsp
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: semiarglist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 2
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_meta
                      min: 1
                      text: \s
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method
                    name: infixstopper
                    rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
            quant:
            - '?'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \s
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: arglist
              rest: ''
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_block {}
args_0: *5
blast: !!perl/hash:RE_ast
  dba: blast
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &6 !!perl/hash:RE_any
      altname: blast_0
      dba: blast
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: blast_0 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_meta
              min: 1
              text: \s
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_bracket
          re: &7 !!perl/hash:RE_any
            altname: blast_1
            dba: blast
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_method
              alt: blast_1 0
              name: block
              rest: ''
            - !!perl/hash:RE_method
              alt: blast_1 1
              name: statement
              rest: ''
      - !!perl/hash:RE_method
        alt: blast_0 1
        name: panic
        rest: 1
blast_0: *6
blast_1: *7
block: !!perl/hash:RE_ast
  dba: scoped block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '{'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: blockoid
      rest: ''
    - !!perl/hash:RE_method
      name: checkyada
      rest: ''
blockoid: !!perl/hash:RE_ast
  dba: blockoid
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: finishlex
      rest: ''
    - !!perl/hash:RE_bracket
      re: &8 !!perl/hash:RE_any
        altname: blockoid_0
        dba: block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: blockoid_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{YOU_ARE_HERE}'
          - !!perl/hash:RE_method
            name: you_are_here
            rest: ''
        - !!perl/hash:RE_sequence
          alt: blockoid_0 1
          zyg:
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: '{'
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: statementlist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '}'
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_method
            name: curlycheck
            rest: 1
        - !!perl/hash:RE_sequence
          alt: blockoid_0 2
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method
              name: terminator
              rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: blockoid_0 3
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_noop
              nobind: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
blockoid_0: *8
capterm: !!perl/hash:RE_ast
  dba: capterm
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: \
    - !!perl/hash:RE_bracket
      re: &9 !!perl/hash:RE_any
        altname: capterm_0
        dba: capterm
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: capterm_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: (
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: capture
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_string
            i: 0
            text: )
        - !!perl/hash:RE_sequence
          alt: capterm_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \S
          - !!perl/hash:RE_method
            name: termish
            rest: ''
        - !!perl/hash:RE_sequence
          alt: capterm_0 2
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
capterm_0: *9
capture: !!perl/hash:RE_ast
  dba: capture
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
circumfix__S_191sigil: !!perl/hash:RE_ast
  dba: contextualizer
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
circumfix__S_192Paren_Thesis: !!perl/hash:RE_ast
  dba: parenthesized expression
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
circumfix__S_193Bra_Ket: !!perl/hash:RE_ast
  dba: array composer
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
circumfix__S_214Cur_Ly: !!perl/hash:RE_ast
  dba: circumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
coloncircumfix: !!perl/hash:RE_ast
  dba: coloncircumfix
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &10 !!perl/hash:RE_any
      altname: coloncircumfix_0
      dba: coloncircumfix
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: coloncircumfix_0 0
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: <>
        - !!perl/hash:RE_method
          name: worry
          rest: 1
      - !!perl/hash:RE_method
        alt: coloncircumfix_0 1
        name: circumfix
        rest: ''
coloncircumfix_0: *10
colonpair: !!perl/hash:RE_ast
  dba: colon pair
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &11 !!perl/hash:RE_any
        altname: colonpair_0
        dba: signature
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: colonpair_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_meta
            text: '::'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: identifier
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: colonpair_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  name: circumfix
                  rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: colonpair_0 2
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: unsp
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: coloncircumfix
                  rest: 1
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          alt: colonpair_0 3
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: fakesignature
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: colonpair_0 4
          zyg:
          - !!perl/hash:RE_method
            name: coloncircumfix
            rest: 1
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: colonpair_0 5
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bracket
                  re: &12 !!perl/hash:RE_any
                    altname: colonpair_1
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: colonpair_1 0
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_method
                          name: twigil
                          rest: ''
                        quant:
                        - '?'
                      - !!perl/hash:RE_method
                        name: desigilname
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: colonpair_1 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: <
                      - !!perl/hash:RE_method
                        name: desigilname
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: '>'
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
colonpair_0: *11
colonpair_1: *12
comp_unit: !!perl/hash:RE_ast
  dba: comp_unit
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: unitstart
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: statementlist
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
curlycheck: !!perl/hash:RE_ast
  dba: curlycheck
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_first
      zyg:
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_meta
                text: $$
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \h
              quant:
              - '*'
            - !!perl/hash:RE_cclass
              i: 0
              text: '[\\,:]'
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: unv
          rest: ''
        - !!perl/hash:RE_meta
          text: $$
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: unsp
            rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_block {}
declarator: !!perl/hash:RE_ast
  dba: declarator
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &13 !!perl/hash:RE_any
      altname: declarator_0
      dba: declarator
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: declarator_0 0
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: \
        - !!perl/hash:RE_method
          name: defterm
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_method
              name: initializer
              rest: ''
            - !!perl/hash:RE_method
              name: sorry
              rest: 1
      - !!perl/hash:RE_sequence
        alt: declarator_0 1
        zyg:
        - !!perl/hash:RE_method
          name: variable_declarator
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: initializer
            rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    text: ','
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_block {}
          quant:
          - '?'
      - !!perl/hash:RE_sequence
        alt: declarator_0 2
        zyg:
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: signature
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_method
          name: ws
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: trait
            rest: ''
          quant:
          - '*'
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: initializer
            rest: ''
          quant:
          - '?'
      - !!perl/hash:RE_method
        alt: declarator_0 3
        name: routine_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 4
        name: regex_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 5
        name: type_declarator
        rest: ''
declarator_0: *13
default_value: !!perl/hash:RE_ast
  dba: default_value
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
deflongname: !!perl/hash:RE_ast
  dba: new name to be defined
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: name
      rest: ''
    - !!perl/hash:RE_bracket
      re: &14 !!perl/hash:RE_any
        altname: deflongname_0
        dba: new name to be defined
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: deflongname_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: colonpair
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block
          alt: deflongname_0 1
deflongname_0: *14
defterm: !!perl/hash:RE_ast
  dba: new term to be defined
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_bracket
      re: &15 !!perl/hash:RE_any
        altname: defterm_0
        dba: new term to be defined
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: defterm_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: colonpair
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block
          alt: defterm_0 1
defterm_0: *15
desigilname: !!perl/hash:RE_ast
  dba: desigilname
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &16 !!perl/hash:RE_any
      altname: desigilname_0
      dba: desigilname
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: desigilname_0 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            name: variable
            rest: ''
      - !!perl/hash:RE_sequence
        alt: desigilname_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              name: sigil
              rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          quant:
          - '?'
        - !!perl/hash:RE_method
          name: variable
          rest: ''
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        alt: desigilname_0 2
        name: longname
        rest: ''
desigilname_0: *16
dotty__S_194DotStar: !!perl/hash:RE_ast
  dba: dotty
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: .
          - !!perl/hash:RE_bracket
            re: &17 !!perl/hash:RE_any
              altname: dotty__S_194DotStar_0
              dba: dotty
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_cclass
                alt: dotty__S_194DotStar_0 0
                i: 0
                text: '[+*?=]'
              - !!perl/hash:RE_sequence
                alt: dotty__S_194DotStar_0 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: '!'
                  quant:
                  - '?'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      name: dottyop
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
dotty__S_194DotStar_0: *17
dotty__S_195Dot: !!perl/hash:RE_ast
  dba: dotty
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: unspacey
      i: 0
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      name: dottyop
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
dottyop: !!perl/hash:RE_ast
  dba: dotty method or postfix
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &18 !!perl/hash:RE_any
      altname: dottyop_0
      dba: dotty method or postfix
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_method
        alt: dottyop_0 0
        name: methodop
        rest: ''
      - !!perl/hash:RE_method
        alt: dottyop_0 1
        name: colonpair
        rest: ''
      - !!perl/hash:RE_sequence
        alt: dottyop_0 2
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method
            name: alpha
            rest: ''
        - !!perl/hash:RE_method
          name: postop
          rest: ''
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_block {}
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_block {}
dottyop_0: *18
dottyopish: !!perl/hash:RE_ast
  dba: dottyopish
  dic: STD::P6
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: dottyop
      rest: ''
dumbsmart: !!perl/hash:RE_ast
  dba: dumbsmart
  dic: STD::P6
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          quant:
          - '*'
        - !!perl/hash:RE_bindpos
          atom: !!perl/hash:RE_paren
            re: &19 !!perl/hash:RE_any
              altname: dumbsmart_0
              dba: dumbsmart
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: dumbsmart_0 0
                i: 0
                text: True
              - !!perl/hash:RE_string
                alt: dumbsmart_0 1
                i: 0
                text: False
              - !!perl/hash:RE_string
                alt: dumbsmart_0 2
                i: 0
                text: Bool::True
              - !!perl/hash:RE_string
                alt: dumbsmart_0 3
                i: 0
                text: Bool::False
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_meta
              min: 1
              text: \s
        - !!perl/hash:RE_block {}
    quant:
    - '?'
dumbsmart_0: *19
eat_terminator: !!perl/hash:RE_ast
  dba: eat_terminator
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_first
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: ;
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: ws
          rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: &20 !!perl/hash:RE_any
            altname: eat_terminator_0
            dba: eat_terminator
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_string
              alt: eat_terminator_0 0
              i: 0
              text: )
            - !!perl/hash:RE_string
              alt: eat_terminator_0 1
              i: 0
              text: ']'
            - !!perl/hash:RE_string
              alt: eat_terminator_0 2
              i: 0
              text: '}'
      - !!perl/hash:RE_meta
        text: $
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method
          name: stopper
          rest: ''
      - !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method_re
              name: suppose
              nobind: 1
              re: !!perl/hash:RE_method
                name: statement_control
                rest: ''
        - !!perl/hash:RE_method
          name: backup_ws
          rest: ''
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: panic
          rest: 1
      - !!perl/hash:RE_method
        name: panic
        rest: 1
eat_terminator_0: *20
fakesignature: !!perl/hash:RE_ast
  dba: fakesignature
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_method
      name: signature
      rest: ''
fatarrow: !!perl/hash:RE_ast
  dba: fatarrow
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: identifier
        rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: =>
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: EXPR
        rest: 1
infix__S_190lambda: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &21 !!perl/hash:RE_any
          altname: infix__S_190lambda_0
          dba: infix
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 0
            i: 0
            text: '{'
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 1
            i: 0
            text: ->
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_190lambda_0: *21
infix__S_216Dot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: .
    - !!perl/hash:RE_cclass
      i: 0
      text: '[\]\)\},:\s\$"'']'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
infix__S_222StarStar: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_237Star: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_238Slash: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: /
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_239div: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: div
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_240Percent: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_241PercentPercent: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%%'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_242mod: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: mod
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_243gcd: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: gcd
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_244lcm: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lcm
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_245PlusAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_246LtLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <<
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_247GtGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_248TildeAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_249QuestionAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?&
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_250TildeLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~<
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_251TildeGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~>
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_252PlusLt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +<
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_253PlusGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +>
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_254Plus: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: +
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_255Minus: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '-'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_256PlusVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_257PlusCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_258TildeVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_259TildeCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_260QuestionVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?|
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_261QuestionCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_262x: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_263xx: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: xx
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_264Tilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_265Amp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_266Vert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_267Caret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_272LtEqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <=>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_273cmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: cmp
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_274leg: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: leg
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_275but: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: but
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_276does: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_277DotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &22 !!perl/hash:RE_any
                altname: infix__S_277DotDot_0
                dba: infix
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: infix__S_277DotDot_0 0
                  i: 0
                  text: )
                - !!perl/hash:RE_string
                  alt: infix__S_277DotDot_0 1
                  i: 0
                  text: ']'
          - !!perl/hash:RE_method
            name: panic
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_277DotDot_0: *22
infix__S_278CaretDotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^..
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_279DotDotCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_280CaretDotDotCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^..^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_281EqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: =
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_282BangEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!='
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_283Lt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: <
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_284LtEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_285Gt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '>'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_286GtEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '>='
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_287TildeTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
infix__S_288BangTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!~'
    - !!perl/hash:RE_meta
      min: 1
      text: \s
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_289EqualTilde: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =~
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_290eq: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: eq
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_291ne: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ne
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_292lt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lt
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_293le: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: le
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_294gt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: gt
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_295ge: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ge
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_296EqualColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =:=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_297EqualEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ===
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_298eqv: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: eqv
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_299before: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: before
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_300after: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: after
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_301AmpAmp: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_302VertVert: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_303CaretCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_304SlashSlash: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: //
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_305min: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: min
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_306max: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: max
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_307QuestionQuestion_BangBang: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ??
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '!!'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '::'
                - !!perl/hash:RE_cclass
                  i: 0
                  text: -[=]
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \n
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \N
                        quant:
                        - '*'
                  quant:
                  - '?'
          - !!perl/hash:RE_string
            i: 0
            text: '!!'
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_308BangBang: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!!'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method_re
            name: suppose
            nobind: 1
            re: !!perl/hash:RE_method
              name: infixish
              rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
infix__S_309Question: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '?'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: -[;]
            quant:
            - '*'
          - !!perl/hash:RE_string
            i: 0
            text: ':'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_310ff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_311Caretff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^ff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_312ffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_313CaretffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^ff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_314fff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: fff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_315Caretfff: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^fff
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_316fffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: fff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_317CaretfffCaret: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^fff^
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_318Equal: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: O
            rest: 1
        - !!perl/hash:RE_method
          name: O
          rest: 1
infix__S_319ColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: :=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_320ColonColonEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ::=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_321DotEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: .=
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_322EqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: =>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_325Comma: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ','
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: '...'
          - !!perl/hash:RE_method
            name: worry
            rest: 1
      quant:
      - '?'
infix__S_326Colon: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &23 !!perl/hash:RE_any
          altname: infix__S_326Colon_0
          dba: infix
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: infix__S_326Colon_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_method
            alt: infix__S_326Colon_0 1
            name: terminator
            rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_326Colon_0: *23
infix__S_327X: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_328Z: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_329minmax: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: minmax
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_330DotDotDot: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: ^
      quant:
      - '?'
infix__S_336and: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: and
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_337andthen: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: andthen
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_338or: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: or
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_339orelse: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: orelse
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_340xor: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: xor
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_341LtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <==
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_342EqualEqualGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_343LtLtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: <<==
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix__S_344EqualEqualGtGt: !!perl/hash:RE_ast
  dba: infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ==>>
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_circumfix_meta_operator__S_204Fre_Nch: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &24 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_204Fre_Nch_0
        dba: infix_circumfix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 0
          i: 0
          text: «
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 1
          i: 0
          text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - &25 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_204Fre_Nch_1
          dba: infix_circumfix_meta_operator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 0
            i: 0
            text: «
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 1
            i: 0
            text: »
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
infix_circumfix_meta_operator__S_204Fre_Nch_0: *24
infix_circumfix_meta_operator__S_204Fre_Nch_1: *25
infix_circumfix_meta_operator__S_205LtLt_GtGt: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &26 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_0
        dba: infix_circumfix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 0
          i: 0
          text: <<
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 1
          i: 0
          text: '>>'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - &27 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_1
          dba: infix_circumfix_meta_operator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 0
            i: 0
            text: <<
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 1
            i: 0
            text: '>>'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
infix_circumfix_meta_operator__S_205LtLt_GtGt_0: *26
infix_circumfix_meta_operator__S_205LtLt_GtGt_1: *27
infix_postfix_meta_operator__S_206Equal: !!perl/hash:RE_ast
  dba: infix_postfix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: =
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_prefix_meta_operator__S_199Bang: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '!'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: infixish
          rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: O
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: panic
          rest: 1
infix_prefix_meta_operator__S_200R: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: R
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
infix_prefix_meta_operator__S_201S: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
infix_prefix_meta_operator__S_202X: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infix_prefix_meta_operator__S_203Z: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
infixish: !!perl/hash:RE_ast
  dba: infix or meta-infix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_bracket
      re: &28 !!perl/hash:RE_any
        altname: infixish_0
        dba: infix or meta-infix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: infixish_0 0
          zyg:
          - !!perl/hash:RE_method
            name: colonpair
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: infixish_0 1
          zyg:
          - !!perl/hash:RE_bracket
            re: &29 !!perl/hash:RE_any
              altname: infixish_1
              dba: infixed function
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: infixish_1 0
                zyg:
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '['
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: infixish
                        rest: 1
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '!'
                        re: !!perl/hash:RE_method_re
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_string
                            i: 0
                            text: =
                      - !!perl/hash:RE_block {}
                  quant:
                  - '?'
              - !!perl/hash:RE_sequence
                alt: infixish_1 1
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '['
                      - !!perl/hash:RE_cclass
                        i: 0
                        text: '[&\$]'
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_method
                          name: twigil
                          rest: ''
                        quant:
                        - '?'
                      - !!perl/hash:RE_bracket
                        re: &30 !!perl/hash:RE_any
                          altname: infixish_2
                          dba: infixed function
                          dic: STD::P6
                          zyg:
                          - !!perl/hash:RE_method
                            alt: infixish_2 0
                            name: alpha
                            rest: ''
                          - !!perl/hash:RE_string
                            alt: infixish_2 1
                            i: 0
                            text: (
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '['
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        name: variable
                        rest: ''
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 2
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infix_circumfix_meta_operator
                    rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 3
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infix_prefix_meta_operator
                    rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 4
                zyg:
                - !!perl/hash:RE_method
                  name: infix
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: infixish_1 5
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_meta
                  text: '::'
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_noop
                    nobind: 1
              - !!perl/hash:RE_sequence
                alt: infixish_1 6
                zyg:
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: dotty
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_sequence
                alt: infixish_1 7
                zyg:
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: postfix
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: =
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: infix_postfix_meta_operator
                  rest: 1
                - !!perl/hash:RE_block {}
            quant:
            - '?'
infixish_0: *28
infixish_1: *29
infixish_2: *30
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &31 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            name: stopper
            rest: ''
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 1
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '!!'
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 2
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: &32 !!perl/hash:RE_any
              altname: infixstopper_1
              dba: infix stopper
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: infixstopper_1 0
                i: 0
                text: '{'
              - !!perl/hash:RE_method
                alt: infixstopper_1 1
                name: lambda
                rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 3
        assert: '?'
        re: !!perl/hash:RE_block
          nobind: 1
infixstopper_0: *31
infixstopper_1: *32
initializer__S_165Equal: !!perl/hash:RE_ast
  dba: initializer
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: ws
        i: 0
        name: sym
        rest: ''
        sym: =
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: EXPR
        rest: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
initializer__S_166ColonEqual: !!perl/hash:RE_ast
  dba: initializer
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: ws
        i: 0
        name: sym
        rest: ''
        sym: :=
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: EXPR
        rest: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
initializer__S_167ColonColonEqual: !!perl/hash:RE_ast
  dba: initializer
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: ws
        i: 0
        name: sym
        rest: ''
        sym: ::=
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: EXPR
        rest: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
initializer__S_168DotEqual: !!perl/hash:RE_ast
  dba: initializer
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: ws
        i: 0
        name: sym
        rest: ''
        sym: .=
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        name: dottyopish
        rest: ''
    - !!perl/hash:RE_method
      name: panic
      rest: 1
label: !!perl/hash:RE_ast
  dba: label
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: worry
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_block {}
lambda: !!perl/hash:RE_ast
  dba: lambda
  dic: STD::P6
  re: &33 !!perl/hash:RE_any
    altname: lambda_0
    dba: lambda
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_string
      alt: lambda_0 0
      i: 0
      text: ->
    - !!perl/hash:RE_string
      alt: lambda_0 1
      i: 0
      text: <->
lambda_0: *33
macro_def: !!perl/hash:RE_ast
  dba: macro_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &34 !!perl/hash:RE_any
                altname: macro_def_0
                dba: macro_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 0
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &35 !!perl/hash:RE_any
                altname: macro_def_1
                dba: macro_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '{'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
macro_def_0: *34
macro_def_1: *35
method_def: !!perl/hash:RE_ast
  dba: method_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: newlex
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bracket
            re: &36 !!perl/hash:RE_any
              altname: method_def_0
              dba: subscript signature
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: method_def_0 0
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_cclass
                        i: 0
                        text: '[ ! ^ ]'
                      quant:
                      - '?'
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: &37 !!perl/hash:RE_any
                      altname: method_def_1
                      dba: method_def
                      dic: STD::P6
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 0
                        zyg:
                        - !!perl/hash:RE_method
                          name: multisig
                          rest: ''
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 1
                        zyg:
                        - !!perl/hash:RE_method
                          name: trait
                          rest: ''
                        - !!perl/hash:RE_method
                          name: ws
                          rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 1
                zyg:
                - !!perl/hash:RE_method
                  name: multisig
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 2
                zyg:
                - !!perl/hash:RE_method
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: .
                - !!perl/hash:RE_bracket
                  re: &38 !!perl/hash:RE_any
                    altname: method_def_2
                    dba: subscript signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_bracket
                      alt: method_def_2 0
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: (
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: )
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_bracket
                      alt: method_def_2 1
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: '['
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: ']'
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_bracket
                      alt: method_def_2 2
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: '{'
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: '}'
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 3
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_method_re
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_string
                            i: 0
                            text: <
                      - !!perl/hash:RE_method
                        name: postcircumfix
                        rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  quant:
                  - '*'
              - !!perl/hash:RE_assertion
                alt: method_def_0 3
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
method_def_0: *36
method_def_1: *37
method_def_2: *38
methodop: !!perl/hash:RE_ast
  dba: method arguments
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &39 !!perl/hash:RE_any
        altname: methodop_0
        dba: methodop
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: methodop_0 0
          name: longname
          rest: ''
        - !!perl/hash:RE_sequence
          alt: methodop_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &40 !!perl/hash:RE_any
                altname: methodop_1
                dba: methodop
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: methodop_1 0
                  i: 0
                  text: $
                - !!perl/hash:RE_string
                  alt: methodop_1 1
                  i: 0
                  text: '@'
                - !!perl/hash:RE_string
                  alt: methodop_1 2
                  i: 0
                  text: '&'
          - !!perl/hash:RE_method
            name: variable
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: methodop_0 2
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_cclass
                i: 0
                text: '[ '' " ]'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '"'
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_cclass
                        i: 0
                        text: -["]
                      quant:
                      - '*'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \s
          - !!perl/hash:RE_method
            name: quote
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &41 !!perl/hash:RE_any
                    altname: methodop_2
                    dba: methodop
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: methodop_2 0
                      i: 0
                      text: (
                    - !!perl/hash:RE_string
                      alt: methodop_2 1
                      i: 0
                      text: .(
                    - !!perl/hash:RE_string
                      alt: methodop_2 2
                      i: 0
                      text: \
              - !!perl/hash:RE_method
                name: obs
                rest: 1
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &42 !!perl/hash:RE_any
          altname: methodop_3
          dba: method arguments
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_sequence
            alt: methodop_3 0
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ':'
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: &43 !!perl/hash:RE_any
                  altname: methodop_4
                  dba: method arguments
                  dic: STD::P6
                  zyg:
                  - !!perl/hash:RE_meta
                    alt: methodop_4 0
                    min: 1
                    text: \s
                  - !!perl/hash:RE_string
                    alt: methodop_4 1
                    i: 0
                    text: '{'
            - !!perl/hash:RE_assertion
              assert: '!'
              re: !!perl/hash:RE_block
                nobind: 1
            - !!perl/hash:RE_method
              name: arglist
              rest: ''
          - !!perl/hash:RE_sequence
            alt: methodop_3 1
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_cclass
                i: 0
                nobind: 1
                text: '[\\(]'
            - !!perl/hash:RE_method
              name: args
              rest: ''
          - !!perl/hash:RE_block
            alt: methodop_3 2
      quant:
      - '?'
methodop_0: *39
methodop_1: *40
methodop_2: *41
methodop_3: *42
methodop_4: *43
modifier_expr: !!perl/hash:RE_ast
  dba: modifier_expr
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
module_name__S_038normal: !!perl/hash:RE_ast
  dba: module_name
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: '['
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: arglist
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: ']'
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
      quant:
      - '?'
multi_declarator__S_057multi: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: multi
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: declarator
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: routine_def
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
multi_declarator__S_058proto: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: proto
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: declarator
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: routine_def
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
multi_declarator__S_059only: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: only
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: declarator
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: routine_def
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
multi_declarator__S_060null: !!perl/hash:RE_ast
  dba: multi_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: declarator
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
multisig: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_string
              i: 0
              text: ':'
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: signature
                rest: 1
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    quant:
    - +
named_param: !!perl/hash:RE_ast
  dba: named parameter
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bracket
      re: &44 !!perl/hash:RE_any
        altname: named_param_0
        dba: named parameter
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: named_param_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: identifier
              rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_block {}
              - !!perl/hash:RE_method
                name: named_param_term
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: )
                  - !!perl/hash:RE_method
                    name: FAILGOAL
                    rest: 1
        - !!perl/hash:RE_method
          alt: named_param_0 1
          name: param_var
          rest: 1
        - !!perl/hash:RE_sequence
          alt: named_param_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \
          - !!perl/hash:RE_method
            name: defterm
            rest: ''
named_param_0: *44
named_param_term: !!perl/hash:RE_ast
  dba: named_param_term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &45 !!perl/hash:RE_any
        altname: named_param_term_0
        dba: named_param_term
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: named_param_term_0 0
          name: named_param
          rest: ''
        - !!perl/hash:RE_method
          alt: named_param_term_0 1
          name: param_var
          rest: ''
        - !!perl/hash:RE_sequence
          alt: named_param_term_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \
          - !!perl/hash:RE_method
            name: defterm
            rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
named_param_term_0: *45
nullterm: !!perl/hash:RE_ast
  dba: nullterm
  dic: STD::P6
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_noop
      nobind: 1
nulltermish: !!perl/hash:RE_ast
  dba: null term
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &46 !!perl/hash:RE_any
      altname: nulltermish_0
      dba: null term
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 0
        assert: '?'
        re: !!perl/hash:RE_method
          name: stdstopper
          rest: ''
      - !!perl/hash:RE_sequence
        alt: nulltermish_0 1
        zyg:
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            name: termish
            rest: ''
        - !!perl/hash:RE_block {}
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 2
        assert: '?'
        re: !!perl/hash:RE_noop
          nobind: 1
nulltermish_0: *46
number: !!perl/hash:RE_ast
  dba: number
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &47 !!perl/hash:RE_any
      altname: number_0
      dba: number
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: number_0 0
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: 'NaN'
        - !!perl/hash:RE_meta
          text: »
      - !!perl/hash:RE_method
        alt: number_0 1
        name: integer
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 2
        name: dec_number
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 3
        name: rad_number
        rest: ''
      - !!perl/hash:RE_sequence
        alt: number_0 4
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: 'Inf'
        - !!perl/hash:RE_meta
          text: »
number_0: *47
numeric__S_136rational: !!perl/hash:RE_ast
  dba: numeric
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: integer
        rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: integer
        rest: ''
numeric__S_137complex: !!perl/hash:RE_ast
  dba: numeric
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[+\-]'
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: number
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_cclass
      i: 0
      text: '[+\-]'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: number
        rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: \
      quant:
      - '?'
    - !!perl/hash:RE_string
      i: 0
      text: i
numeric__S_138number: !!perl/hash:RE_ast
  dba: numeric
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[+\-]'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: number
      rest: ''
old_rx_mods: !!perl/hash:RE_ast
  dba: old_rx_mods
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: after
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \w
          quant:
          - +
    - !!perl/hash:RE_block {}
old_tr_mods: !!perl/hash:RE_ast
  dba: old_tr_mods
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            min: 1
            text: < c d s ] >
          quant:
          - +
    - !!perl/hash:RE_block {}
package_declarator__S_047class: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: class
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_048grammar: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: grammar
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_049module: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: module
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_050package: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: package
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_051role: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: role
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_052knowhow: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: knowhow
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_053slang: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: slang
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: package_def
      rest: ''
package_declarator__S_054require: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: require
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: module_name
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: EXPR
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: EXPR
          rest: ''
package_declarator__S_055trusts: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: trusts
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
package_declarator__S_056also: !!perl/hash:RE_ast
  dba: package_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: also
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: trait
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
package_def: !!perl/hash:RE_ast
  dba: package_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_string
        i: 0
        text: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      text: '['
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: signature
                      rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_first
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: ']'
                        - !!perl/hash:RE_method
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: trait
              rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '{'
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_method
                      name: blockoid
                      rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_method
                      name: checkyada
                      rest: ''
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ;
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_block
                          nobind: 1
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_method
                        name: statementlist
                        rest: ''
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_method
                        name: panic
                        rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
param_sep: !!perl/hash:RE_ast
  dba: param_sep
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &48 !!perl/hash:RE_any
        altname: param_sep_0
        dba: param_sep
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: param_sep_0 0
          i: 0
          text: ','
        - !!perl/hash:RE_string
          alt: param_sep_0 1
          i: 0
          text: ':'
        - !!perl/hash:RE_string
          alt: param_sep_0 2
          i: 0
          text: ;
        - !!perl/hash:RE_string
          alt: param_sep_0 3
          i: 0
          text: ;;
    - !!perl/hash:RE_method
      name: ws
      rest: ''
param_sep_0: *48
param_var: !!perl/hash:RE_ast
  dba: formal parameter
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &49 !!perl/hash:RE_any
      altname: param_var_0
      dba: formal parameter
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_bracket
        alt: param_var_0 0
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: ']'
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_bracket
        alt: param_var_0 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: )
              - !!perl/hash:RE_method
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_sequence
        alt: param_var_0 2
        zyg:
        - !!perl/hash:RE_method
          name: sigil
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: twigil
            rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method
                    name: ident
                    rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: sublongname
                    rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_method
                      name: identifier
                      rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \< \( \[ \{ ]'
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: identifier
                  rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: decint
                    rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_cclass
                    i: 0
                    text: '[/!]'
          quant:
          - '?'
        - !!perl/hash:RE_block {}
param_var_0: *49
parameter: !!perl/hash:RE_ast
  dba: parameter
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &50 !!perl/hash:RE_any
        altname: parameter_0
        dba: parameter
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: parameter_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: type_constraint
              rest: ''
            quant:
            - +
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: &51 !!perl/hash:RE_any
              altname: parameter_1
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_1 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '**'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '*'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '|'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: defterm
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: \
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: defterm
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_1 4
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '|'
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_method
                  name: worryobs
                  rest: 1
              - !!perl/hash:RE_sequence
                alt: parameter_1 5
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: \
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
                - !!perl/hash:RE_method
                  name: worryobs
                  rest: 1
              - !!perl/hash:RE_sequence
                alt: parameter_1 6
                zyg:
                - !!perl/hash:RE_bracket
                  re: &52 !!perl/hash:RE_any
                    altname: parameter_2
                    dba: parameter
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 0
                      zyg:
                      - !!perl/hash:RE_method
                        name: param_var
                        rest: ''
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 1
                      zyg:
                      - !!perl/hash:RE_method
                        name: named_param
                        rest: ''
                      - !!perl/hash:RE_block {}
                - !!perl/hash:RE_bracket
                  re: &53 !!perl/hash:RE_any
                    altname: parameter_3
                    dba: parameter
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 0
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '?'
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '!'
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_assertion
                      alt: parameter_3 2
                      assert: '?'
                      re: !!perl/hash:RE_noop
                        nobind: 1
              - !!perl/hash:RE_sequence
                alt: parameter_1 7
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_noop
                    nobind: 1
                - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '**'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '*'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 3
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '|'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: defterm
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 4
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: defterm
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: parameter_0 5
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '|'
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: worryobs
            rest: 1
        - !!perl/hash:RE_sequence
          alt: parameter_0 6
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \
          - !!perl/hash:RE_method
            name: param_var
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: worryobs
            rest: 1
        - !!perl/hash:RE_sequence
          alt: parameter_0 7
          zyg:
          - !!perl/hash:RE_bracket
            re: &54 !!perl/hash:RE_any
              altname: parameter_4
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_4 0
                zyg:
                - !!perl/hash:RE_method
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_4 1
                zyg:
                - !!perl/hash:RE_method
                  name: named_param
                  rest: ''
                - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: &55 !!perl/hash:RE_any
              altname: parameter_5
              dba: parameter
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_5 0
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '?'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                alt: parameter_5 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '!'
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_assertion
                alt: parameter_5 2
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
        - !!perl/hash:RE_sequence
          alt: parameter_0 8
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: longname
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: post_constraint
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: default_value
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ':'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[,;)\]\{\}\-]'
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
parameter_0: *50
parameter_1: *51
parameter_2: *52
parameter_3: *53
parameter_4: *54
parameter_5: *55
pblock: !!perl/hash:RE_ast
  dba: parameterized block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: &56 !!perl/hash:RE_any
              altname: pblock_0
              dba: parameterized block
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: pblock_0 0
                name: lambda
                rest: ''
              - !!perl/hash:RE_string
                alt: pblock_0 1
                i: 0
                text: '{'
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &57 !!perl/hash:RE_any
        altname: pblock_1
        dba: parameterized block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: pblock_1 0
          zyg:
          - !!perl/hash:RE_method
            name: lambda
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: signature
            rest: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
        - !!perl/hash:RE_sequence
          alt: pblock_1 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '{'
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
pblock_0: *56
pblock_1: *57
post_constraint: !!perl/hash:RE_ast
  dba: constraint
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &58 !!perl/hash:RE_any
        altname: post_constraint_0
        dba: constraint
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_bracket
          alt: post_constraint_0 0
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: signature
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_bracket
          alt: post_constraint_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: signature
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: w
          - !!perl/hash:RE_string
            i: 0
            text: h
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_string
            i: 0
            text: r
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
post_constraint_0: *58
postcircumfix__S_207Paren_Thesis: !!perl/hash:RE_ast
  dba: argument list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semiarglist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_208Bra_Ket: !!perl/hash:RE_ast
  dba: subscript
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
postcircumfix__S_209Cur_Ly: !!perl/hash:RE_ast
  dba: subscript
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: newlex
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '{'
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '}'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_method
      name: checkyada
      rest: ''
    - !!perl/hash:RE_method
      name: curlycheck
      rest: 1
postcircumfix__S_210Lt_Gt: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: nibble
            rest: 1
          - !!perl/hash:RE_string
            i: 0
            text: '>'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &59 !!perl/hash:RE_any
                    altname: postcircumfix__S_210Lt_Gt_0
                    dba: postcircumfix
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: postcircumfix__S_210Lt_Gt_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_method
                      alt: postcircumfix__S_210Lt_Gt_0 1
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_string
                      alt: postcircumfix__S_210Lt_Gt_0 2
                      i: 0
                      text: ':'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_210Lt_Gt_0: *59
postcircumfix__S_211LtLt_GtGt: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <<
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '>>'
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postcircumfix__S_212Fre_Nch: !!perl/hash:RE_ast
  dba: postcircumfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: «
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: »
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_215i: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: i
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_217MinusGt: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ->
    - !!perl/hash:RE_bracket
      re: &60 !!perl/hash:RE_any
        altname: postfix__S_217MinusGt_0
        dba: postfix
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: postfix__S_217MinusGt_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_cclass
              i: 0
              text: '[ \[ \{ \( ]'
          - !!perl/hash:RE_method
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          alt: postfix__S_217MinusGt_0 1
          name: obs
          rest: 1
postfix__S_217MinusGt_0: *60
postfix__S_218PlusPlus: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix__S_219MinusMinus: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      name: O
      rest: 1
postfix_prefix_meta_operator__S_198Nch: !!perl/hash:RE_ast
  dba: postfix_prefix_meta_operator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &61 !!perl/hash:RE_any
        altname: postfix_prefix_meta_operator__S_198Nch_0
        dba: postfix_prefix_meta_operator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: postfix_prefix_meta_operator__S_198Nch_0 0
          i: 0
          name: sym
          rest: ''
          sym: »
        - !!perl/hash:RE_string
          alt: postfix_prefix_meta_operator__S_198Nch_0 1
          i: 0
          text: '>>'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: (
postfix_prefix_meta_operator__S_198Nch_0: *61
postop: !!perl/hash:RE_ast
  dba: postop
  dic: STD::P6
  re: &62 !!perl/hash:RE_any
    altname: postop_0
    dba: postop
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_sequence
      alt: postop_0 0
      zyg:
      - !!perl/hash:RE_method
        name: postfix
        rest: ''
      - !!perl/hash:RE_bindnamed
        atom: !!perl/hash:RE_block {}
      - !!perl/hash:RE_bindnamed
        atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_sequence
      alt: postop_0 1
      zyg:
      - !!perl/hash:RE_method
        name: postcircumfix
        rest: ''
      - !!perl/hash:RE_bindnamed
        atom: !!perl/hash:RE_block {}
      - !!perl/hash:RE_bindnamed
        atom: !!perl/hash:RE_block {}
postop_0: *62
prefix__S_220PlusPlus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_221MinusMinus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_223Bang: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_224Plus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_225Minus: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_226TildeTilde: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_227Tilde: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_228QuestionQuestion: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ??
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_229Question: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_230TildeCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_231PlusCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_232QuestionCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_233CaretCaret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      name: dupprefix
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_234Caret: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_235VertVert: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_236Vert: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_268sleep: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: sleep
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_269abs: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: abs
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_270let: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: let
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_271temp: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: temp
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          quant:
          - '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_323so: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: so
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix__S_324not: !!perl/hash:RE_ast
  dba: prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: not
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
prefix_postfix_meta_operator__S_197Fre: !!perl/hash:RE_ast
  dba: prefix_postfix_meta_operator
  dic: STD::P6
  re: &63 !!perl/hash:RE_any
    altname: prefix_postfix_meta_operator__S_197Fre_0
    dba: prefix_postfix_meta_operator
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_method
      alt: prefix_postfix_meta_operator__S_197Fre_0 0
      i: 0
      name: sym
      rest: ''
      sym: «
    - !!perl/hash:RE_string
      alt: prefix_postfix_meta_operator__S_197Fre_0 1
      i: 0
      text: <<
prefix_postfix_meta_operator__S_197Fre_0: *63
privop: !!perl/hash:RE_ast
  dba: privop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '!'
    - !!perl/hash:RE_method
      name: methodop
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
quasiquibble: !!perl/hash:RE_ast
  dba: quasiquibble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_decl {}
              - !!perl/hash:RE_method
                name: block
                rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_decl {}
            - !!perl/hash:RE_method
              name: starter
              rest: ''
            - !!perl/hash:RE_method
              name: statementlist
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
quote__S_139SlashSlash: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
quote__S_140Slash_Slash: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: /
    - !!perl/hash:RE_method
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: /
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
      quant:
      - '?'
quote__S_141qq: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: qq
    - !!perl/hash:RE_bracket
      re: &64 !!perl/hash:RE_any
        altname: quote__S_141qq_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_141qq_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_141qq_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_141qq_0: *64
quote__S_142q: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: q
    - !!perl/hash:RE_bracket
      re: &65 !!perl/hash:RE_any
        altname: quote__S_142q_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_142q_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_142q_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_142q_0: *65
quote__S_143Q: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: Q
    - !!perl/hash:RE_bracket
      re: &66 !!perl/hash:RE_any
        altname: quote__S_143Q_0
        dba: quote
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_143Q_0 0
          zyg:
          - !!perl/hash:RE_method
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_143Q_0 1
          zyg:
          - !!perl/hash:RE_meta
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
quote__S_143Q_0: *66
quote__S_155rx: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: rx
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_156m: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: m
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_157ms: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ms
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_158s: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: sibble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_159ss: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ss
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: sibble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_rx_mods
        rest: ''
quote__S_160tr: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: tr
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: tribble
        rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: old_tr_mods
        rest: ''
quote__S_161quasi: !!perl/hash:RE_ast
  dba: quote
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: quasi
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: (
    - !!perl/hash:RE_method
      name: quasiquibble
      rest: 1
quote_mod__S_144w: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: w
quote_mod__S_145ww: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ww
quote_mod__S_146p: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: p
quote_mod__S_147x: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: x
quote_mod__S_148to: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: to
quote_mod__S_149s: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: s
quote_mod__S_150a: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: a
quote_mod__S_151h: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: h
quote_mod__S_152f: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: f
quote_mod__S_153c: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: c
quote_mod__S_154b: !!perl/hash:RE_ast
  dba: quote_mod
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: b
regex_block: !!perl/hash:RE_ast
  dba: regex_block
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: &67 !!perl/hash:RE_any
        altname: regex_block_0
        dba: regex_block
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: regex_block_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{*}'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          alt: regex_block_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '{'
            - !!perl/hash:RE_method
              name: nibble
              rest: 1
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '}'
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
    - !!perl/hash:RE_method
      name: curlycheck
      rest: 1
regex_block_0: *67
regex_declarator__S_065regex: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: regex
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
regex_declarator__S_066token: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: token
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
regex_declarator__S_067rule: !!perl/hash:RE_ast
  dba: regex_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: rule
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: regex_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
regex_def: !!perl/hash:RE_ast
  dba: regex_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &68 !!perl/hash:RE_any
                altname: regex_def_0
                dba: regex_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 0
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &69 !!perl/hash:RE_any
                altname: regex_def_1
                dba: regex_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 0
                  zyg:
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: ':'
                        quant:
                        - '?'
                      - !!perl/hash:RE_string
                        i: 0
                        text: (
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_method
                        name: signature
                        rest: 1
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: )
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '{'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: finishlex
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: regex_block
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
regex_def_0: *68
regex_def_1: *69
routine_declarator__S_061sub: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: sub
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: routine_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
routine_declarator__S_062method: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: method
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: method_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
routine_declarator__S_063submethod: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: submethod
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: method_def
      rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
routine_declarator__S_064macro: !!perl/hash:RE_ast
  dba: routine_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: macro
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: macro_def
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
routine_def: !!perl/hash:RE_ast
  dba: routine_def
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &70 !!perl/hash:RE_any
                altname: routine_def_0
                dba: routine_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 0
                  zyg:
                  - !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_sequence
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: '&'
                          - !!perl/hash:RE_quantified_atom
                            atom: !!perl/hash:RE_string
                              i: 0
                              text: '*'
                            quant:
                            - '?'
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      name: deflongname
                      rest: ''
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: newlex
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: &71 !!perl/hash:RE_any
                altname: routine_def_1
                dba: routine_def
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 0
                  zyg:
                  - !!perl/hash:RE_method
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 1
                  zyg:
                  - !!perl/hash:RE_method
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '{'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
routine_def_0: *70
routine_def_1: *71
scope_declarator__S_040my: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: my
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_041our: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: our
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_042anon: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: anon
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_043state: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: state
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_044augment: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: augment
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_045supersede: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: supersede
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scope_declarator__S_046has: !!perl/hash:RE_ast
  dba: scope_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: has
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: scoped
      rest: 1
scoped: !!perl/hash:RE_ast
  dba: scoped declarator
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: &72 !!perl/hash:RE_any
          altname: scoped_0
          dba: scoped declarator
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_method
            alt: scoped_0 0
            name: declarator
            rest: ''
          - !!perl/hash:RE_method
            alt: scoped_0 1
            name: regex_declarator
            rest: ''
          - !!perl/hash:RE_method
            alt: scoped_0 2
            name: package_declarator
            rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 3
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_method
                    name: typename
                    rest: ''
                  - !!perl/hash:RE_method
                    name: ws
                    rest: ''
              quant:
              - +
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: multi_declarator
              rest: ''
          - !!perl/hash:RE_method
            alt: scoped_0 4
            name: multi_declarator
            rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_cclass
            i: 0
            text: '[A..Z]'
      - !!perl/hash:RE_method
        name: longname
        rest: ''
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_assertion
        assert: '!'
        re: !!perl/hash:RE_noop
          nobind: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
scoped_0: *72
semiarglist: !!perl/hash:RE_ast
  dba: semiarglist
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: arglist
        rest: ''
      quant:
      - +
    - !!perl/hash:RE_method
      name: ws
      rest: ''
semilist: !!perl/hash:RE_ast
  dba: semicolon list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &73 !!perl/hash:RE_any
        altname: semilist_0
        dba: semicolon list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_assertion
          alt: semilist_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_cclass
              i: 0
              text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: semilist_0 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
semilist_0: *73
sibble: !!perl/hash:RE_ast
  dba: sibble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: nibble
        rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_cclass
                    i: 0
                    nobind: 1
                    text: '[ \[ \{ \( \< ]'
                - !!perl/hash:RE_method
                  name: obs
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: infixish
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: EXPR
              rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: nibble
              rest: 1
          - !!perl/hash:RE_var
            var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
signature: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &74 !!perl/hash:RE_any
        altname: signature_0
        dba: signature
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: signature_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: \|
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: defterm
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &75 !!perl/hash:RE_any
                    altname: signature_1
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: signature_1 0
                      i: 0
                      text: -->
                    - !!perl/hash:RE_string
                      alt: signature_1 1
                      i: 0
                      text: )
                    - !!perl/hash:RE_string
                      alt: signature_1 2
                      i: 0
                      text: ']'
              - !!perl/hash:RE_method
                name: panic
                rest: 1
        - !!perl/hash:RE_quantified_atom
          alt: signature_0 1
          atom: !!perl/hash:RE_bracket
            re: &76 !!perl/hash:RE_any
              altname: signature_2
              dba: signature
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_assertion
                alt: signature_2 0
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &77 !!perl/hash:RE_any
                    altname: signature_3
                    dba: signature
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: signature_3 0
                      i: 0
                      text: -->
                    - !!perl/hash:RE_string
                      alt: signature_3 1
                      i: 0
                      text: )
                    - !!perl/hash:RE_string
                      alt: signature_3 2
                      i: 0
                      text: ']'
                    - !!perl/hash:RE_string
                      alt: signature_3 3
                      i: 0
                      text: '{'
                    - !!perl/hash:RE_sequence
                      alt: signature_3 4
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: ':'
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \s
                    - !!perl/hash:RE_string
                      alt: signature_3 5
                      i: 0
                      text: ;;
              - !!perl/hash:RE_bracket
                alt: signature_2 1
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_method
                    name: parameter
                    rest: ''
                  - !!perl/hash:RE_method
                    name: panic
                    rest: 1
          quant:
          - +
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: -->
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_method
                name: type_constraint
                rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
              - !!perl/hash:RE_method
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_block {}
signature_0: *74
signature_1: *75
signature_2: *76
signature_3: *77
sigterm: !!perl/hash:RE_ast
  dba: signature
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: :(
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_method
        name: fakesignature
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: )
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
special_variable__S_089Dollar_a2_: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: $¢
special_variable__S_090DollarBang: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $!
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
special_variable__S_091DollarBangCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $!
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '{'
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_bracket
          re: &78 !!perl/hash:RE_any
            altname: special_variable__S_091DollarBangCur_Ly_0
            dba: special_variable
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_method
              alt: special_variable__S_091DollarBangCur_Ly_0 0
              name: identifier
              rest: ''
            - !!perl/hash:RE_method
              alt: special_variable__S_091DollarBangCur_Ly_0 1
              name: statementlist
              rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '}'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block {}
special_variable__S_091DollarBangCur_Ly_0: *78
special_variable__S_092DollarSlash: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $/
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_cclass
                    i: 0
                    nobind: 1
                    text: '[=]'
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
special_variable__S_093DollarTilde: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $~
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &79 !!perl/hash:RE_any
          altname: special_variable__S_093DollarTilde_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_093DollarTilde_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_093DollarTilde_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_093DollarTilde_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_093DollarTilde_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_093DollarTilde_0: *79
special_variable__S_094DollarGrave: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $`
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &80 !!perl/hash:RE_any
          altname: special_variable__S_094DollarGrave_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_094DollarGrave_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_094DollarGrave_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_094DollarGrave_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_094DollarGrave_0: *80
special_variable__S_095DollarAt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $@
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \W
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_096DollarSharp: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $#
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_method
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          name: obs
          rest: 1
special_variable__S_097DollarDollar: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: alpha
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &81 !!perl/hash:RE_any
          altname: special_variable__S_097DollarDollar_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_097DollarDollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_097DollarDollar_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_097DollarDollar_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_097DollarDollar_0: *81
special_variable__S_098DollarPercent: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $%
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: sigil
        rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_099DollarCaretX: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: ^
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[A..Z]'
    - !!perl/hash:RE_meta
      min: 1
      text: \W
    - !!perl/hash:RE_method
      name: obscaret
      rest: 1
special_variable__S_100DollarCaret: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $^
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &82 !!perl/hash:RE_any
          altname: special_variable__S_100DollarCaret_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_100DollarCaret_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_100DollarCaret_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_100DollarCaret_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_100DollarCaret_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_100DollarCaret_0: *82
special_variable__S_101DollarAmp: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $&
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &83 !!perl/hash:RE_any
          altname: special_variable__S_101DollarAmp_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_101DollarAmp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_101DollarAmp_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_101DollarAmp_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_101DollarAmp_0: *83
special_variable__S_102DollarStar: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $*
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &84 !!perl/hash:RE_any
          altname: special_variable__S_102DollarStar_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_102DollarStar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarStar_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarStar_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_102DollarStar_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_102DollarStar_0: *84
special_variable__S_103DollarThesis: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $)
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &85 !!perl/hash:RE_any
          altname: special_variable__S_103DollarThesis_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_103DollarThesis_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_103DollarThesis_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_103DollarThesis_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_103DollarThesis_0: *85
special_variable__S_104DollarMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $-
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &86 !!perl/hash:RE_any
          altname: special_variable__S_104DollarMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_104DollarMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarMinus_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_104DollarMinus_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_104DollarMinus_0: *86
special_variable__S_105DollarEqual: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $=
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &87 !!perl/hash:RE_any
          altname: special_variable__S_105DollarEqual_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_105DollarEqual_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_105DollarEqual_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_105DollarEqual_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_105DollarEqual_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_105DollarEqual_0: *87
special_variable__S_106AtPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '@+'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &88 !!perl/hash:RE_any
          altname: special_variable__S_106AtPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_106AtPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_106AtPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_106AtPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_106AtPlus_0: *88
special_variable__S_107PercentPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%+'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &89 !!perl/hash:RE_any
          altname: special_variable__S_107PercentPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_107PercentPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_107PercentPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_107PercentPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_107PercentPlus_0: *89
special_variable__S_108DollarPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $+[
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_109AtPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@+['
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_110AtPlusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@+{'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_111AtMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '@-'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &90 !!perl/hash:RE_any
          altname: special_variable__S_111AtMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_111AtMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_111AtMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_111AtMinus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_111AtMinus_0: *90
special_variable__S_112PercentMinus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '%-'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &91 !!perl/hash:RE_any
          altname: special_variable__S_112PercentMinus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_112PercentMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_112PercentMinus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_112PercentMinus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_112PercentMinus_0: *91
special_variable__S_113DollarMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $-[
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_114AtMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@-['
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_115PercentMinusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '@-{'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_116DollarPlus: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $+
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &92 !!perl/hash:RE_any
          altname: special_variable__S_116DollarPlus_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_116DollarPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_116DollarPlus_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_116DollarPlus_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_116DollarPlus_0: *92
special_variable__S_117DollarCurCaret_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{^'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          text: .*?
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_method
      name: obscaret
      rest: 1
special_variable__S_118ColonColonCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
special_variable__S_119DollarCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          text: .*?
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_block {}
special_variable__S_120DollarBra: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $[
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &93 !!perl/hash:RE_any
          altname: special_variable__S_120DollarBra_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_120DollarBra_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_120DollarBra_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_120DollarBra_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_120DollarBra_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_120DollarBra_0: *93
special_variable__S_121DollarKet: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $]
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &94 !!perl/hash:RE_any
          altname: special_variable__S_121DollarKet_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_121DollarKet_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_121DollarKet_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_121DollarKet_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_121DollarKet_0: *94
special_variable__S_122DollarBack: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $\
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &95 !!perl/hash:RE_any
          altname: special_variable__S_122DollarBack_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_122DollarBack_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBack_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBack_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_122DollarBack_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_122DollarBack_0: *95
special_variable__S_123DollarVert: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $|
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &96 !!perl/hash:RE_any
          altname: special_variable__S_123DollarVert_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_123DollarVert_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_123DollarVert_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_123DollarVert_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_123DollarVert_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_123DollarVert_0: *96
special_variable__S_124DollarColon: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '$:'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[\x20\t\n\],=)}]'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_125DollarSemi: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $;
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &97 !!perl/hash:RE_any
          altname: special_variable__S_125DollarSemi_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_125DollarSemi_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarSemi_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarSemi_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_125DollarSemi_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_125DollarSemi_0: *97
special_variable__S_126DollarSingle: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &98 !!perl/hash:RE_any
          altname: special_variable__S_126DollarSingle_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_126DollarSingle_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_126DollarSingle_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_126DollarSingle_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_126DollarSingle_0: *98
special_variable__S_127DollarDouble: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $"
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &99 !!perl/hash:RE_any
          altname: special_variable__S_127DollarDouble_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_127DollarDouble_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarDouble_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarDouble_0 2
            i: 0
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_127DollarDouble_0 3
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_127DollarDouble_0: *99
special_variable__S_128DollarComma: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $,
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &100 !!perl/hash:RE_any
          altname: special_variable__S_128DollarComma_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_128DollarComma_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_128DollarComma_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_128DollarComma_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_128DollarComma_0: *100
special_variable__S_129DollarLt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $<
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_cclass
            i: 0
            text: '[ = , ; ? : ! ) \] } ]'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \S
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: '>'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_130DollarGt: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $>
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &101 !!perl/hash:RE_any
          altname: special_variable__S_130DollarGt_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_130DollarGt_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_130DollarGt_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_130DollarGt_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_130DollarGt_0: *101
special_variable__S_131DollarDot: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $.
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &102 !!perl/hash:RE_any
          altname: special_variable__S_131DollarDot_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_131DollarDot_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_131DollarDot_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_131DollarDot_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_131DollarDot_0: *102
special_variable__S_132DollarQuestion: !!perl/hash:RE_ast
  dba: special_variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $?
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &103 !!perl/hash:RE_any
          altname: special_variable__S_132DollarQuestion_0
          dba: special_variable
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_132DollarQuestion_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_132DollarQuestion_0 1
            i: 0
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_132DollarQuestion_0 2
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      name: obs
      rest: 1
special_variable__S_132DollarQuestion_0: *103
statement: !!perl/hash:RE_ast
  dba: statement
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[\)\]\}]'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_assertion
        assert: '!'
        nobind: 1
        re: !!perl/hash:RE_block
          nobind: 1
    - !!perl/hash:RE_bracket
      re: &104 !!perl/hash:RE_any
        altname: statement_0
        dba: statement end
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_0 0
          zyg:
          - !!perl/hash:RE_method
            name: label
            rest: ''
          - !!perl/hash:RE_method
            name: statement
            rest: ''
        - !!perl/hash:RE_method
          alt: statement_0 1
          name: statement_control
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 2
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: &105 !!perl/hash:RE_any
                      altname: statement_1
                      dba: statement modifier loop
                      dic: STD::P6
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: statement_1 0
                        zyg:
                        - !!perl/hash:RE_method
                          name: statement_mod_loop
                          rest: ''
                        - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_sequence
                        alt: statement_1 1
                        zyg:
                        - !!perl/hash:RE_method
                          name: statement_mod_cond
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '?'
                              re: !!perl/hash:RE_block
                                nobind: 1
                            - !!perl/hash:RE_sequence
                              zyg:
                              - !!perl/hash:RE_method
                                name: ws
                                rest: ''
                              - !!perl/hash:RE_quantified_atom
                                atom: !!perl/hash:RE_method
                                  name: statement_mod_loop
                                  rest: ''
                                quant:
                                - '?'
                  quant:
                  - '?'
        - !!perl/hash:RE_assertion
          alt: statement_0 3
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: ;
        - !!perl/hash:RE_assertion
          alt: statement_0 4
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              name: stopper
              rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 5
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            quant:
            - '*'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &106 !!perl/hash:RE_any
                altname: statement_2
                dba: statement
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_2 0
                  i: 0
                  text: ;
                - !!perl/hash:RE_string
                  alt: statement_2 1
                  i: 0
                  text: )
                - !!perl/hash:RE_string
                  alt: statement_2 2
                  i: 0
                  text: ']'
                - !!perl/hash:RE_string
                  alt: statement_2 3
                  i: 0
                  text: '}'
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_method
              name: infixstopper
              rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: panic
            rest: 1
      quant:
      - '?'
statement_0: *104
statement_1: *105
statement_2: *106
statement_control__S_000need: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: need
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &107 !!perl/hash:RE_any
          altname: statement_control__S_000need_0
          dba: statement_control
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 0
            zyg:
            - !!perl/hash:RE_method
              name: version
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 1
            zyg:
            - !!perl/hash:RE_method
              name: module_name
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
            - !!perl/hash:RE_block {}
      quant:
      - +
statement_control__S_000need_0: *107
statement_control__S_001import: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: import
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            name: arglist
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_002use: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: use
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &108 !!perl/hash:RE_any
        altname: statement_control__S_002use_0
        dba: statement_control
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: statement_control__S_002use_0 0
          name: version
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_002use_0 1
          zyg:
          - !!perl/hash:RE_method
            name: module_name
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: spacey
                  rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
statement_control__S_002use_0: *108
statement_control__S_003no: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: no
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: module_name
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            name: arglist
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_004if: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_bracket
          re: &109 !!perl/hash:RE_any
            altname: statement_control__S_004if_0
            dba: statement_control
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_sequence
              alt: statement_control__S_004if_0 0
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: else
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                quant:
                - '*'
              - !!perl/hash:RE_string
                i: 0
                text: if
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_method
                name: sorry
                rest: 1
              - !!perl/hash:RE_method
                name: ws
                rest: ''
            - !!perl/hash:RE_sequence
              alt: statement_control__S_004if_0 1
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: elsif
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method
                  name: keyspace
                  rest: ''
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: xblock
                  rest: ''
              - !!perl/hash:RE_method
                name: ws
                rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: else
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method
              name: keyspace
              rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: pblock
              rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_004if_0: *109
statement_control__S_005unless: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: else
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
statement_control__S_006while: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: my
                        quant:
                        - '?'
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: $
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \w
                        quant:
                        - +
                      - !!perl/hash:RE_method
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        text: =
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: <
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: $
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  quant:
                  - +
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: '>'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: )
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_007until: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_008repeat: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: repeat
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &110 !!perl/hash:RE_any
        altname: statement_control__S_008repeat_0
        dba: statement_control
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: &111 !!perl/hash:RE_any
                altname: statement_control__S_008repeat_1
                dba: statement_control
                dic: STD::P6
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 0
                  i: 0
                  text: while
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 1
                  i: 0
                  text: until
          - !!perl/hash:RE_method
            name: keyspace
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: xblock
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 1
          zyg:
          - !!perl/hash:RE_method
            name: pblock
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_bracket
                    re: &112 !!perl/hash:RE_any
                      altname: statement_control__S_008repeat_2
                      dba: statement_control
                      dic: STD::P6
                      zyg:
                      - !!perl/hash:RE_string
                        alt: statement_control__S_008repeat_2 0
                        i: 0
                        text: while
                      - !!perl/hash:RE_string
                        alt: statement_control__S_008repeat_2 1
                        i: 0
                        text: until
                - !!perl/hash:RE_method
                  name: keyspace
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
statement_control__S_008repeat_0: *110
statement_control__S_008repeat_1: *111
statement_control__S_008repeat_2: *112
statement_control__S_009loop: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: loop
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_paren
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_string
                i: 0
                text: (
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          name: EXPR
                          rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_string
                      i: 0
                      text: ;
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          name: EXPR
                          rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_string
                      i: 0
                      text: ;
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          name: EXPR
                          rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_string
                      i: 0
                      text: )
                  - !!perl/hash:RE_method
                    name: panic
                    rest: 1
              - !!perl/hash:RE_method
                name: ws
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '!'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_method
                      name: sorry
                      rest: 1
                    - !!perl/hash:RE_method
                      name: ws
                      rest: ''
                quant:
                - '?'
              - !!perl/hash:RE_method
                name: ws
                rest: ''
          quant:
          - '?'
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_010for: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: my
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: $
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  quant:
                  - +
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: (
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: ;
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: ;
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: EXPR
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: obs
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_011given: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_012when: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
    - !!perl/hash:RE_method
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_013default: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: default
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_028CATCH: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: CATCH
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_029CONTROL: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: CONTROL
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_control__S_030TEMP: !!perl/hash:RE_ast
  dba: statement_control
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: TEMP
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: block
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_031if: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_032unless: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_cond__S_033when: !!perl/hash:RE_ast
  dba: statement_mod_cond
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method
        name: dumbsmart
        rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_034while: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_035until: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_036for: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_mod_loop__S_037given: !!perl/hash:RE_ast
  dba: statement_mod_loop
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
statement_prefix__S_014BEGIN: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: BEGIN
    - !!perl/hash:RE_method
      name: blast
      rest: ''
    - !!perl/hash:RE_method
      name: explain_mystery
      rest: ''
statement_prefix__S_015CHECK: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: CHECK
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_016INIT: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: INIT
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_017START: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: START
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_018ENTER: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ENTER
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_019FIRST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: FIRST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_020END: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: END
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_021LEAVE: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: LEAVE
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_022KEEP: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: KEEP
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_023UNDO: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: UNDO
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_024NEXT: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: NEXT
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_025LAST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: LAST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_026PRE: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: PRE
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_027POST: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: POST
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_169sink: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: sink
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_170try: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: try
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_171quietly: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: quietly
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_172gather: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: gather
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_173contend: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: contend
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_174async: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: async
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_175maybe: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: maybe
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_176lazy: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lazy
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_177do: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: do
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statement_prefix__S_178lift: !!perl/hash:RE_ast
  dba: statement_prefix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: lift
    - !!perl/hash:RE_method
      name: blast
      rest: ''
statementlist: !!perl/hash:RE_ast
  dba: statement list
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &113 !!perl/hash:RE_any
        altname: statementlist_0
        dba: statement list
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: statementlist_0 0
          zyg:
          - !!perl/hash:RE_meta
            text: $
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_assertion
          alt: statementlist_0 1
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_cclass
              i: 0
              text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: statementlist_0 2
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
statementlist_0: *113
sublongname: !!perl/hash:RE_ast
  dba: sublongname
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: subshortname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: sigterm
        rest: ''
      quant:
      - '?'
subshortname: !!perl/hash:RE_ast
  dba: subshortname
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &114 !!perl/hash:RE_any
      altname: subshortname_0
      dba: subshortname
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: subshortname_0 0
        zyg:
        - !!perl/hash:RE_method
          name: category
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            name: colonpair
            rest: ''
          quant:
          - +
      - !!perl/hash:RE_method
        alt: subshortname_0 1
        name: desigilname
        rest: ''
subshortname_0: *114
term__S_074fatarrow: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: fatarrow
    rest: ''
term__S_075variable: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: variable
      rest: ''
    - !!perl/hash:RE_block {}
term__S_076package_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: package_declarator
    rest: ''
term__S_077scope_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: scope_declarator
    rest: ''
term__S_078multi_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &115 !!perl/hash:RE_any
          altname: term__S_078multi_declarator_0
          dba: term
          dic: STD::P6
          zyg:
          - !!perl/hash:RE_string
            alt: term__S_078multi_declarator_0 0
            i: 0
            text: multi
          - !!perl/hash:RE_string
            alt: term__S_078multi_declarator_0 1
            i: 0
            text: proto
          - !!perl/hash:RE_string
            alt: term__S_078multi_declarator_0 2
            i: 0
            text: only
    - !!perl/hash:RE_method
      name: multi_declarator
      rest: ''
term__S_078multi_declarator_0: *115
term__S_079routine_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: routine_declarator
    rest: ''
term__S_080regex_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: regex_declarator
    rest: ''
term__S_081type_declarator: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: type_declarator
    rest: ''
term__S_082circumfix: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: circumfix
    rest: ''
term__S_083dotty: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: dotty
    rest: ''
term__S_084value: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: value
    rest: ''
term__S_085capterm: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: capterm
    rest: ''
term__S_086sigterm: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: sigterm
    rest: ''
term__S_087statement_prefix: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: statement_prefix
    rest: ''
term__S_088colonpair: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_method
          name: colonpair
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
    quant:
    - +
term__S_179new: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: new
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - +
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: ':'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
term__S_180ColonColonQuestionIDENT: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ::?
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_181undef: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: undef
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: $/
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_bracket
                re: !!perl/hash:RE_first
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: (
                  - !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      quant:
                      - '*'
                    - !!perl/hash:RE_method
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        name: twigil
                        rest: ''
                      quant:
                      - '?'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \w
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
term__S_182proceed: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: proceed
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_183time: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: time
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_184now: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: now
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_185self: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: self
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_186defer: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: defer
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_187rand: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: rand
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    text: (
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  re: &116 !!perl/hash:RE_any
                    altname: term__S_187rand_0
                    dba: term
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: term__S_187rand_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_string
                      alt: term__S_187rand_0 1
                      i: 0
                      text: $
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: ()
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_187rand_0: *116
term__S_188Star: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_189StarStar: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_196reduce: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \S
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            text: ']'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '['
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ']'
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: \\
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: ']'
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_string
            i: 0
            text: ']'
          - !!perl/hash:RE_bracket
            re: &117 !!perl/hash:RE_any
              altname: term__S_196reduce_0
              dba: term
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_string
                alt: term__S_196reduce_0 0
                i: 0
                text: «
              - !!perl/hash:RE_assertion
                alt: term__S_196reduce_0 1
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_block
            nobind: 1
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      name: args
      rest: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
    - !!perl/hash:RE_block {}
term__S_196reduce_0: *117
term__S_213lambda: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: lambda
          rest: ''
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_331DotDotDot: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_332QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ???
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_333BangBangBang: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!!!'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: args
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_334identifier: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: identifier
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            re: &118 !!perl/hash:RE_any
              altname: term__S_334identifier_0
              dba: term
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: term__S_334identifier_0 0
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: term__S_334identifier_0 1
                i: 0
                text: (
          quant:
          - '?'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_cclass
        i: 0
        nobind: 1
        text: '[:]'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: args
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_334identifier_0: *118
term__S_335name: !!perl/hash:RE_ast
  dba: term
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: longname
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '['
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      text: '::'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_bracket
                      re: &119 !!perl/hash:RE_any
                        altname: term__S_335name_0
                        dba: namespace variable lookup
                        dic: STD::P6
                        zyg:
                        - !!perl/hash:RE_string
                          alt: term__S_335name_0 0
                          i: 0
                          text: «
                        - !!perl/hash:RE_string
                          alt: term__S_335name_0 1
                          i: 0
                          text: <
                        - !!perl/hash:RE_string
                          alt: term__S_335name_0 2
                          i: 0
                          text: '{'
                        - !!perl/hash:RE_string
                          alt: term__S_335name_0 3
                          i: 0
                          text: <<
                - !!perl/hash:RE_method
                  name: postcircumfix
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: args
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: O
      rest: 1
term__S_335name_0: *119
terminator__S_345Semi: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ;
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_346if: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: if
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_347unless: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: unless
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_348while: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: while
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_349until: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: until
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_350for: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: for
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_351given: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: given
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_352when: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: when
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_353MinusMinusGt: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: -->
    - !!perl/hash:RE_method
      name: O
      rest: 1
terminator__S_354BangBang: !!perl/hash:RE_ast
  dba: terminator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '!!'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: O
      rest: 1
termish: !!perl/hash:RE_ast
  dba: postfix
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &120 !!perl/hash:RE_any
        altname: termish_0
        dba: prefix or term
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: termish_0 0
          zyg:
          - !!perl/hash:RE_method
            name: PRE
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: PRE
                  rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
              - !!perl/hash:RE_method
                name: term
                rest: ''
              - !!perl/hash:RE_method
                name: panic
                rest: 1
        - !!perl/hash:RE_method
          alt: termish_0 1
          name: term
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: !!perl/hash:RE_first
              zyg:
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_first
                    zyg:
                    - !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_sequence
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '!'
                              re: !!perl/hash:RE_method_re
                                name: before
                                nobind: 1
                                re: !!perl/hash:RE_string
                                  i: 0
                                  text: \
                            - !!perl/hash:RE_method
                              name: POST
                              rest: ''
                        quant:
                        - +
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        re: !!perl/hash:RE_method_re
                          name: after
                          nobind: 1
                          re: !!perl/hash:RE_cclass
                            i: 0
                            text: '[ \] } > ) ]'
                    - !!perl/hash:RE_block {}
              - !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '!'
                        re: !!perl/hash:RE_method_re
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_string
                            i: 0
                            text: \
                      - !!perl/hash:RE_method
                        name: POST
                        rest: ''
                  quant:
                  - '*'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      text: '[ \] } > ) ]'
              - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: POST
              rest: ''
            quant:
            - '*'
    - !!perl/hash:RE_block {}
termish_0: *120
trait: !!perl/hash:RE_ast
  dba: trait
  dic: STD::P6
  re: !!perl/hash:RE_bracket
    re: &121 !!perl/hash:RE_any
      altname: trait_0
      dba: trait
      dic: STD::P6
      zyg:
      - !!perl/hash:RE_sequence
        alt: trait_0 0
        zyg:
        - !!perl/hash:RE_method
          name: trait_mod
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
      - !!perl/hash:RE_sequence
        alt: trait_0 1
        zyg:
        - !!perl/hash:RE_method
          name: colonpair
          rest: ''
        - !!perl/hash:RE_method
          name: ws
          rest: ''
trait_0: *121
trait_mod__S_068is: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: is
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: longname
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: circumfix
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_block {}
trait_mod__S_069hides: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: hides
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: typename
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_070does: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: typename
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_071will: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: will
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: pblock
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
trait_mod__S_072of: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &122 !!perl/hash:RE_any
        altname: trait_mod__S_072of_0
        dba: trait_mod
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_string
          alt: trait_mod__S_072of_0 0
          i: 0
          text: of
        - !!perl/hash:RE_string
          alt: trait_mod__S_072of_0 1
          i: 0
          text: returns
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: typename
            rest: ''
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
trait_mod__S_072of_0: *122
trait_mod__S_073handles: !!perl/hash:RE_ast
  dba: trait_mod
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: handles
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
tribble: !!perl/hash:RE_ast
  dba: tribble
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: babble
      rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_var
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: nibble
        rest: 1
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_var
          var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: nibble
              rest: 1
          - !!perl/hash:RE_var
            var: $stop
        - !!perl/hash:RE_method
          name: panic
          rest: 1
type_constraint: !!perl/hash:RE_ast
  dba: type_constraint
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &123 !!perl/hash:RE_any
        altname: type_constraint_0
        dba: type_constraint
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_method
          alt: type_constraint_0 0
          name: value
          rest: ''
        - !!perl/hash:RE_sequence
          alt: type_constraint_0 1
          zyg:
          - !!perl/hash:RE_method
            name: typename
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_block
                    nobind: 1
                - !!perl/hash:RE_method
                  name: sorry
                  rest: 1
            quant:
            - '?'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_constraint_0 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: w
          - !!perl/hash:RE_string
            i: 0
            text: h
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_string
            i: 0
            text: r
          - !!perl/hash:RE_string
            i: 0
            text: e
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      name: ws
      rest: ''
type_constraint_0: *123
type_declarator__S_162subset: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        endsym: keyspace
        i: 0
        name: sym
        rest: ''
        sym: subset
      - !!perl/hash:RE_method
        name: keyspace
        rest: ''
      - !!perl/hash:RE_method
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_method
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block {}
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: trait
              rest: ''
            quant:
            - '*'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: w
                - !!perl/hash:RE_string
                  i: 0
                  text: h
                - !!perl/hash:RE_string
                  i: 0
                  text: e
                - !!perl/hash:RE_string
                  i: 0
                  text: r
                - !!perl/hash:RE_string
                  i: 0
                  text: e
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: EXPR
                  rest: 1
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_method
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        name: ws
        rest: ''
type_declarator__S_163enum: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: enum
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &124 !!perl/hash:RE_any
        altname: type_declarator__S_163enum_0
        dba: type_declarator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_163enum_0 0
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: longname
              rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_163enum_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: variable
              rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_163enum_0 2
          assert: '?'
          re: !!perl/hash:RE_noop
            nobind: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[ < ( « ]'
    - !!perl/hash:RE_method
      name: term
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_block {}
type_declarator__S_163enum_0: *124
type_declarator__S_164constant: !!perl/hash:RE_ast
  dba: type_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      endsym: keyspace
      i: 0
      name: sym
      rest: ''
      sym: constant
    - !!perl/hash:RE_method
      name: keyspace
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: &125 !!perl/hash:RE_any
        altname: type_declarator__S_164constant_0
        dba: type_declarator
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_164constant_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_string
              i: 0
              text: \
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: defterm
            rest: ''
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_164constant_0 1
          zyg:
          - !!perl/hash:RE_method
            name: variable
            rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_164constant_0 2
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_method
          name: initializer
          rest: ''
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
type_declarator__S_164constant_0: *125
typename: !!perl/hash:RE_ast
  dba: typename
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &126 !!perl/hash:RE_any
        altname: typename_0
        dba: typename
        dic: STD::P6
        zyg:
        - !!perl/hash:RE_sequence
          alt: typename_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ::?
          - !!perl/hash:RE_method
            name: identifier
            rest: ''
        - !!perl/hash:RE_sequence
          alt: typename_0 1
          zyg:
          - !!perl/hash:RE_method
            name: longname
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '['
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: postcircumfix
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: postcircumfix
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: unsp
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: postcircumfix
              rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            text: of
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: typename
            rest: ''
      quant:
      - '?'
typename_0: *126
unitstart: !!perl/hash:RE_ast
  dba: unitstart
  dic: STD::P6
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_noop
      nobind: 1
value__S_133quote: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: quote
    rest: ''
value__S_134number: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: number
    rest: ''
value__S_135version: !!perl/hash:RE_ast
  dba: value
  dic: STD::P6
  re: !!perl/hash:RE_method
    name: version
    rest: ''
variable: !!perl/hash:RE_ast
  dba: variable
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sigil
            rest: ''
          - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: sigil
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: twigil
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: '::'
                - !!perl/hash:RE_bracket
                  re: &127 !!perl/hash:RE_any
                    altname: variable_0
                    dba: variable
                    dic: STD::P6
                    zyg:
                    - !!perl/hash:RE_string
                      alt: variable_0 0
                      i: 0
                      text: '{'
                    - !!perl/hash:RE_string
                      alt: variable_0 1
                      i: 0
                      text: <
                    - !!perl/hash:RE_string
                      alt: variable_0 2
                      i: 0
                      text: (
          - !!perl/hash:RE_method
            name: longname
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '&'
          - !!perl/hash:RE_bracket
            re: &128 !!perl/hash:RE_any
              altname: variable_1
              dba: infix noun
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_sequence
                alt: variable_1 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    name: twigil
                    rest: ''
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  name: sublongname
                  rest: ''
                - !!perl/hash:RE_block {}
              - !!perl/hash:RE_bracket
                alt: variable_1 1
                re: !!perl/hash:RE_sequence
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    text: '['
                  - !!perl/hash:RE_block {}
                  - !!perl/hash:RE_method
                    name: infixish
                    rest: 1
                  - !!perl/hash:RE_bracket
                    re: !!perl/hash:RE_first
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: ']'
                      - !!perl/hash:RE_method
                        name: FAILGOAL
                        rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '$::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: name
              rest: ''
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '$:'
          - !!perl/hash:RE_method
            name: name
            rest: ''
        - !!perl/hash:RE_bracket
          re: &129 !!perl/hash:RE_any
            altname: variable_2
            dba: variable
            dic: STD::P6
            zyg:
            - !!perl/hash:RE_sequence
              alt: variable_2 0
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  name: twigil
                  rest: ''
                quant:
                - '?'
              - !!perl/hash:RE_method
                name: desigilname
                rest: ''
              - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              alt: variable_2 1
              name: special_variable
              rest: ''
            - !!perl/hash:RE_sequence
              alt: variable_2 2
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  name: decint
                  rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 3
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: <
              - !!perl/hash:RE_method
                name: postcircumfix
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 4
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: (
              - !!perl/hash:RE_method
                name: postcircumfix
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  re: !!perl/hash:RE_sequence
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_block
                        nobind: 1
                    - !!perl/hash:RE_method
                      name: panic
                      rest: 1
                quant:
                - '?'
            - !!perl/hash:RE_sequence
              alt: variable_2 5
              zyg:
              - !!perl/hash:RE_method
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_block
                  nobind: 1
            - !!perl/hash:RE_sequence
              alt: variable_2 6
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
              - !!perl/hash:RE_block {}
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_bracket
            re: &130 !!perl/hash:RE_any
              altname: variable_3
              dba: variable
              dic: STD::P6
              zyg:
              - !!perl/hash:RE_method
                alt: variable_3 0
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: variable_3 1
                i: 0
                text: \
              - !!perl/hash:RE_assertion
                alt: variable_3 2
                assert: '?'
                re: !!perl/hash:RE_noop
                  nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: (
          - !!perl/hash:RE_method
            name: postcircumfix
            rest: ''
      quant:
      - '?'
variable_0: *127
variable_1: *128
variable_2: *129
variable_3: *130
variable_declarator: !!perl/hash:RE_ast
  dba: variable_declarator
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: variable
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: unsp
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                re: &131 !!perl/hash:RE_any
                  altname: variable_declarator_0
                  dba: shape definition
                  dic: STD::P6
                  zyg:
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 0
                    zyg:
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: (
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: )
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_block {}
                  - !!perl/hash:RE_bracket
                    alt: variable_declarator_0 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        text: '['
                      - !!perl/hash:RE_block {}
                      - !!perl/hash:RE_method
                        name: semilist
                        rest: ''
                      - !!perl/hash:RE_bracket
                        re: !!perl/hash:RE_first
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            text: ']'
                          - !!perl/hash:RE_method
                            name: FAILGOAL
                            rest: 1
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 2
                    zyg:
                    - !!perl/hash:RE_bracket
                      re: !!perl/hash:RE_sequence
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          text: '{'
                        - !!perl/hash:RE_block {}
                        - !!perl/hash:RE_method
                          name: semilist
                          rest: ''
                        - !!perl/hash:RE_bracket
                          re: !!perl/hash:RE_first
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              text: '}'
                            - !!perl/hash:RE_method
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_method
                      name: curlycheck
                      rest: 1
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 3
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      re: !!perl/hash:RE_method_re
                        name: before
                        nobind: 1
                        re: !!perl/hash:RE_string
                          i: 0
                          text: <
                    - !!perl/hash:RE_method
                      name: postcircumfix
                      rest: ''
              quant:
              - '*'
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: trait
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: post_constraint
        rest: ''
      quant:
      - '*'
    - !!perl/hash:RE_method
      name: getdecl
      rest: ''
variable_declarator_0: *131
version__S_039v: !!perl/hash:RE_ast
  dba: version
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: v
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \d
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: vnum
        rest: ''
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: +
      quant:
      - '?'
vnum: !!perl/hash:RE_ast
  dba: vnum
  dic: STD::P6
  re: &132 !!perl/hash:RE_any
    altname: vnum_0
    dba: vnum
    dic: STD::P6
    zyg:
    - !!perl/hash:RE_quantified_atom
      alt: vnum_0 0
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      quant:
      - +
    - !!perl/hash:RE_string
      alt: vnum_0 1
      i: 0
      text: '*'
vnum_0: *132
xblock: !!perl/hash:RE_ast
  dba: xblock
  dic: STD::P6
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: pblock
      rest: ''
RETREE_END
## rule comp_unit {
sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit', $retree) }
sub comp_unit {
no warnings 'recursion';
my $self = shift;

local $::begin_compunit = 1;local $::endargs = -1;local %::LANG;local $::PKGDECL = "";local $::IN_DECL = '';local $::HAS_SELF = '';local $::DECLARAND;local $::OFTYPE;local $::NEWPKG;local $::NEWLEX;local $::QSIGIL = '';local $::IN_META = '';local $::QUASIMODO;local $::SCOPE = "";local $::LEFTSIGIL;local $::PRECLIM;local %::MYSTERY = ();local $::INVOCANT_OK;local $::INVOCANT_IS;local $::CURLEX;local $::MULTINESS = '';local $::SIGNUM = 0;local $::MONKEY_TYPING = 0;local %::WORRIES;local @::WORRIES;local $::FATALS = 0;local $::IN_SUPPOSE = 0;local $::CURPKG;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comp_unit");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "comp_unit", do {
my $C = $C;
if (($C) = (scalar(do {
$::LANG{'MAIN'}    = 'STD::P6' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'P5'}      = 'STD::P5' ;
$::LANG{'P5Regex'} = 'STD::P5::Regex' ;
@::WORRIES = ();
$self->load_setting($::SETTINGNAME);
my $oid = $::SETTING->id;
my $id = 'MY:file<' . $::FILE->{'name'} . '>';
$::CURLEX = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => 0,
'!id' => [$id],
);
$ALL->{$id} = $::CURLEX;
$::UNIT = $::CURLEX;
$ALL->{'UNIT'} = $::UNIT;
$self->finishlex;
}, $C))
and ($C) = ($C->unitstart)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->unitstopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Confused"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_SUBSUMEblock('LEX', sub {
my $C = shift;
$::CURLEX }))) {
scalar(do {
$C->explain_mystery();
if (@::WORRIES) {
print STDERR "Potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
die "Check failed\n" if $::FATALS;
}, $C)
} else { () }

});
}
;
## token pblock () {
sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock', $retree) }
sub pblock {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pblock", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_0') {
$C->deb("Fate passed to pblock_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pblock_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
if ($::BORG and $::BORG->{'block'}) {
if ($::BORG->{'name'}) {
my $m = "Function '" . $::BORG->{'name'} . "' needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $::BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)")}
else {
$C->panic("Missing block")}}, $C)
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_1') {
$C->deb("Fate passed to pblock_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT pblock_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM pblock_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'pblock_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("pblock_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))
and ($C) = ($C->newlex(1))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->newlex(1))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token unitstart { <?> }
sub unitstart__PEEK { $_[0]->_AUTOLEXpeek('unitstart', $retree) }
sub unitstart {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstart");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstart", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token lambda { '->' | '<->' }
sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda', $retree) }
sub lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "lambda", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_0') {
$C->deb("Fate passed to lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT lambda_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM lambda_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'lambda_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\<\-\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token xblock {
sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock', $retree) }
sub xblock {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '{';local $::BORG = {
};
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE xblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "xblock", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = (scalar(do {
my $M = $C;
$::BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
})
} else { () }

});
}
;
## token block () {
sub block__PEEK { $_[0]->_AUTOLEXpeek('block', $retree) }
sub block {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "block", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing block"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->newlex)
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)) {
$C
} else { () }

});
}
;
## token blockoid {
sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid', $retree) }
sub blockoid {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local $::SIGNUM;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blockoid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blockoid", do {
my $C = $C;
if (($C) = ($C->finishlex)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_0') {
$C->deb("Fate passed to blockoid_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blockoid_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blockoid_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'blockoid_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("blockoid_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{YOU_ARE_HERE\}"))
and ($C) = ($C->you_are_here)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'block', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->curlycheck(1))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))
and ($C) = ($C->panic('Missing block'))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->panic("Malformed block"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token curlycheck($code) {
sub curlycheck__PEEK { $_[0]->_AUTOLEXpeek('curlycheck', $retree) }
sub curlycheck {
no warnings 'recursion';
my $self = shift;

die 'Required argument code omitted' unless @_;
my $code = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE curlycheck");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "curlycheck", $C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+(?m:$)/)
}))) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+[\\,:]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->unv)
and ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endargs'} = $code}, $C)
} else { () }

}
};
@gather;
}
}));
}
;
## token regex_block {
sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block', $retree) }
sub regex_block {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;local %::RX = %::RX;my $lang = $::LANG{'Regex'};local $::GOAL = '}';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "regex_block", do {
my $C = $C;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak(($kv->{'k'}->Str => $kv->{'v'}))
or $lang->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_block_0') {
$C->deb("Fate passed to regex_block_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_block_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_block_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_block_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_block_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{\*\}"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::MULTINESS eq 'proto' })
}))) {
$C->_SUBSUMEblock('onlystar', sub {
my $C = shift;
1})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find right brace"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->curlycheck(1))) {
$C
} else { () }

});
}
;
## rule statementlist {
sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist', $retree) }
sub statementlist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;local $::MONKEY_TYPING = $::MONKEY_TYPING;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statementlist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "statementlist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_0') {
$C->deb("Fate passed to statementlist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statementlist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statementlist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statementlist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statementlist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\z/))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$self->mark_sinks($M->{'statement'}) }, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## rule semilist {
sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist', $retree) }
sub semilist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semilist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "semilist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_0') {
$C->deb("Fate passed to semilist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT semilist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM semilist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'semilist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("semilist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token label {
sub label__PEEK { $_[0]->_AUTOLEXpeek('label', $retree) }
sub label {
no warnings 'recursion';
my $self = shift;

my $label;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE label");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "label", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$C->is_name($label = $M->{'identifier'}->Str) })
}))
and ($C) = ($C->worry("Redeclaration of '$label'"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
$C->add_constant($label,$self->label_id)}, $C)
} else { () }

});
}
;
## token statement {
sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement', $retree) }
sub statement {
no warnings 'recursion';
my $self = shift;

local $::endargs = -1;local $::QSIGIL = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement_mod_cond'} = [];
$C->{'statement_mod_loop'} = [];
$self->_MATCHIFYr($S, "statement", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::LASTSTATE = $C->{'_pos'};
$C = $::LANG{'MAIN'}->bless($C);
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_0') {
$C->deb("Fate passed to statement_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_1') {
$C->deb("Fate passed to statement_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
scalar(do {
my $M = $C;
my $sp = $M->{'EXPR'}->{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}->[0]->{'sym'};
if ($s eq 'while' or $s eq 'until') {
$C->obs("do...$s" ,"repeat...$s")};
};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
})
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\;")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("Bogus statement"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}]->{'endargs'}//0) == 1 })
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_2') {
$C->deb("Fate passed to statement_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
$::HIGHWATER = $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}}, $C))
and ($C) = ($C->panic("Strange text after block (missing comma, semicolon, comment marker?)"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token eat_terminator {
sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator', $retree) }
sub eat_terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE eat_terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "eat_terminator", $C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\;")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'}//0) >= 2 })
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'eat_terminator_0') {
$C->deb("Fate passed to eat_terminator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT eat_terminator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM eat_terminator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'eat_terminator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("eat_terminator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\z/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->backup_ws)
and ($C) = (scalar(do {
$::HIGHWATER = -1}, $C))
and ($C) = ($C->panic("Missing semicolon"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }

}
};
@gather;
}
}));
}
;
## method backup_ws ()
sub backup_ws {
no warnings 'recursion';
my $self = shift;
if ($::MEMOS[$self->{'_pos'}]->{'ws'}) {
return $self->cursor($::MEMOS[$self->{'_pos'}]->{'ws'})};
return $self;
};
## rule statement_control:need {
sub statement_control__S_000need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_000need', $retree) }
sub statement_control__S_000need {
no warnings 'recursion';
my $self = shift;

my $longname;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_000need");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'module_name'} = [];
$C->{'version'} = [];
$C->{sym} = "need";
$self->_MATCHIFYr($S, "statement_control__S_000need", do {
my $C = $C;
if (($C) = ($C->_EXACT("need"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)) {
$C->_REPSEPr( sub {
my $C=shift;
if (($C) = ($C->_EXACT("\,"))
and ($C) = ($C->ws)) {
$C
} else { () }
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_000need_0') {
$C->deb("Fate passed to statement_control__S_000need_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_000need_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_000need_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_000need_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_000need_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
$longname = $M->{'module_name'}->[-1]->{'longname'};
$C->do_need($longname->{'name'});
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token statement_control:import {
sub statement_control__S_001import__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_001import', $retree) }
sub statement_control__S_001import {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'use';local $::HAS_SELF = '';local $::SCOPE = 'use';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_001import");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "import";
$self->_MATCHIFYr($S, "statement_control__S_001import", do {
my $C = $C;
if (($C) = ($C->_EXACT("import"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
local %::MYSTERY;
$C->do_import($M->{'term'}, $M->{'arglist'});
$C->explain_mystery();
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
$C->do_import($M->{'term'}, '')}, $C)
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_control:use {
sub statement_control__S_002use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_002use', $retree) }
sub statement_control__S_002use {
no warnings 'recursion';
my $self = shift;

my $longname;local $::IN_DECL = 'use';local $::SCOPE = 'use';local $::HAS_SELF = '';local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_002use");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "use";
$self->_MATCHIFYr($S, "statement_control__S_002use", do {
my $C = $C;
if (($C) = ($C->_EXACT("use"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_002use_0') {
$C->deb("Fate passed to statement_control__S_002use_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_002use_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_002use_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_002use_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_002use_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = (scalar(do {
my $M = $C;
$longname = $M->{'module_name'}->{'longname'};
if ($longname->Str eq 'MONKEY_TYPING') {
$::MONKEY_TYPING = 1};
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
$C->do_use($longname->{'name'}, $M->{'arglist'})}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->do_use($longname->{'name'}, '')}, $C)
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)) {
$C
} else { () }

});
}
;
## rule statement_control:no {
sub statement_control__S_003no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_003no', $retree) }
sub statement_control__S_003no {
no warnings 'recursion';
my $self = shift;

local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_003no");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "no";
$self->_MATCHIFYr($S, "statement_control__S_003no", do {
my $C = $C;
if (($C) = ($C->_EXACT("no"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:if {
sub statement_control__S_004if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_004if', $retree) }
sub statement_control__S_004if {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_004if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_control__S_004if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_004if_0') {
$C->deb("Fate passed to statement_control__S_004if_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_004if_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_004if_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_004if_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_004if_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gelse[\x20\t\r]*+if/))
and ($C) = ($C->ws)
and ($C) = ($C->sorry("Please use 'elsif'"))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("elsif"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->keyspace)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("else"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->keyspace)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:unless {
sub statement_control__S_005unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_005unless', $retree) }
sub statement_control__S_005unless {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_005unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_control__S_005unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("else")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("\"unless\" does not take \"else\" in Perl 6; please rewrite using \"if\""))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule statement_control:while {
sub statement_control__S_006while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_006while', $retree) }
sub statement_control__S_006while {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_006while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_control__S_006while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)) {
$C->_EXACT("\=")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\<"))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$?+\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\>"))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->panic("This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:until {
sub statement_control__S_007until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_007until', $retree) }
sub statement_control__S_007until {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_007until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_control__S_007until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:repeat {
sub statement_control__S_008repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_008repeat', $retree) }
sub statement_control__S_008repeat {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_008repeat");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "repeat";
$self->_MATCHIFYr($S, "statement_control__S_008repeat", do {
my $C = $C;
if (($C) = ($C->_EXACT("repeat"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_0') {
$C->deb("Fate passed to statement_control__S_008repeat_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_1') {
$C->deb("Fate passed to statement_control__S_008repeat_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_2') {
$C->deb("Fate passed to statement_control__S_008repeat_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT statement_control__S_008repeat_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM statement_control__S_008repeat_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("statement_control__S_008repeat_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic('"repeat" is missing its "while" or "until"'))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## rule statement_control:loop {
sub statement_control__S_009loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_009loop', $retree) }
sub statement_control__S_009loop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_009loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "loop";
$self->_MATCHIFYr($S, "statement_control__S_009loop", do {
my $C = $C;
if (($C) = ($C->_EXACT("loop"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['eee'], sub {
my $C = shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e1'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e2'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e3'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed loop spec"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]->{'ws'} })
}))
and ($C) = ($C->ws)
and ($C) = ($C->sorry("Whitespace required before block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
};

}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:for {
sub statement_control__S_010for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_010for', $retree) }
sub statement_control__S_010for {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_010for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_control__S_010for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->panic("This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\)"))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:given {
sub statement_control__S_011given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_011given', $retree) }
sub statement_control__S_011given {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_011given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_control__S_011given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:when {
sub statement_control__S_012when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_012when', $retree) }
sub statement_control__S_012when {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_012when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_control__S_012when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:default {<sym> <block> }
sub statement_control__S_013default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_013default', $retree) }
sub statement_control__S_013default {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_013default");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "default";
$self->_MATCHIFYr($S, "statement_control__S_013default", do {
my $C = $C;
if (($C) = ($C->_EXACT("default"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_prefix:BEGIN   { :my %*MYSTERY; <sym> <blast> <.explain_mystery> }
sub statement_prefix__S_014BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_014BEGIN', $retree) }
sub statement_prefix__S_014BEGIN {
no warnings 'recursion';
my $self = shift;

local %::MYSTERY;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_014BEGIN");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "BEGIN";
$self->_MATCHIFYr($S, "statement_prefix__S_014BEGIN", do {
my $C = $C;
if (($C) = ($C->_EXACT("BEGIN"))
and ($C) = ($C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
}))
and ($C) = ($C->explain_mystery)) {
$C
} else { () }

});
}
;
## token statement_prefix:CHECK   { <sym> <blast> }
sub statement_prefix__S_015CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_015CHECK', $retree) }
sub statement_prefix__S_015CHECK {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_015CHECK");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CHECK";
$self->_MATCHIFYr($S, "statement_prefix__S_015CHECK", do {
if (my ($C) = ($C->_EXACT("CHECK"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:INIT    { <sym> <blast> }
sub statement_prefix__S_016INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_016INIT', $retree) }
sub statement_prefix__S_016INIT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_016INIT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "INIT";
$self->_MATCHIFYr($S, "statement_prefix__S_016INIT", do {
if (my ($C) = ($C->_EXACT("INIT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:START   { <sym> <blast> }
sub statement_prefix__S_017START__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_017START', $retree) }
sub statement_prefix__S_017START {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_017START");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "START";
$self->_MATCHIFYr($S, "statement_prefix__S_017START", do {
if (my ($C) = ($C->_EXACT("START"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:ENTER   { <sym> <blast> }
sub statement_prefix__S_018ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_018ENTER', $retree) }
sub statement_prefix__S_018ENTER {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_018ENTER");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ENTER";
$self->_MATCHIFYr($S, "statement_prefix__S_018ENTER", do {
if (my ($C) = ($C->_EXACT("ENTER"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:FIRST   { <sym> <blast> }
sub statement_prefix__S_019FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_019FIRST', $retree) }
sub statement_prefix__S_019FIRST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_019FIRST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "FIRST";
$self->_MATCHIFYr($S, "statement_prefix__S_019FIRST", do {
if (my ($C) = ($C->_EXACT("FIRST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:END     { <sym> <blast> }
sub statement_prefix__S_020END__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_020END', $retree) }
sub statement_prefix__S_020END {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_020END");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "END";
$self->_MATCHIFYr($S, "statement_prefix__S_020END", do {
if (my ($C) = ($C->_EXACT("END"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:LEAVE   { <sym> <blast> }
sub statement_prefix__S_021LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_021LEAVE', $retree) }
sub statement_prefix__S_021LEAVE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_021LEAVE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LEAVE";
$self->_MATCHIFYr($S, "statement_prefix__S_021LEAVE", do {
if (my ($C) = ($C->_EXACT("LEAVE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:KEEP    { <sym> <blast> }
sub statement_prefix__S_022KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_022KEEP', $retree) }
sub statement_prefix__S_022KEEP {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_022KEEP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "KEEP";
$self->_MATCHIFYr($S, "statement_prefix__S_022KEEP", do {
if (my ($C) = ($C->_EXACT("KEEP"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:UNDO    { <sym> <blast> }
sub statement_prefix__S_023UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_023UNDO', $retree) }
sub statement_prefix__S_023UNDO {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_023UNDO");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "UNDO";
$self->_MATCHIFYr($S, "statement_prefix__S_023UNDO", do {
if (my ($C) = ($C->_EXACT("UNDO"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:NEXT    { <sym> <blast> }
sub statement_prefix__S_024NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_024NEXT', $retree) }
sub statement_prefix__S_024NEXT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_024NEXT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "NEXT";
$self->_MATCHIFYr($S, "statement_prefix__S_024NEXT", do {
if (my ($C) = ($C->_EXACT("NEXT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:LAST    { <sym> <blast> }
sub statement_prefix__S_025LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_025LAST', $retree) }
sub statement_prefix__S_025LAST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_025LAST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LAST";
$self->_MATCHIFYr($S, "statement_prefix__S_025LAST", do {
if (my ($C) = ($C->_EXACT("LAST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:PRE     { <sym> <blast> }
sub statement_prefix__S_026PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_026PRE', $retree) }
sub statement_prefix__S_026PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_026PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "PRE";
$self->_MATCHIFYr($S, "statement_prefix__S_026PRE", do {
if (my ($C) = ($C->_EXACT("PRE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:POST    { <sym> <blast> }
sub statement_prefix__S_027POST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_027POST', $retree) }
sub statement_prefix__S_027POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_027POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "POST";
$self->_MATCHIFYr($S, "statement_prefix__S_027POST", do {
if (my ($C) = ($C->_EXACT("POST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## rule statement_control:CATCH   {<sym> <block> }
sub statement_control__S_028CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_028CATCH', $retree) }
sub statement_control__S_028CATCH {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_028CATCH");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CATCH";
$self->_MATCHIFYr($S, "statement_control__S_028CATCH", do {
my $C = $C;
if (($C) = ($C->_EXACT("CATCH"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:CONTROL {<sym> <block> }
sub statement_control__S_029CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_029CONTROL', $retree) }
sub statement_control__S_029CONTROL {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_029CONTROL");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CONTROL";
$self->_MATCHIFYr($S, "statement_control__S_029CONTROL", do {
my $C = $C;
if (($C) = ($C->_EXACT("CONTROL"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_control:TEMP    {<sym> <block> }
sub statement_control__S_030TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_030TEMP', $retree) }
sub statement_control__S_030TEMP {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_030TEMP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "TEMP";
$self->_MATCHIFYr($S, "statement_control__S_030TEMP", do {
my $C = $C;
if (($C) = ($C->_EXACT("TEMP"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule modifier_expr { <EXPR> }
sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr', $retree) }
sub modifier_expr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE modifier_expr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "modifier_expr", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:if     {<sym> <modifier_expr> }
sub statement_mod_cond__S_031if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_031if', $retree) }
sub statement_mod_cond__S_031if {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_031if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_mod_cond__S_031if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:unless {<sym> <modifier_expr> }
sub statement_mod_cond__S_032unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_032unless', $retree) }
sub statement_mod_cond__S_032unless {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_032unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_mod_cond__S_032unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_cond:when   {<sym> <?dumbsmart> <modifier_expr> }
sub statement_mod_cond__S_033when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_033when', $retree) }
sub statement_mod_cond__S_033when {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_033when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_mod_cond__S_033when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:while {<sym> <modifier_expr> }
sub statement_mod_loop__S_034while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_034while', $retree) }
sub statement_mod_loop__S_034while {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_034while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_mod_loop__S_034while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:until {<sym> <modifier_expr> }
sub statement_mod_loop__S_035until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_035until', $retree) }
sub statement_mod_loop__S_035until {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_035until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_mod_loop__S_035until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:for   {<sym> <modifier_expr> }
sub statement_mod_loop__S_036for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_036for', $retree) }
sub statement_mod_loop__S_036for {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_036for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_mod_loop__S_036for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule statement_mod_loop:given {<sym> <modifier_expr> }
sub statement_mod_loop__S_037given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_037given', $retree) }
sub statement_mod_loop__S_037given {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_037given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_mod_loop__S_037given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token module_name:normal {
sub module_name__S_038normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_038normal', $retree) }
sub module_name__S_038normal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE module_name__S_038normal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "normal";
$self->_MATCHIFYr($S, "module_name__S_038normal", do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token vnum {
sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum', $retree) }
sub vnum {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vnum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vnum", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_0') {
$C->deb("Fate passed to vnum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT vnum_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM vnum_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'vnum_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("vnum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_EXACT("\*")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token version:sym<v> {
sub version__S_039v__PEEK { $_[0]->_AUTOLEXpeek('version__S_039v', $retree) }
sub version__S_039v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE version__S_039v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{sym} = "v";
$self->_MATCHIFYr($S, "version__S_039v", do {
my $C = $C;
if (($C) = ($C->_EXACT("v"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\.")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))) {
$C->_PATTERN(qr/\G\+?+/)
} else { () }

});
}
;
## token variable_declarator {
sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator', $retree) }
sub variable_declarator {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'variable';local $::DECLARAND;my $var;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'post_constraint'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];
$C->{'shape'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "variable_declarator", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
and ($C) = (scalar(do {
my $M = $C;
$var = $M->{'variable'}->Str;
$C->add_variable($var);
$::IN_DECL = '';
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['shape'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_0') {
$C->deb("Fate passed to variable_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'variable_declarator', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
given (substr($var,0,1)) {
when ('&') {
$C->sorry("The () shape syntax in routine declarations is reserved (maybe use :() to declare a longname?)")}
;
when ('@') {
$C->sorry("The () shape syntax in array declarations is reserved")}
;
when ('%') {
$C->sorry("The () shape syntax in hash declarations is reserved")}
;
default {
$C->sorry("The () shape syntax in variable declarations is reserved")}
;
}
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->curlycheck(0))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
})
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }

});
}
;
## token scoped ($*SCOPE) {
sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped', $retree) }
sub scoped {
no warnings 'recursion';
my $self = shift;

die 'Required argument SCOPE omitted' unless @_;
local $::SCOPE = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scoped");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$self->_MATCHIFYr($S, "scoped", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_0') {
$C->deb("Fate passed to scoped_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT scoped_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM scoped_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'scoped_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("scoped_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
},
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'typename'};
@$t > 1 and $C->sorry("Multiple prefix constraints not yet supported");
$::OFTYPE = $t->[0];
}, $C))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->sorry("In $::SCOPE declaration, typename '$t' must be predeclared (or marked as declarative with :: prefix)")};
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed $::SCOPE"))) { ($C) } else { () }

}
};
@gather;
});
}
;
## token scope_declarator:my        { <sym> <scoped('my')> }
sub scope_declarator__S_040my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_040my', $retree) }
sub scope_declarator__S_040my {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_040my");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "my";
$self->_MATCHIFYr($S, "scope_declarator__S_040my", do {
my $C = $C;
if (($C) = ($C->_EXACT("my"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('my')
})
} else { () }

});
}
;
## token scope_declarator:our       { <sym> <scoped('our')> }
sub scope_declarator__S_041our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_041our', $retree) }
sub scope_declarator__S_041our {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_041our");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "our";
$self->_MATCHIFYr($S, "scope_declarator__S_041our", do {
my $C = $C;
if (($C) = ($C->_EXACT("our"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('our')
})
} else { () }

});
}
;
## token scope_declarator:anon      { <sym> <scoped('anon')> }
sub scope_declarator__S_042anon__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_042anon', $retree) }
sub scope_declarator__S_042anon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_042anon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "anon";
$self->_MATCHIFYr($S, "scope_declarator__S_042anon", do {
my $C = $C;
if (($C) = ($C->_EXACT("anon"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('anon')
})
} else { () }

});
}
;
## token scope_declarator:state     { <sym> <scoped('state')> }
sub scope_declarator__S_043state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_043state', $retree) }
sub scope_declarator__S_043state {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_043state");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "state";
$self->_MATCHIFYr($S, "scope_declarator__S_043state", do {
my $C = $C;
if (($C) = ($C->_EXACT("state"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('state')
})
} else { () }

});
}
;
## token scope_declarator:augment   { <sym> <scoped('augment')> }
sub scope_declarator__S_044augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_044augment', $retree) }
sub scope_declarator__S_044augment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_044augment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "augment";
$self->_MATCHIFYr($S, "scope_declarator__S_044augment", do {
my $C = $C;
if (($C) = ($C->_EXACT("augment"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('augment')
})
} else { () }

});
}
;
## token scope_declarator:supersede { <sym> <scoped('supersede')> }
sub scope_declarator__S_045supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_045supersede', $retree) }
sub scope_declarator__S_045supersede {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_045supersede");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "supersede";
$self->_MATCHIFYr($S, "scope_declarator__S_045supersede", do {
my $C = $C;
if (($C) = ($C->_EXACT("supersede"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('supersede')
})
} else { () }

});
}
;
## token scope_declarator:has       {
sub scope_declarator__S_046has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_046has', $retree) }
sub scope_declarator__S_046has {
no warnings 'recursion';
my $self = shift;

local $::HAS_SELF = 'partial';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_046has");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "has";
$self->_MATCHIFYr($S, "scope_declarator__S_046has", do {
my $C = $C;
if (($C) = ($C->_EXACT("has"))
and ($C) = ($C->nofun)
and ($C) = (scalar(do {
given ($::PKGDECL) {
when ('class')   {
}
;
when ('grammar') {
}
;
when ('role')    {
}
;
default {
$C->worry("'has' declaration outside of class") }
;
}
}, $C))) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('has')
})
} else { () }

});
}
;
## token package_declarator:class {
sub package_declarator__S_047class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_047class', $retree) }
sub package_declarator__S_047class {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'class';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_047class");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "class";
$self->_MATCHIFYr($S, "package_declarator__S_047class", do {
my $C = $C;
if (($C) = ($C->_EXACT("class"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:grammar {
sub package_declarator__S_048grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_048grammar', $retree) }
sub package_declarator__S_048grammar {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'grammar';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_048grammar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "grammar";
$self->_MATCHIFYr($S, "package_declarator__S_048grammar", do {
my $C = $C;
if (($C) = ($C->_EXACT("grammar"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:module {
sub package_declarator__S_049module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_049module', $retree) }
sub package_declarator__S_049module {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'module';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_049module");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module";
$self->_MATCHIFYr($S, "package_declarator__S_049module", do {
my $C = $C;
if (($C) = ($C->_EXACT("module"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:package {
sub package_declarator__S_050package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_050package', $retree) }
sub package_declarator__S_050package {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'package';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_050package");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package";
$self->_MATCHIFYr($S, "package_declarator__S_050package", do {
my $C = $C;
if (($C) = ($C->_EXACT("package"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:role {
sub package_declarator__S_051role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_051role', $retree) }
sub package_declarator__S_051role {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'role';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_051role");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "role";
$self->_MATCHIFYr($S, "package_declarator__S_051role", do {
my $C = $C;
if (($C) = ($C->_EXACT("role"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:knowhow {
sub package_declarator__S_052knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_052knowhow', $retree) }
sub package_declarator__S_052knowhow {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'knowhow';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_052knowhow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "knowhow";
$self->_MATCHIFYr($S, "package_declarator__S_052knowhow", do {
my $C = $C;
if (($C) = ($C->_EXACT("knowhow"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:slang {
sub package_declarator__S_053slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_053slang', $retree) }
sub package_declarator__S_053slang {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'slang';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_053slang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "slang";
$self->_MATCHIFYr($S, "package_declarator__S_053slang", do {
my $C = $C;
if (($C) = ($C->_EXACT("slang"))
and ($C) = ($C->keyspace)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }

});
}
;
## token package_declarator:require {   # here because of declarational aspects
sub package_declarator__S_054require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_054require', $retree) }
sub package_declarator__S_054require {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_054require");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{sym} = "require";
$self->_MATCHIFYr($S, "package_declarator__S_054require", do {
my $C = $C;
if (($C) = ($C->_EXACT("require"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
scalar(do {
my $M = $C;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
$C->add_name($M->{'module_name'}->{'longname'}->{'name'}->Str);
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule package_declarator:trusts {
sub package_declarator__S_055trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_055trusts', $retree) }
sub package_declarator__S_055trusts {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_055trusts");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trusts";
$self->_MATCHIFYr($S, "package_declarator__S_055trusts", do {
my $C = $C;
if (($C) = ($C->_EXACT("trusts"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule package_declarator:sym<also> {
sub package_declarator__S_056also__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_056also', $retree) }
sub package_declarator__S_056also {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_056also");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "also";
$self->_MATCHIFYr($S, "package_declarator__S_056also", do {
my $C = $C;
if (($C) = ($C->_EXACT("also"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("No valid trait found after also"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule package_def {
sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def', $retree) }
sub package_def {
no warnings 'recursion';
my $self = shift;

my $longname;local $::IN_DECL = 'package';local $::HAS_SELF = '';local $::DECLARAND;local $::NEWPKG;local $::NEWLEX;my $outer = $::CURLEX;local $::CURPKG = $::CURPKG;local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "package_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$::SCOPE ||= 'our'}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$longname = $M->{'longname'}->[0];
$C->add_name($longname->{'name'}->Str);
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
$::IN_DECL = ''}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->getdecl)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = (scalar(do {
if ($longname and $::NEWPKG) {
my $shortname = $longname->{'name'}->Str;
if ($::SCOPE eq 'our') {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added our " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
}
else {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added my " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
};
};
$::begin_compunit = 0;
$::UNIT->{'$?LONGNAME'} ||= $longname ? $longname->{'name'}->Str : '';
}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->ws)
and ($C) = ($C->checkyada)
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\;")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::begin_compunit })
}))
and ($C) = (scalar(do {
$longname  or  $C->panic("Compilation unit cannot be anonymous");
$outer == $::UNIT or $C->panic("Semicolon form of " . $::PKGDECL . " definition not allowed in subscope;\n  please use block form");
$::PKGDECL eq 'package' and $C->panic("Semicolon form of package definition indicates a Perl 5 module; unfortunately,\n  STD doesn't know how to parse Perl 5 code yet");
my $shortname = $longname->{'name'}->Str;
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$::begin_compunit = 0;
$::CURLEX = $outer;
$::UNIT->{'$?LONGNAME'} = $longname->{'name'}->Str;
}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Too late for semicolon form of " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed $::PKGDECL"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## token declarator {
sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator', $retree) }
sub declarator {
no warnings 'recursion';
my $self = shift;

local $::LEFTSIGIL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'initializer'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "declarator", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_0') {
$C->deb("Fate passed to declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['initializer'], sub {
my $C = shift;
$C->initializer
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Term definition requires an initializer"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['initializer'], sub {
my $C = shift;
$C->initializer
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\,"))
and ($C) = ($C->ws)) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'declend'} = $::SCOPE}, $C)
} else { () }
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'declarator', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['initializer'], sub {
my $C = shift;
$C->initializer
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## rule multi_declarator:multi {
sub multi_declarator__S_057multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_057multi', $retree) }
sub multi_declarator__S_057multi {
no warnings 'recursion';
my $self = shift;

local $::MULTINESS = 'multi';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_057multi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi";
$self->_MATCHIFYr($S, "multi_declarator__S_057multi", do {
my $C = $C;
if (($C) = ($C->_EXACT("multi"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('multi')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic('Malformed multi'))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule multi_declarator:proto {
sub multi_declarator__S_058proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_058proto', $retree) }
sub multi_declarator__S_058proto {
no warnings 'recursion';
my $self = shift;

local $::MULTINESS = 'proto';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_058proto");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proto";
$self->_MATCHIFYr($S, "multi_declarator__S_058proto", do {
my $C = $C;
if (($C) = ($C->_EXACT("proto"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('proto')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic('Malformed proto'))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule multi_declarator:only {
sub multi_declarator__S_059only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_059only', $retree) }
sub multi_declarator__S_059only {
no warnings 'recursion';
my $self = shift;

local $::MULTINESS = 'only';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_059only");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "only";
$self->_MATCHIFYr($S, "multi_declarator__S_059only", do {
my $C = $C;
if (($C) = ($C->_EXACT("only"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('only')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic('Malformed only'))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## rule multi_declarator:null {
sub multi_declarator__S_060null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_060null', $retree) }
sub multi_declarator__S_060null {
no warnings 'recursion';
my $self = shift;

local $::MULTINESS = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_060null");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "null";
$self->_MATCHIFYr($S, "multi_declarator__S_060null", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule routine_declarator:sub       { <sym> <routine_def('sub')> }
sub routine_declarator__S_061sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_061sub', $retree) }
sub routine_declarator__S_061sub {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_061sub");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sub";
$self->_MATCHIFYr($S, "routine_declarator__S_061sub", do {
my $C = $C;
if (($C) = ($C->_EXACT("sub"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('sub')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule routine_declarator:method    { <sym> <method_def('method')> }
sub routine_declarator__S_062method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_062method', $retree) }
sub routine_declarator__S_062method {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_062method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "routine_declarator__S_062method", do {
my $C = $C;
if (($C) = ($C->_EXACT("method"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def('method')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule routine_declarator:submethod { <sym> <method_def('submethod')> }
sub routine_declarator__S_063submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_063submethod', $retree) }
sub routine_declarator__S_063submethod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_063submethod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "submethod";
$self->_MATCHIFYr($S, "routine_declarator__S_063submethod", do {
my $C = $C;
if (($C) = ($C->_EXACT("submethod"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def('submethod')
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule routine_declarator:macro     { <sym> <macro_def> }
sub routine_declarator__S_064macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_064macro', $retree) }
sub routine_declarator__S_064macro {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_064macro");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "macro";
$self->_MATCHIFYr($S, "routine_declarator__S_064macro", do {
my $C = $C;
if (($C) = ($C->_EXACT("macro"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule regex_declarator:regex { <sym> <regex_def('regex', :!r,:!s)> }
sub regex_declarator__S_065regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_065regex', $retree) }
sub regex_declarator__S_065regex {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_065regex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex";
$self->_MATCHIFYr($S, "regex_declarator__S_065regex", do {
my $C = $C;
if (($C) = ($C->_EXACT("regex"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('regex', 'r' => 0,'s' => 0)
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule regex_declarator:token { <sym> <regex_def('token', :r,:!s)> }
sub regex_declarator__S_066token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_066token', $retree) }
sub regex_declarator__S_066token {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_066token");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "token";
$self->_MATCHIFYr($S, "regex_declarator__S_066token", do {
my $C = $C;
if (($C) = ($C->_EXACT("token"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('token', 'r' => 1,'s' => 0)
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule regex_declarator:rule  { <sym> <regex_def('rule',  :r,:s)> }
sub regex_declarator__S_067rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_067rule', $retree) }
sub regex_declarator__S_067rule {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_067rule");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rule";
$self->_MATCHIFYr($S, "regex_declarator__S_067rule", do {
my $C = $C;
if (($C) = ($C->_EXACT("rule"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('rule',  'r' => 1,'s' => 1)
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule multisig {
sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig', $retree) }
sub multisig {
no warnings 'recursion';
my $self = shift;

my $signum = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multisig");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'signature'} = [];
$self->_MATCHIFYr($S, "multisig", $C->_REPSEPr( sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->ws)) {
$C
} else { () }
}, sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\:?+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(++$signum)
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}));
}
;
## method checkyada
sub checkyada {
no warnings 'recursion';
my $self = shift;
eval {
my $statements = $self->{'blockoid'}->{'statementlist'}->{'statement'};
my $startsym = $statements->[0]->{'EXPR'}->{'sym'} // '';
given ($startsym) {
when ('...') {
$::DECLARAND->{'stub'} = 1 }
;
when ('!!!') {
$::DECLARAND->{'stub'} = 1 }
;
when ('???') {
$::DECLARAND->{'stub'} = 1 }
;
when ('*') {
if ($::MULTINESS eq 'proto' and $statements->elems == 1) {
delete $self->{'blockoid'};
$self->{'onlystar'} = 1;
}}
;
}
;
};
return $self;
};
## rule routine_def ($d) {
sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def', $retree) }
sub routine_def {
no warnings 'recursion';
my $self = shift;

die 'Required argument d omitted' unless @_;
my $d = @_ ? shift() : undef;
local $::CURLEX = $::CURLEX;local $::IN_DECL = $d;local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'sigil'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "routine_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_0') {
$C->deb("Fate passed to routine_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("routine_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\&\*?+/)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_1') {
$C->deb("Fate passed to routine_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT routine_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM routine_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'routine_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("routine_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL = ''})
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed routine"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule method_def ($d) {
sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def', $retree) }
sub method_def {
no warnings 'recursion';
my $self = shift;

die 'Required argument d omitted' unless @_;
my $d = @_ ? shift() : undef;
local $::CURLEX = $::CURLEX;local $::IN_DECL = $d;local $::DECLARAND;local $::HAS_SELF = $d eq 'submethod' ? 'partial' : 'complete';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE method_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "method_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_0') {
$C->deb("Fate passed to method_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['type'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[!^])?+/)
})
}))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_1') {
$C->deb("Fate passed to method_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_2') {
$C->deb("Fate passed to method_def_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT method_def_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM method_def_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'method_def_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("method_def_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
my $M = $C;
given ($::PKGDECL) {
when ('class')   {
}
;
when ('grammar') {
}
;
when ('role')    {
}
;
default {
$C->worry("'$d' declaration outside of class") if ($::SCOPE || 'has') eq 'has' && $M->{'longname'} }
;
}
}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed method"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule regex_def ($d, :$r, :$s) {
sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def', $retree) }
sub regex_def {
no warnings 'recursion';
my $self = shift;

die 'Required argument d omitted' unless @_;
my $d = @_ ? shift() : undef;
my %args = @_;
my $r = exists $args{r} ? delete $args{r} : undef;
my $s = exists $args{s} ? delete $args{s} : undef;
local $::CURLEX = $::CURLEX;local $::IN_DECL = $d;local %::RX = %::RX;local $::DECLARAND;local $::HAS_SELF = 'complete';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "regex_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$::RX{'s'} = $s;
$::RX{'r'} = $r;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_0') {
$C->deb("Fate passed to regex_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_1') {
$C->deb("Fate passed to regex_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM regex_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'regex_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("regex_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\:?+\(/))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
my $M = $C;
given ($::PKGDECL) {
when ('grammar') {
}
;
when ('role')    {
}
;
default {
$C->worry("'$d' declaration outside of grammar") if ($::SCOPE || 'has') eq 'has' && $M->{'deflongname'}->[0] }
;
}
}, $C))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->finishlex)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
}))
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed regex"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule macro_def () {
sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def', $retree) }
sub macro_def {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;local $::IN_DECL = 'macro';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE macro_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "macro_def", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_0') {
$C->deb("Fate passed to macro_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("macro_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newlex(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_1') {
$C->deb("Fate passed to macro_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT macro_def_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM macro_def_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'macro_def_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("macro_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->panic("Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed macro"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## rule trait {
sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait', $retree) }
sub trait {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "trait", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_0') {
$C->deb("Fate passed to trait_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("trait_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## rule trait_mod:is {
sub trait_mod__S_068is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_068is', $retree) }
sub trait_mod__S_068is {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_068is");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$C->{sym} = "is";
$self->_MATCHIFYr($S, "trait_mod__S_068is", do {
my $C = $C;
if (($C) = ($C->_EXACT("is"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Invalid trait name"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
if ($::DECLARAND) {
my $traitname = $M->{'longname'}->Str;
$::DECLARAND->{$traitname} = $self->gettrait($traitname, $M->{'circumfix'});
}}, $C)
} else { () }

});
}
;
## rule trait_mod:hides {
sub trait_mod__S_069hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_069hides', $retree) }
sub trait_mod__S_069hides {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_069hides");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "hides";
$self->_MATCHIFYr($S, "trait_mod__S_069hides", do {
my $C = $C;
if (($C) = ($C->_EXACT("hides"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Invalid class name"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule trait_mod:does {
sub trait_mod__S_070does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_070does', $retree) }
sub trait_mod__S_070does {
no warnings 'recursion';
my $self = shift;

local $::PKGDECL = 'role';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_070does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "trait_mod__S_070does", do {
my $C = $C;
if (($C) = ($C->_EXACT("does"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Invalid role name"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule trait_mod:will {
sub trait_mod__S_071will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_071will', $retree) }
sub trait_mod__S_071will {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_071will");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "will";
$self->_MATCHIFYr($S, "trait_mod__S_071will", do {
my $C = $C;
if (($C) = ($C->_EXACT("will"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Invalid phaser"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule trait_mod:of {
sub trait_mod__S_072of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_072of', $retree) }
sub trait_mod__S_072of {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_072of");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "of";
$self->_MATCHIFYr($S, "trait_mod__S_072of", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_mod__S_072of_0') {
$C->deb("Fate passed to trait_mod__S_072of_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT trait_mod__S_072of_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM trait_mod__S_072of_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'trait_mod__S_072of_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("trait_mod__S_072of_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("of")
},
sub {
my $C=shift;
$C->_EXACT("returns")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Invalid type name"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::DECLARAND->{'of'} })
}))
and ($C) = ($C->ws)
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::DECLARAND->{'of'}->Str))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$::DECLARAND->{'of'} = $M->{'typename'}}, $C)
} else { () }

});
}
;
## rule trait_mod:handles { <sym> <term> }
sub trait_mod__S_073handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_073handles', $retree) }
sub trait_mod__S_073handles {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_073handles");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "handles";
$self->_MATCHIFYr($S, "trait_mod__S_073handles", do {
my $C = $C;
if (($C) = ($C->_EXACT("handles"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token nullterm {
sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm', $retree) }
sub nullterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nullterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nullterm", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token nulltermish {
sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish', $retree) }
sub nulltermish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nulltermish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nulltermish", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_0') {
$C->deb("Fate passed to nulltermish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT nulltermish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM nulltermish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'nulltermish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("nulltermish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C;
$C->{'PRE'}  = delete $M->{'term'}->{'PRE'};
$C->{'POST'} = delete $M->{'term'}->{'POST'};
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;

local $::SCOPE = "";local $::MULTINESS = "";local $::OFTYPE;local $::VAR;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'POST'} = [];
$C->{'PRE'} = [];
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
$C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'termish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
my $p = $M->{'PRE'};
my @p = @$p;
$p[-1]->dump;
$p[-1]->{'O'}->{'term'} and $M->{'term'} = pop @$p ;
})
}))) {
$C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'term'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Prefix requires an argument"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL eq '$' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_PLUSg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
})))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
$M->{'POST'} = [] }, $C)
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_STARg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
})))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$::VAR = 0}, $C)
};
@gather;
}
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
})
} else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
$self->check_variable($::VAR) if $::VAR;
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }

});
}
;
## token term:fatarrow           { <fatarrow> }
sub term__S_074fatarrow__PEEK { $_[0]->_AUTOLEXpeek('term__S_074fatarrow', $retree) }
sub term__S_074fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_074fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fatarrow";
$self->_MATCHIFYr($S, "term__S_074fatarrow", $C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
}));
}
;
## token term:variable           { <variable> { $*VAR = $<variable> } }
sub term__S_075variable__PEEK { $_[0]->_AUTOLEXpeek('term__S_075variable', $retree) }
sub term__S_075variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_075variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "term__S_075variable", do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'} }, $C)
} else { () }

});
}
;
## token term:package_declarator { <package_declarator> }
sub term__S_076package_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_076package_declarator', $retree) }
sub term__S_076package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_076package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "term__S_076package_declarator", $C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}));
}
;
## token term:scope_declarator   { <scope_declarator> }
sub term__S_077scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_077scope_declarator', $retree) }
sub term__S_077scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_077scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "term__S_077scope_declarator", $C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
}));
}
;
## token term:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }
sub term__S_078multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_078multi_declarator', $retree) }
sub term__S_078multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_078multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "term__S_078multi_declarator", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_078multi_declarator_0') {
$C->deb("Fate passed to term__S_078multi_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_078multi_declarator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_078multi_declarator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_078multi_declarator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_078multi_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("multi")
},
sub {
my $C=shift;
$C->_EXACT("proto")
},
sub {
my $C=shift;
$C->_EXACT("only")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
})
} else { () }

});
}
;
## token term:routine_declarator { <routine_declarator> }
sub term__S_079routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_079routine_declarator', $retree) }
sub term__S_079routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_079routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "term__S_079routine_declarator", $C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
}));
}
;
## token term:regex_declarator   { <regex_declarator> }
sub term__S_080regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_080regex_declarator', $retree) }
sub term__S_080regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_080regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "term__S_080regex_declarator", $C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}));
}
;
## token term:type_declarator    { <type_declarator> }
sub term__S_081type_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_081type_declarator', $retree) }
sub term__S_081type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_081type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "term__S_081type_declarator", $C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
}));
}
;
## token term:circumfix          { <circumfix> }
sub term__S_082circumfix__PEEK { $_[0]->_AUTOLEXpeek('term__S_082circumfix', $retree) }
sub term__S_082circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_082circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "term__S_082circumfix", $C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}));
}
;
## token term:dotty              { <dotty> }
sub term__S_083dotty__PEEK { $_[0]->_AUTOLEXpeek('term__S_083dotty', $retree) }
sub term__S_083dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_083dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "term__S_083dotty", $C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}));
}
;
## token term:value              { <value> }
sub term__S_084value__PEEK { $_[0]->_AUTOLEXpeek('term__S_084value', $retree) }
sub term__S_084value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_084value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "term__S_084value", $C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
}));
}
;
## token term:capterm            { <capterm> }
sub term__S_085capterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_085capterm', $retree) }
sub term__S_085capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_085capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "capterm";
$self->_MATCHIFYr($S, "term__S_085capterm", $C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
}));
}
;
## token term:sigterm            { <sigterm> }
sub term__S_086sigterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_086sigterm', $retree) }
sub term__S_086sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_086sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigterm";
$self->_MATCHIFYr($S, "term__S_086sigterm", $C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
}));
}
;
## token term:statement_prefix   { <statement_prefix> }
sub term__S_087statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('term__S_087statement_prefix', $retree) }
sub term__S_087statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_087statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "term__S_087statement_prefix", $C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
}));
}
;
## token term:colonpair          { [ <colonpair> <.ws> ]+ }
sub term__S_088colonpair__PEEK { $_[0]->_AUTOLEXpeek('term__S_088colonpair', $retree) }
sub term__S_088colonpair {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_088colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{sym} = "colonpair";
$self->_MATCHIFYr($S, "term__S_088colonpair", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token fatarrow {
sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow', $retree) }
sub fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fatarrow", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=\>/))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }

});
}
;
## token coloncircumfix ($front) {
sub coloncircumfix__PEEK { $_[0]->_AUTOLEXpeek('coloncircumfix', $retree) }
sub coloncircumfix {
no warnings 'recursion';
my $self = shift;

die 'Required argument front omitted' unless @_;
my $front = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE coloncircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "coloncircumfix", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'coloncircumfix_0') {
$C->deb("Fate passed to coloncircumfix_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT coloncircumfix_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM coloncircumfix_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'coloncircumfix_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("coloncircumfix_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\>"))
and ($C) = ($C->worry("Pair with <> really means a Nil value, not null string; use :$front" . "('') to represent the null string,\n  or :$front" . "() to represent Nil more accurately"))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token colonpair {
sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair', $retree) }
sub colonpair {
no warnings 'recursion';
my $self = shift;

my $key;my $value;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "colonpair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_0') {
$C->deb("Fate passed to colonpair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT colonpair_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM colonpair_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'colonpair_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("colonpair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed False pair; expected identifier"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Extra argument not allowed; pair already has False argument"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Extra argument not allowed; pair already has argument of " . $M->{'num'}->Str)
})
and ($C) = ($C->circumfix)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix($key)
}))) {
scalar(do {
my $M = $C;
$value = $M->{'coloncircumfix'}}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix('')
}))) {
scalar(do {
my $M = $C;
$key = "";
$value = $M->{'coloncircumfix'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['var'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_1') {
$C->deb("Fate passed to colonpair_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT colonpair_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM colonpair_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'colonpair_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("colonpair_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
$C->_EXACT("\>")
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};

})
}))) {
scalar(do {
my $M = $C;
$key = $M->{'var'}->{'desigilname'}->Str;
$value = $M->{'var'};
$C->check_variable($value);
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_SUBSUMEblock('k', sub {
my $C = shift;
$key}))) {
$C->_SUBSUMEblock('v', sub {
my $C = shift;
$value})
} else { () }

});
}
;
## token special_variable:sym<$¢> { <sym> }
sub special_variable__S_089Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_089Dollar_a2_', $retree) }
sub special_variable__S_089Dollar_a2_ {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_089Dollar_a2_");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$¢";
$self->_MATCHIFYr($S, "special_variable__S_089Dollar_a2_", $C->_EXACT("\$¢"));
}
;
## token special_variable:sym<$!> { <sym> <!before \w> }
sub special_variable__S_090DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_090DollarBang', $retree) }
sub special_variable__S_090DollarBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_090DollarBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!";
$self->_MATCHIFYr($S, "special_variable__S_090DollarBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$!{ }> {
sub special_variable__S_091DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_091DollarBangCur_Ly', $retree) }
sub special_variable__S_091DollarBangCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_091DollarBangCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_091DollarBangCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_091DollarBangCur_Ly_0') {
$C->deb("Fate passed to special_variable__S_091DollarBangCur_Ly_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_091DollarBangCur_Ly_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_091DollarBangCur_Ly_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_091DollarBangCur_Ly_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_091DollarBangCur_Ly_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'special_variable', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
my $all = substr($self->orig, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'});
my ($inside)= $all =~ m!^...\s*(.*?)\s*.$!;
$C->obs("Perl 5's $all construct", "a smartmatch like \$! ~~ $inside" );
}, $C)
} else { () }

});
}
;
## token special_variable:sym<$/> {
sub special_variable__S_092DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_092DollarSlash', $retree) }
sub special_variable__S_092DollarSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_092DollarSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\/";
$self->_MATCHIFYr($S, "special_variable__S_092DollarSlash", do {
if (my ($C) = ($C->_EXACT("\$\/"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[=]/)
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
"the filehandle's :irs attribute"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token special_variable:sym<$~> {
sub special_variable__S_093DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_093DollarTilde', $retree) }
sub special_variable__S_093DollarTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_093DollarTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\~";
$self->_MATCHIFYr($S, "special_variable__S_093DollarTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\~"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_093DollarTilde_0') {
$C->deb("Fate passed to special_variable__S_093DollarTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_093DollarTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_093DollarTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_093DollarTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_093DollarTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$~ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$`> {
sub special_variable__S_094DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_094DollarGrave', $retree) }
sub special_variable__S_094DollarGrave {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_094DollarGrave");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\`";
$self->_MATCHIFYr($S, "special_variable__S_094DollarGrave", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_094DollarGrave_0') {
$C->deb("Fate passed to special_variable__S_094DollarGrave_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_094DollarGrave_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_094DollarGrave_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_094DollarGrave_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_094DollarGrave_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$` variable', 'explicit pattern before <('))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$@> {
sub special_variable__S_095DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_095DollarAt', $retree) }
sub special_variable__S_095DollarAt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_095DollarAt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\@";
$self->_MATCHIFYr($S, "special_variable__S_095DollarAt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\@"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$@ variable as eval error', '$!'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$#> {
sub special_variable__S_096DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_096DollarSharp', $retree) }
sub special_variable__S_096DollarSharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_096DollarSharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\#";
$self->_MATCHIFYr($S, "special_variable__S_096DollarSharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\#"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$#" . $M->{0}->Str . " variable", '@' . $M->{0}->Str . '.end')
})) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('$# variable', '.fmt'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$$> {
sub special_variable__S_097DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_097DollarDollar', $retree) }
sub special_variable__S_097DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_097DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "special_variable__S_097DollarDollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\$"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_097DollarDollar_0') {
$C->deb("Fate passed to special_variable__S_097DollarDollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_097DollarDollar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_097DollarDollar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_097DollarDollar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_097DollarDollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$$ variable', '$*PID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$%> {
sub special_variable__S_098DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_098DollarPercent', $retree) }
sub special_variable__S_098DollarPercent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_098DollarPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\%";
$self->_MATCHIFYr($S, "special_variable__S_098DollarPercent", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\%"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->sigil)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$% variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$^X> {
sub special_variable__S_099DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_099DollarCaretX', $retree) }
sub special_variable__S_099DollarCaretX {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_099DollarCaretX");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^X";
$self->_MATCHIFYr($S, "special_variable__S_099DollarCaretX", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\^"))
and ($C) = ($C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))
and ($C) = ($C->_PATTERN(qr/\G\W/))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}->Str, $M->{'letter'}->Str)
})) {
$C
} else { () }

});
}
;
## token special_variable:sym<$^> {
sub special_variable__S_100DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_100DollarCaret', $retree) }
sub special_variable__S_100DollarCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_100DollarCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^";
$self->_MATCHIFYr($S, "special_variable__S_100DollarCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_100DollarCaret_0') {
$C->deb("Fate passed to special_variable__S_100DollarCaret_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_100DollarCaret_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_100DollarCaret_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_100DollarCaret_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_100DollarCaret_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$^ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$&> {
sub special_variable__S_101DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_101DollarAmp', $retree) }
sub special_variable__S_101DollarAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_101DollarAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\&";
$self->_MATCHIFYr($S, "special_variable__S_101DollarAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\&"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_101DollarAmp_0') {
$C->deb("Fate passed to special_variable__S_101DollarAmp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_101DollarAmp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_101DollarAmp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_101DollarAmp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_101DollarAmp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$& variable', '$/ or $()'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$*> {
sub special_variable__S_102DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_102DollarStar', $retree) }
sub special_variable__S_102DollarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_102DollarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\*";
$self->_MATCHIFYr($S, "special_variable__S_102DollarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_102DollarStar_0') {
$C->deb("Fate passed to special_variable__S_102DollarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_102DollarStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_102DollarStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_102DollarStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_102DollarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$* variable', '^^ and $$'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$)> {
sub special_variable__S_103DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_103DollarThesis', $retree) }
sub special_variable__S_103DollarThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_103DollarThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\)";
$self->_MATCHIFYr($S, "special_variable__S_103DollarThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\)"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL ne ')' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_103DollarThesis_0') {
$C->deb("Fate passed to special_variable__S_103DollarThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_103DollarThesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_103DollarThesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_103DollarThesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_103DollarThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$) variable', '$*EGID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$-> {
sub special_variable__S_104DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_104DollarMinus', $retree) }
sub special_variable__S_104DollarMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_104DollarMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-";
$self->_MATCHIFYr($S, "special_variable__S_104DollarMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_104DollarMinus_0') {
$C->deb("Fate passed to special_variable__S_104DollarMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_104DollarMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_104DollarMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_104DollarMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_104DollarMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$- variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$=> {
sub special_variable__S_105DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_105DollarEqual', $retree) }
sub special_variable__S_105DollarEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_105DollarEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\=";
$self->_MATCHIFYr($S, "special_variable__S_105DollarEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\="))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_105DollarEqual_0') {
$C->deb("Fate passed to special_variable__S_105DollarEqual_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_105DollarEqual_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_105DollarEqual_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_105DollarEqual_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_105DollarEqual_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$= variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+> {
sub special_variable__S_106AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_106AtPlus', $retree) }
sub special_variable__S_106AtPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_106AtPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+";
$self->_MATCHIFYr($S, "special_variable__S_106AtPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_106AtPlus_0') {
$C->deb("Fate passed to special_variable__S_106AtPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_106AtPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_106AtPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_106AtPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_106AtPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%+> {
sub special_variable__S_107PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_107PercentPlus', $retree) }
sub special_variable__S_107PercentPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_107PercentPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\+";
$self->_MATCHIFYr($S, "special_variable__S_107PercentPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_107PercentPlus_0') {
$C->deb("Fate passed to special_variable__S_107PercentPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_107PercentPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_107PercentPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_107PercentPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_107PercentPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$+[ ]> {
sub special_variable__S_108DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_108DollarPlusBra_Ket', $retree) }
sub special_variable__S_108DollarPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_108DollarPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_108DollarPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+[ ]> {
sub special_variable__S_109AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_109AtPlusBra_Ket', $retree) }
sub special_variable__S_109AtPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_109AtPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_109AtPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@+{ }> {
sub special_variable__S_110AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_110AtPlusCur_Ly', $retree) }
sub special_variable__S_110AtPlusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_110AtPlusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_110AtPlusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\{"))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@-> {
sub special_variable__S_111AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_111AtMinus', $retree) }
sub special_variable__S_111AtMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_111AtMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-";
$self->_MATCHIFYr($S, "special_variable__S_111AtMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_111AtMinus_0') {
$C->deb("Fate passed to special_variable__S_111AtMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_111AtMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_111AtMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_111AtMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_111AtMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%-> {
sub special_variable__S_112PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_112PercentMinus', $retree) }
sub special_variable__S_112PercentMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_112PercentMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-";
$self->_MATCHIFYr($S, "special_variable__S_112PercentMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_112PercentMinus_0') {
$C->deb("Fate passed to special_variable__S_112PercentMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_112PercentMinus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_112PercentMinus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_112PercentMinus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_112PercentMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$-[ ]> {
sub special_variable__S_113DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_113DollarMinusBra_Ket', $retree) }
sub special_variable__S_113DollarMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_113DollarMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_113DollarMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<@-[ ]> {
sub special_variable__S_114AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_114AtMinusBra_Ket', $retree) }
sub special_variable__S_114AtMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_114AtMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_114AtMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<%-{ }> {
sub special_variable__S_115PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_115PercentMinusCur_Ly', $retree) }
sub special_variable__S_115PercentMinusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_115PercentMinusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_115PercentMinusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\{"))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$+> {
sub special_variable__S_116DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_116DollarPlus', $retree) }
sub special_variable__S_116DollarPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_116DollarPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+";
$self->_MATCHIFYr($S, "special_variable__S_116DollarPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_116DollarPlus_0') {
$C->deb("Fate passed to special_variable__S_116DollarPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_116DollarPlus_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_116DollarPlus_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_116DollarPlus_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_116DollarPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$+ variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<${^ }> {
sub special_variable__S_117DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_117DollarCurCaret_Ly', $retree) }
sub special_variable__S_117DollarCurCaret_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_117DollarCurCaret_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\^\ \}";
$self->_MATCHIFYr($S, "special_variable__S_117DollarCurCaret_Ly", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\{\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
and ($C) = ($C->_EXACT("\}"))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '{^' . $M->{'text'}->Str . '}', $M->{'sigil'}->Str, $M->{'text'}->Str)
})) {
$C
} else { () }

});
}
;
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
no warnings 'recursion';
my $self = shift;
die 'Required argument var omitted' unless @_;
my $var = @_ ? shift() : undef;
die 'Required argument sigil omitted' unless @_;
my $sigil = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         {
$repl = '$/' }
;
when ('PREMATCH')      {
$repl = 'an explicit pattern before <(' }
;
when ('POSTMATCH')     {
$repl = 'an explicit pattern after )>' }
;
when ('ENCODING')      {
$repl = '$?ENCODING' }
;
when ('UNICODE')       {
$repl = '$?UNICODE' }
;
when ('TAINT')         {
$repl = '$*TAINT' }
;
when ('OPEN')          {
$repl = 'filehandle introspection' }
;
when ('N')             {
$repl = '$-1' }
;
when ('L')             {
$repl = 'Form module' }
;
when ('A')             {
$repl = 'Form module' }
;
when ('E')             {
$repl = '$!.extended_os_error' }
;
when ('C')             {
$repl = 'COMPILING namespace' }
;
when ('D')             {
$repl = '$*DEBUGGING' }
;
when ('F')             {
$repl = '$*SYSTEM_FD_MAX' }
;
when ('H')             {
$repl = '$?FOO variables' }
;
when ('I')             {
$repl = '$*INPLACE' }
;
when ('O')             {
$repl = '$?OS or $*OS' }
;
when ('P')             {
$repl = 'whatever debugger Perl 6 comes with' }
;
when ('R')             {
$repl = 'an explicit result variable' }
;
when ('S')             {
$repl = 'the context function' }
;
when ('T')             {
$repl = '$*BASETIME' }
;
when ('V')             {
$repl = '$*PERL_VERSION' }
;
when ('W')             {
$repl = '$*WARNING' }
;
when ('X')             {
$repl = '$*EXECUTABLE_NAME' }
;
default               {
$repl = "a global form such as $sigil*$name" }
;
}
}
;
when ('%') {
given ($name) {
when ('H')             {
$repl = '$?FOO variables' }
;
default               {
$repl = "a global form such as $sigil*$name" }
;
}
}
;
default {
$repl = "a global form such as $sigil*$name" }
;
};
return $self->obs("$var variable", $repl);
};
## token special_variable:sym<::{ }> {
sub special_variable__S_118ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_118ColonColonCur_Ly', $retree) }
sub special_variable__S_118ColonColonCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_118ColonColonCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_118ColonColonCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## regex special_variable:sym<${ }> {
sub special_variable__S_119DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_119DollarCur_Ly', $retree) }
sub special_variable__S_119DollarCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_119DollarCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\ \}";
$self->_MATCHIFY($S, "special_variable__S_119DollarCur_Ly", LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
my $sigil = $M->{'sigil'}->Str;
my $text = $M->{'text'}->Str;
my $bad = $sigil . '{' . $text . '}';
$text = $text - 1 if $text =~ /^\d+$/;
if ($text !~ /^(\w|\:)+$/) {
return () if $::QSIGIL;
$C->obs($bad, $sigil . '(' . $text . ')');
}
elsif ($::QSIGIL) {
$C->obs($bad, '{' . $sigil . $text . '}')}
else {
$C->obs($bad, $sigil . $text)};
}, $C)
} else { () }
},
$C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
} else { () }
},
$C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
})));
}
;
## token special_variable:sym<$[> {
sub special_variable__S_120DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_120DollarBra', $retree) }
sub special_variable__S_120DollarBra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_120DollarBra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\[";
$self->_MATCHIFYr($S, "special_variable__S_120DollarBra", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\["))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_120DollarBra_0') {
$C->deb("Fate passed to special_variable__S_120DollarBra_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_120DollarBra_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_120DollarBra_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_120DollarBra_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_120DollarBra_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$[ variable', 'user-defined array indices'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$]> {
sub special_variable__S_121DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_121DollarKet', $retree) }
sub special_variable__S_121DollarKet {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_121DollarKet");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\]";
$self->_MATCHIFYr($S, "special_variable__S_121DollarKet", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\]"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_121DollarKet_0') {
$C->deb("Fate passed to special_variable__S_121DollarKet_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_121DollarKet_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_121DollarKet_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_121DollarKet_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_121DollarKet_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$] variable', '$*PERL_VERSION'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$\\> {
sub special_variable__S_122DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_122DollarBack', $retree) }
sub special_variable__S_122DollarBack {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_122DollarBack");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\\";
$self->_MATCHIFYr($S, "special_variable__S_122DollarBack", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\\"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_122DollarBack_0') {
$C->deb("Fate passed to special_variable__S_122DollarBack_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_122DollarBack_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_122DollarBack_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_122DollarBack_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_122DollarBack_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$\\ variable', "the filehandle's :ors attribute"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$|> {
sub special_variable__S_123DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_123DollarVert', $retree) }
sub special_variable__S_123DollarVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_123DollarVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\|";
$self->_MATCHIFYr($S, "special_variable__S_123DollarVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\|"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_123DollarVert_0') {
$C->deb("Fate passed to special_variable__S_123DollarVert_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_123DollarVert_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_123DollarVert_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_123DollarVert_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_123DollarVert_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$| variable', ':autoflush on open'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$:> {
sub special_variable__S_124DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_124DollarColon', $retree) }
sub special_variable__S_124DollarColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_124DollarColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\:";
$self->_MATCHIFYr($S, "special_variable__S_124DollarColon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$: variable', 'Form module'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$;> {
sub special_variable__S_125DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_125DollarSemi', $retree) }
sub special_variable__S_125DollarSemi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_125DollarSemi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\;";
$self->_MATCHIFYr($S, "special_variable__S_125DollarSemi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\;"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_125DollarSemi_0') {
$C->deb("Fate passed to special_variable__S_125DollarSemi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_125DollarSemi_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_125DollarSemi_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_125DollarSemi_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_125DollarSemi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$; variable', 'real multidimensional hashes'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$'> { #'
sub special_variable__S_126DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_126DollarSingle', $retree) }
sub special_variable__S_126DollarSingle {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_126DollarSingle");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\'";
$self->_MATCHIFYr($S, "special_variable__S_126DollarSingle", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\'"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_126DollarSingle_0') {
$C->deb("Fate passed to special_variable__S_126DollarSingle_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_126DollarSingle_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_126DollarSingle_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_126DollarSingle_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_126DollarSingle_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$' . "'" . 'variable', "explicit pattern after )\x{3E}"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$"> {
sub special_variable__S_127DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_127DollarDouble', $retree) }
sub special_variable__S_127DollarDouble {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_127DollarDouble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\"";
$self->_MATCHIFYr($S, "special_variable__S_127DollarDouble", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\""))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_127DollarDouble_0') {
$C->deb("Fate passed to special_variable__S_127DollarDouble_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_127DollarDouble_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_127DollarDouble_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_127DollarDouble_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_127DollarDouble_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$" variable', '.join() method'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$,> {
sub special_variable__S_128DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128DollarComma', $retree) }
sub special_variable__S_128DollarComma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_128DollarComma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\,";
$self->_MATCHIFYr($S, "special_variable__S_128DollarComma", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\,"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_128DollarComma_0') {
$C->deb("Fate passed to special_variable__S_128DollarComma_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_128DollarComma_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_128DollarComma_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_128DollarComma_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_128DollarComma_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$, variable', ".join() method"))) {
$C
} else { () }

});
}
;
## token special_variable:sym['$<'] {
sub special_variable__S_129DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarLt', $retree) }
sub special_variable__S_129DollarLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_129DollarLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\<";
$self->_MATCHIFYr($S, "special_variable__S_129DollarLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\<"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+[=,;?:!)\]}]/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S*+\>/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$< variable', '$*UID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym«\$>» {
sub special_variable__S_130DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarGt', $retree) }
sub special_variable__S_130DollarGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_130DollarGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\>";
$self->_MATCHIFYr($S, "special_variable__S_130DollarGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\>"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_130DollarGt_0') {
$C->deb("Fate passed to special_variable__S_130DollarGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_130DollarGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_130DollarGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_130DollarGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_130DollarGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$> variable', '$*EUID'))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$.> {
sub special_variable__S_131DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarDot', $retree) }
sub special_variable__S_131DollarDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_131DollarDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\.";
$self->_MATCHIFYr($S, "special_variable__S_131DollarDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\."))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_131DollarDot_0') {
$C->deb("Fate passed to special_variable__S_131DollarDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_131DollarDot_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_131DollarDot_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_131DollarDot_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_131DollarDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$. variable', "the filehandle's .line method"))) {
$C
} else { () }

});
}
;
## token special_variable:sym<$?> {
sub special_variable__S_132DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarQuestion', $retree) }
sub special_variable__S_132DollarQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_132DollarQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\?";
$self->_MATCHIFYr($S, "special_variable__S_132DollarQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\?"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_132DollarQuestion_0') {
$C->deb("Fate passed to special_variable__S_132DollarQuestion_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT special_variable__S_132DollarQuestion_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM special_variable__S_132DollarQuestion_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'special_variable__S_132DollarQuestion_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("special_variable__S_132DollarQuestion_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$? variable as child error', '$!'))) {
$C
} else { () }

});
}
;
## token desigilname {
sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname', $retree) }
sub desigilname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE desigilname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "desigilname", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_0') {
$C->deb("Fate passed to desigilname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT desigilname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM desigilname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'desigilname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("desigilname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['VAR','variable'], sub {
my $C = shift;
$C->variable
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Cannot declare an indirect variable name"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'};
$self->check_variable($::VAR);
}, $C)
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token variable {
sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable', $retree) }
sub variable {
no warnings 'recursion';
my $self = shift;

local $::IN_META = '';my $sigil = '';my $twigil = '';my $name;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C;
$sigil = $M->{'sigil'}->Str;
$::LEFTSIGIL ||= $sigil;
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_0') {
$C->deb("Fate passed to variable_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_1') {
$C->deb("Fate passed to variable_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'sublongname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'infix noun', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:"))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_2') {
$C->deb("Fate passed to variable_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'desigilname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['special_variable'], sub {
my $C = shift;
$C->special_variable
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_SUBSUMEr(['index'], sub {
my $C = shift;
$C->decint
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Cannot declare a numeric variable"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Cannot declare a match variable"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))
and ($C) = ($C->panic("Cannot declare a contextualizer"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
if ($::QSIGIL) {
return ()}
else {
$C->sorry("Non-declarative sigil is missing its name")}}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'twigil'};
$twigil = $t->[0]->Str if @$t;
}, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$twigil eq '.' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_3') {
$C->deb("Fate passed to variable_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT variable_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM variable_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'variable_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("variable_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token defterm {     # XXX this is probably too general
sub defterm__PEEK { $_[0]->_AUTOLEXpeek('defterm', $retree) }
sub defterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE defterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "defterm", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'defterm_0') {
$C->deb("Fate passed to defterm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT defterm_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM defterm_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'defterm_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("defterm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
$C->add_categorical(substr($self->orig, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'}))}, $C)
} else { () }
},
sub {
my $C=shift;
scalar(do {
my $M = $C;
$C->add_name($M->{'identifier'}->Str)}, $C)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token deflongname {
sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname', $retree) }
sub deflongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE deflongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "deflongname", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_0') {
$C->deb("Fate passed to deflongname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT deflongname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM deflongname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'deflongname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("deflongname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
$C->add_categorical(substr($self->orig, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'})) if $::IN_DECL}, $C)
} else { () }
},
sub {
my $C=shift;
scalar(do {
my $M = $C;
$C->add_routine($M->{'name'}->Str) if $::IN_DECL}, $C)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token subshortname {
sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname', $retree) }
sub subshortname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE subshortname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "subshortname", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_0') {
$C->deb("Fate passed to subshortname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT subshortname_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM subshortname_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'subshortname_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("subshortname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token sublongname {
sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname', $retree) }
sub sublongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sublongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];
$self->_MATCHIFYr($S, "sublongname", do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
})
} else { () }

});
}
;
## token value:quote   { <quote> }
sub value__S_133quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_133quote', $retree) }
sub value__S_133quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_133quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "value__S_133quote", $C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}));
}
;
## token value:number  { <number> }
sub value__S_134number__PEEK { $_[0]->_AUTOLEXpeek('value__S_134number', $retree) }
sub value__S_134number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_134number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "value__S_134number", $C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
}));
}
;
## token value:version { <version> }
sub value__S_135version__PEEK { $_[0]->_AUTOLEXpeek('value__S_135version', $retree) }
sub value__S_135version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_135version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "value__S_135version", $C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}));
}
;
## token typename {
sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename', $retree) }
sub typename {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE typename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'accept'} = [];
$C->{'param'} = [];
$C->{'typename'} = [];
$C->{'whence'} = [];
$self->_MATCHIFYr($S, "typename", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_0') {
$C->deb("Fate passed to typename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT typename_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM typename_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'typename_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("typename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2))}
else {
$C->is_name($longname)
};
})
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['whence'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['accept'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("of"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token number {
sub number__PEEK { $_[0]->_AUTOLEXpeek('number', $retree) }
sub number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "number", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'number_0') {
$C->deb("Fate passed to number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT number_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM number_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'number_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\GNaN\b/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\GInf\b/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token numeric:rational { <[+\-]>?<nu=.integer>'/'<de=.integer> }
sub numeric__S_136rational__PEEK { $_[0]->_AUTOLEXpeek('numeric__S_136rational', $retree) }
sub numeric__S_136rational {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE numeric__S_136rational");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rational";
$self->_MATCHIFYr($S, "numeric__S_136rational", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))
and ($C) = ($C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))
and ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
})
} else { () }

});
}
;
## token numeric:complex { [<[+\-]>?<re=.number>]? <[+\-]><im=.number>'\\'?'i' }
sub numeric__S_137complex__PEEK { $_[0]->_AUTOLEXpeek('numeric__S_137complex', $retree) }
sub numeric__S_137complex {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE numeric__S_137complex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'re'} = [];
$C->{sym} = "complex";
$self->_MATCHIFYr($S, "numeric__S_137complex", do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->number
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G[+\-]/))
and ($C) = ($C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->number
}))) {
$C->_PATTERN(qr/\G\\?+i/)
} else { () }

});
}
;
## token numeric:number { <[+\-]>?<number> }
sub numeric__S_138number__PEEK { $_[0]->_AUTOLEXpeek('numeric__S_138number', $retree) }
sub numeric__S_138number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE numeric__S_138number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "numeric__S_138number", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
} else { () }

});
}
;
## token sibble ($l, $lang2) {
sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble', $retree) }
sub sibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
die 'Required argument lang2 omitted' unless @_;
my $lang2 = @_ ? shift() : undef;
my ($lang, $start, $stop);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\{\(\<]/)
}))
and ($C) = ($C->obs('brackets around replacement', 'assignment syntax'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['panic'], sub {
my $C = shift;
$C->panic("Missing assignment operator")
})
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' || $M->{'infixish'}->{'infix_postfix_meta_operator'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed assignment operator"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right','EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token tribble ($l, $lang2 = $l) {
sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble', $retree) }
sub tribble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang2 = @_ ? shift() : $l;
my ($lang, $start, $stop);local $::CCSTATE = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE tribble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "tribble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
$::CCSTATE = ''}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quasiquibble ($l) {
sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble', $retree) }
sub quasiquibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
local %::LANG = %::LANG;my ($lang, $start, $stop);local $::QUASIMODO = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quasiquibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quasiquibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
$::LANG{'MAIN'} = $lang;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start eq '{' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

}
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quote:sym<//>   {
sub quote__S_139SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_139SlashSlash', $retree) }
sub quote__S_139SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_139SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "quote__S_139SlashSlash", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\/\s*+\//))
and ($C) = ($C->sorry("Null regex not allowed"))) {
$C
} else { () }

});
}
;
## token quote:sym</ />   {
sub quote__S_140Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_140Slash_Slash', $retree) }
sub quote__S_140Slash_Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_140Slash_Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\ \/";
$self->_MATCHIFYr($S, "quote__S_140Slash_Slash", do {
my $C = $C;
if (($C) = ($C->_EXACT("\/"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\/")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find final '/'"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
})
} else { () }

});
}
;
## token quote:qq {
sub quote__S_141qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_141qq', $retree) }
sub quote__S_141qq {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_141qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "quote__S_141qq", do {
my $C = $C;
if (($C) = ($C->_EXACT("qq"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_141qq_0') {
$C->deb("Fate passed to quote__S_141qq_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_141qq_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_141qq_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_141qq_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_141qq_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak(($qm => 1)))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote:q {
sub quote__S_142q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_142q', $retree) }
sub quote__S_142q {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_142q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "q";
$self->_MATCHIFYr($S, "quote__S_142q", do {
my $C = $C;
if (($C) = ($C->_EXACT("q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_142q_0') {
$C->deb("Fate passed to quote__S_142q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_142q_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_142q_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_142q_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_142q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak(($qm => 1)))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote:Q {
sub quote__S_143Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_143Q', $retree) }
sub quote__S_143Q {
no warnings 'recursion';
my $self = shift;

my $qm;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_143Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "quote__S_143Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_143Q_0') {
$C->deb("Fate passed to quote__S_143Q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quote__S_143Q_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quote__S_143Q_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'quote__S_143Q_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quote__S_143Q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak(($qm => 1)))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quote_mod:w  { <sym> }
sub quote_mod__S_144w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_144w', $retree) }
sub quote_mod__S_144w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_144w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "quote_mod__S_144w", $C->_EXACT("w"));
}
;
## token quote_mod:ww { <sym> }
sub quote_mod__S_145ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_145ww', $retree) }
sub quote_mod__S_145ww {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_145ww");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ww";
$self->_MATCHIFYr($S, "quote_mod__S_145ww", $C->_EXACT("ww"));
}
;
## token quote_mod:p  { <sym> }
sub quote_mod__S_146p__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_146p', $retree) }
sub quote_mod__S_146p {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_146p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p";
$self->_MATCHIFYr($S, "quote_mod__S_146p", $C->_EXACT("p"));
}
;
## token quote_mod:x  { <sym> }
sub quote_mod__S_147x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_147x', $retree) }
sub quote_mod__S_147x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_147x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "quote_mod__S_147x", $C->_EXACT("x"));
}
;
## token quote_mod:to { <sym> }
sub quote_mod__S_148to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_148to', $retree) }
sub quote_mod__S_148to {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_148to");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "to";
$self->_MATCHIFYr($S, "quote_mod__S_148to", $C->_EXACT("to"));
}
;
## token quote_mod:s  { <sym> }
sub quote_mod__S_149s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_149s', $retree) }
sub quote_mod__S_149s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_149s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote_mod__S_149s", $C->_EXACT("s"));
}
;
## token quote_mod:a  { <sym> }
sub quote_mod__S_150a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_150a', $retree) }
sub quote_mod__S_150a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_150a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "quote_mod__S_150a", $C->_EXACT("a"));
}
;
## token quote_mod:h  { <sym> }
sub quote_mod__S_151h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_151h', $retree) }
sub quote_mod__S_151h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_151h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "quote_mod__S_151h", $C->_EXACT("h"));
}
;
## token quote_mod:f  { <sym> }
sub quote_mod__S_152f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_152f', $retree) }
sub quote_mod__S_152f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_152f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "quote_mod__S_152f", $C->_EXACT("f"));
}
;
## token quote_mod:c  { <sym> }
sub quote_mod__S_153c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_153c', $retree) }
sub quote_mod__S_153c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_153c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "quote_mod__S_153c", $C->_EXACT("c"));
}
;
## token quote_mod:b  { <sym> }
sub quote_mod__S_154b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_154b', $retree) }
sub quote_mod__S_154b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_154b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "quote_mod__S_154b", $C->_EXACT("b"));
}
;
## token quote:rx {
sub quote__S_155rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_155rx', $retree) }
sub quote__S_155rx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_155rx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rx";
$self->_MATCHIFYr($S, "quote__S_155rx", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grx\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:m  {
sub quote__S_156m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_156m', $retree) }
sub quote__S_156m {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_156m");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "m";
$self->_MATCHIFYr($S, "quote__S_156m", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gm\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:ms {
sub quote__S_157ms__PEEK { $_[0]->_AUTOLEXpeek('quote__S_157ms', $retree) }
sub quote__S_157ms {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_157ms");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ms";
$self->_MATCHIFYr($S, "quote__S_157ms", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gms\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:s {
sub quote__S_158s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_158s', $retree) }
sub quote__S_158s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_158s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote__S_158s", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gs\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:ss {
sub quote__S_159ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_159ss', $retree) }
sub quote__S_159ss {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_159ss");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ss";
$self->_MATCHIFYr($S, "quote__S_159ss", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gss\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quote:tr {
sub quote__S_160tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_160tr', $retree) }
sub quote__S_160tr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_160tr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "tr";
$self->_MATCHIFYr($S, "quote__S_160tr", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtr\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_tr_mods)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token old_rx_mods {
sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods', $retree) }
sub old_rx_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_rx_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_rx_mods", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))) {
scalar(do {
my $M = $C;
given ($M->{0}->Str) {
$_ =~ /i/ and $C->worryobs('/i',':i');
$_ =~ /g/ and $C->worryobs('/g',':g');
$_ =~ /m/ and $C->worryobs('/m','^^ and $$ anchors');
$_ =~ /s/ and $C->worryobs('/s','. or \N');
$_ =~ /x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ /c/ and $C->worryobs('/c',':c or :p');
$_ =~ /e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$_ =~ /r/ and $C->worryobs('/c','.subst');
$_ =~ /a/ and $C->worryobs('/a','Unicode');
$_ =~ /d/ and $C->worryobs('/d','Unicode');
$_ =~ /l/ and $C->worryobs('/l','Unicode');
$_ =~ /u/ and $C->worryobs('/l','normal regex');
$_ =~ /p/ and $C->worryobs('/c','substr or /$<PREMATCH>=[...] <(...)> $<POSTMATCH>=[...]');
$C->obs('suffix regex modifiers','prefix adverbs');
}
}, $C)
} else { () }

});
}
;
## token old_tr_mods {
sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods', $retree) }
sub old_tr_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_tr_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_tr_mods", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_ARRAY( qw< c d s ] > ))) { ($C) } else { () }
})

})
}))) {
scalar(do {
my $M = $C;
given ($M->{0}->Str) {
$_ =~ /c/ and $C->worryobs('/c',':c');
$_ =~ /d/ and $C->worryobs('/g',':d');
$_ =~ /s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
}
}, $C)
} else { () }

});
}
;
## token quote:quasi {
sub quote__S_161quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_161quasi', $retree) }
sub quote__S_161quasi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_161quasi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quasi";
$self->_MATCHIFYr($S, "quote__S_161quasi", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gquasi\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
})
} else { () }

});
}
;
## token capterm {
sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm', $retree) }
sub capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'capture'} = [];
$self->_MATCHIFYr($S, "capterm", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_0') {
$C->deb("Fate passed to capterm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT capterm_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM capterm_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'capterm_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("capterm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT("\)")
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("You can't backslash that"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## rule capture {
sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture', $retree) }
sub capture {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 1;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capture");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "capture", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token sigterm {
sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm', $retree) }
sub sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sigterm", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\:\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## rule param_sep {'' [','|':'|';'|';;'] }
sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep', $retree) }
sub param_sep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_sep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "param_sep", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_0') {
$C->deb("Fate passed to param_sep_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_sep_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_sep_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'param_sep_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("param_sep_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\:")
},
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\;\;")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token fakesignature() {
sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature', $retree) }
sub fakesignature {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fakesignature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fakesignature", do {
if (my ($C) = ($C->newlex)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
})
} else { () }

});
}
;
## token signature ($lexsig = 0) {
sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature', $retree) }
sub signature {
no warnings 'recursion';
my $self = shift;

my $lexsig = @_ ? shift() : 0;
local $::IN_DECL = 'sig';local $::zone = 'posreq';my $startpos = $self->{'_pos'};local $::MULTINESS = 'only';local $::SIGNUM = $lexsig;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE signature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'param_sep'} = [];
$C->{'parameter'} = [];
$C->{'type_constraint'} = [];
$self->_MATCHIFYr($S, "signature", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_0') {
$C->deb("Fate passed to signature_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\\|"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("\\| signature must contain one identifier"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_1') {
$C->deb("Fate passed to signature_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("\\| signature may contain only an identifier"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_REPSEPr( sub {
my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_2') {
$C->deb("Fate passed to signature_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_3') {
$C->deb("Fate passed to signature_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT signature_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM signature_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'signature_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("signature_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\s/)
},
sub {
my $C=shift;
$C->_EXACT("\;\;")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed parameter"))) { ($C) } else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\-\-\>"))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (do {
my $M = $C;
$C->panic("Typename " . $M->{'longname'}->[0]->Str . " must be predeclared")
})) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("No type found after -->"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
$::LEFTSIGIL = '@';
if ($lexsig) {
$::CURLEX->{'$?SIGNATURE'} .= '|' if $lexsig > 1;
$::CURLEX->{'$?SIGNATURE'} .= '(' . substr($self->orig, $startpos, $C->{'_pos'} - $startpos) . ')';
delete $::CURLEX->{'!NEEDSIG'};
};
}, $C)
} else { () }

});
}
;
## rule type_declarator:subset {
sub type_declarator__S_162subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_162subset', $retree) }
sub type_declarator__S_162subset {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'subset';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_162subset");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'longname'} = [];
$C->{'trait'} = [];
$C->{sym} = "subset";
$self->_MATCHIFYr($S, "type_declarator__S_162subset", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("subset"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_name($M->{'longname'}->[0]->Str)}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Malformed subset"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
});
}
;
## token type_declarator:enum {
sub type_declarator__S_163enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_163enum', $retree) }
sub type_declarator__S_163enum {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'enum';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_163enum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "enum";
$self->_MATCHIFYr($S, "type_declarator__S_163enum", do {
my $C = $C;
if (($C) = ($C->_EXACT("enum"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_163enum_0') {
$C->deb("Fate passed to type_declarator__S_163enum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator__S_163enum_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_declarator__S_163enum_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_163enum_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_declarator__S_163enum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','longname'], sub {
my $C = shift;
$C->longname
}))) {
scalar(do {
my $M = $C;
$C->add_name($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[<(«]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_enum($M->{'name'}, $M->{'term'}->Str)}, $C)
} else { () }

});
}
;
## token type_declarator:constant {
sub type_declarator__S_164constant__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_164constant', $retree) }
sub type_declarator__S_164constant {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'constant';local $::DECLARAND;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_164constant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "constant";
$self->_MATCHIFYr($S, "type_declarator__S_164constant", do {
my $C = $C;
if (($C) = ($C->_EXACT("constant"))
and ($C) = ($C->keyspace)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_164constant_0') {
$C->deb("Fate passed to type_declarator__S_164constant_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_declarator__S_164constant_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_declarator__S_164constant_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_164constant_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_declarator__S_164constant_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\\?+/))) {
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'variable'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->sorry("Missing symbol in constant declaration"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['initializer'], sub {
my $C = shift;
$C->initializer
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Missing initializer on constant declaration"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }

});
}
;
## token initializer:sym<=> {
sub initializer__S_165Equal__PEEK { $_[0]->_AUTOLEXpeek('initializer__S_165Equal', $retree) }
sub initializer__S_165Equal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE initializer__S_165Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "initializer__S_165Equal", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(($::LEFTSIGIL eq '$' ? (\%item_assignment) : (\%list_prefix) ))
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed initializer"))) { ($C) } else { () }

}
};
@gather;
});
}
;
## token initializer:sym<:=> {
sub initializer__S_166ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('initializer__S_166ColonEqual', $retree) }
sub initializer__S_166ColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE initializer__S_166ColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\=";
$self->_MATCHIFYr($S, "initializer__S_166ColonEqual", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\="))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed binding"))) { ($C) } else { () }

}
};
@gather;
});
}
;
## token initializer:sym<::=> {
sub initializer__S_167ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('initializer__S_167ColonColonEqual', $retree) }
sub initializer__S_167ColonColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE initializer__S_167ColonColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\=";
$self->_MATCHIFYr($S, "initializer__S_167ColonColonEqual", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:\="))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed binding"))) { ($C) } else { () }

}
};
@gather;
});
}
;
## token initializer:sym<.=> {
sub initializer__S_168DotEqual__PEEK { $_[0]->_AUTOLEXpeek('initializer__S_168DotEqual', $retree) }
sub initializer__S_168DotEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE initializer__S_168DotEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\=";
$self->_MATCHIFYr($S, "initializer__S_168DotEqual", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\="))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['dottyopish'], sub {
my $C = shift;
$C->dottyopish
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed mutator method call"))) { ($C) } else { () }

}
};
@gather;
});
}
;
## token type_constraint {
sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint', $retree) }
sub type_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "type_constraint", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_0') {
$C->deb("Fate passed to type_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT type_constraint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM type_constraint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'type_constraint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("type_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::DECLARAND->{'of'} })
}))
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::DECLARAND->{'of'}->Str))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$::DECLARAND->{'of'} = $M->{'typename'}}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## rule post_constraint {
sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint', $retree) }
sub post_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE post_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "post_constraint", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_0') {
$C->deb("Fate passed to post_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT post_constraint_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM post_constraint_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'post_constraint_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("post_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token named_param {
sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param', $retree) }
sub named_param {
no warnings 'recursion';
my $self = shift;

local $::GOAL = ')';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE named_param");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "named_param", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_0') {
$C->deb("Fate passed to named_param_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("named_param_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['named_param_term'], sub {
my $C = shift;
$C->named_param_term
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'named parameter', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var(1)
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token named_param_term {
sub named_param_term__PEEK { $_[0]->_AUTOLEXpeek('named_param_term', $retree) }
sub named_param_term {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE named_param_term");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "named_param_term", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_term_0') {
$C->deb("Fate passed to named_param_term_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT named_param_term_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM named_param_term_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'named_param_term_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("named_param_term_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token param_var($named = 0) {
sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var', $retree) }
sub param_var {
no warnings 'recursion';
my $self = shift;

my $named = @_ ? shift() : 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "param_var", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_0') {
$C->deb("Fate passed to param_var_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT param_var_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM param_var_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'param_var_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("param_var_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '&' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ident)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->sublongname
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->panic("Cannot declare a numeric parameter"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})
};
@gather;
}
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval {
$M->{'name'}->[0]->Str } // '';
$vname .= $n;
given ($twigil) {
when ('') {
$self->add_my_name($vname) if $n ne '';
$::CURLEX->{$vname}->{'used'} = 1 if $named and $n;
}
;
when ('.') {
}
;
when ('!') {
}
;
when ('*') {
}
;
default {
$self->panic("You may not use the $twigil twigil in a signature")}
;
}
;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token parameter {
sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter', $retree) }
sub parameter {
no warnings 'recursion';
my $self = shift;

my $kind;my $quant = '';local $::DECLARAND;local $::OFTYPE;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE parameter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'default_value'} = [];
$C->{'defterm'} = [];
$C->{'post_constraint'} = [];
$C->{'trait'} = [];
$C->{'type_constraint'} = [];
$self->_MATCHIFYr($S, "parameter", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_0') {
$C->deb("Fate passed to parameter_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'type_constraint'};
my @t = grep {
substr($_->Str,0,2) ne '::' }  @$t;
@t > 1 and $C->sorry("Multiple prefix constraints not yet supported")
;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_1') {
$C->deb("Fate passed to parameter_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
}))) {
scalar(do {
$quant = '|';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = (scalar(do {
$quant = '|';
$kind = '!';
}, $C))
and ($C) = ($C->worryobs("| with sigil","| without sigil"," nowadays"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = (scalar(do {
$quant = '\\';
$kind = '!';
}, $C))
and ($C) = ($C->worryobs("\\ with sigil","\\ without sigil"," nowadays"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_2') {
$C->deb("Fate passed to parameter_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_3') {
$C->deb("Fate passed to parameter_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' if $kind eq '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
$quant = '';
$kind = '!' ;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
}))) {
scalar(do {
$quant = '|';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['defterm'], sub {
my $C = shift;
$C->defterm
})
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = (scalar(do {
$quant = '|';
$kind = '!';
}, $C))
and ($C) = ($C->worryobs("| with sigil","| without sigil"," nowadays"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = (scalar(do {
$quant = '\\';
$kind = '!';
}, $C))
and ($C) = ($C->worryobs("\\ with sigil","\\ without sigil"," nowadays"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_4') {
$C->deb("Fate passed to parameter_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_4';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_4'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_4', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_5') {
$C->deb("Fate passed to parameter_5: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT parameter_5';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM parameter_5'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'parameter_5', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("parameter_5 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' if $kind eq '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (do {
my $M = $C;
$C->panic("In parameter declaration, typename '" . $M->{'longname'}->Str . "' must be predeclared (or marked as declarative with :: prefix)")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))
and ($C) = ($C->getdecl)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))
and ($C) = (scalar(do {
given ($quant) {
when ('!')  {
$C->sorry("Cannot put a default on a required parameter") }
;
when ('*')  {
$C->sorry("Cannot put a default on a slurpy parameter") }
;
when ('**') {
$C->sorry("Cannot put a default on a slice parameter") }
;
when ('\\') {
$C->sorry("Cannot put a default on a parcel parameter") }
;
when ('|')  {
$C->sorry("Cannot put a default on a capture snapshot parameter") }
;
}
;
$kind = '?' if $kind eq '!';
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Cannot put a default on the invocant parameter"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[,;)\]\{\}\-]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Default expression must come last"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$kind ne '!' })
}))
and ($C) = ($C->sorry("Invocant is too exotic"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEblock('quant', sub {
my $C = shift;
$quant}))
and ($C) = ($C->_SUBSUMEblock('kind', sub {
my $C = shift;
$kind}))) {
scalar(do {
given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->sorry("Cannot put required parameter after optional parameters")}
;
when ('var') {
$C->sorry("Cannot put required parameter after variadic parameters")}
;
}
}
;
when ('?') {
given ($::zone) {
when ('posreq') {
$::zone = 'posopt' }
;
when ('var') {
$C->sorry("Cannot put optional positional parameter after variadic parameters")}
;
}
}
;
when ('*') {
$::zone = 'var'}
;
}
}, $C)
} else { () }

});
}
;
## rule default_value {
sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value', $retree) }
sub default_value {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE default_value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "default_value", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token statement_prefix:sink    { <sym> <blast> }
sub statement_prefix__S_169sink__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_169sink', $retree) }
sub statement_prefix__S_169sink {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_169sink");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sink";
$self->_MATCHIFYr($S, "statement_prefix__S_169sink", do {
if (my ($C) = ($C->_EXACT("sink"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:try     { <sym> <blast> }
sub statement_prefix__S_170try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_170try', $retree) }
sub statement_prefix__S_170try {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_170try");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "try";
$self->_MATCHIFYr($S, "statement_prefix__S_170try", do {
if (my ($C) = ($C->_EXACT("try"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:quietly { <sym> <blast> }
sub statement_prefix__S_171quietly__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_171quietly', $retree) }
sub statement_prefix__S_171quietly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_171quietly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quietly";
$self->_MATCHIFYr($S, "statement_prefix__S_171quietly", do {
if (my ($C) = ($C->_EXACT("quietly"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:gather  { <sym> <blast> }
sub statement_prefix__S_172gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_172gather', $retree) }
sub statement_prefix__S_172gather {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_172gather");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gather";
$self->_MATCHIFYr($S, "statement_prefix__S_172gather", do {
if (my ($C) = ($C->_EXACT("gather"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:contend { <sym> <blast> }
sub statement_prefix__S_173contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_173contend', $retree) }
sub statement_prefix__S_173contend {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_173contend");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "contend";
$self->_MATCHIFYr($S, "statement_prefix__S_173contend", do {
if (my ($C) = ($C->_EXACT("contend"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:async   { <sym> <blast> }
sub statement_prefix__S_174async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_174async', $retree) }
sub statement_prefix__S_174async {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_174async");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "async";
$self->_MATCHIFYr($S, "statement_prefix__S_174async", do {
if (my ($C) = ($C->_EXACT("async"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:maybe   { <sym> <blast> }
sub statement_prefix__S_175maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_175maybe', $retree) }
sub statement_prefix__S_175maybe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_175maybe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "maybe";
$self->_MATCHIFYr($S, "statement_prefix__S_175maybe", do {
if (my ($C) = ($C->_EXACT("maybe"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:lazy    { <sym> <blast> }
sub statement_prefix__S_176lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_176lazy', $retree) }
sub statement_prefix__S_176lazy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_176lazy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lazy";
$self->_MATCHIFYr($S, "statement_prefix__S_176lazy", do {
if (my ($C) = ($C->_EXACT("lazy"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:do      { <sym> <blast> }
sub statement_prefix__S_177do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_177do', $retree) }
sub statement_prefix__S_177do {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_177do");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "do";
$self->_MATCHIFYr($S, "statement_prefix__S_177do", do {
if (my ($C) = ($C->_EXACT("do"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token statement_prefix:lift    {
sub statement_prefix__S_178lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_178lift', $retree) }
sub statement_prefix__S_178lift {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 1;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_178lift");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lift";
$self->_MATCHIFYr($S, "statement_prefix__S_178lift", do {
if (my ($C) = ($C->_EXACT("lift"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }

});
}
;
## token blast {
sub blast__PEEK { $_[0]->_AUTOLEXpeek('blast', $retree) }
sub blast {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blast");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blast", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blast_0') {
$C->deb("Fate passed to blast_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blast_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blast_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'blast_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("blast_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'blast_1') {
$C->deb("Fate passed to blast_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT blast_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM blast_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'blast_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("blast_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->panic("Whitespace required after keyword"))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token term:new {
sub term__S_179new__PEEK { $_[0]->_AUTOLEXpeek('term__S_179new', $retree) }
sub term__S_179new {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_179new");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "new";
$self->_MATCHIFYr($S, "term__S_179new", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gnew[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs("C++ constructor syntax", "method call syntax"))) {
$C
} else { () }

});
}
;
## token term:sym<::?IDENT> {
sub term__S_180ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_180ColonColonQuestionIDENT', $retree) }
sub term__S_180ColonColonQuestionIDENT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_180ColonColonQuestionIDENT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\?IDENT";
$self->_MATCHIFYr($S, "term__S_180ColonColonQuestionIDENT", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<undef> {
sub term__S_181undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_181undef', $retree) }
sub term__S_181undef {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_181undef");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "undef";
$self->_MATCHIFYr($S, "term__S_181undef", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gundef\b/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\$\//)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
"the filehandle's .slurp method"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
$C->{'twigil'} = [];
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\(")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/)
} else { () }

}
};
@gather;
}
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a verb', 'undefine function or assignment of Nil'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a value', "something more specific:\n\tMu (the \"most undefined\" type object),\n\tan undefined type object such as Int,\n\t:!defined as a matcher,\n\tAny:U as a type constraint,\n\tNil as the absense of a value\n\tor fail() as a failure return\n\t   "))) {
$C
} else { () }

});
}
;
## token term:sym<proceed>
sub term__S_182proceed__PEEK { $_[0]->_AUTOLEXpeek('term__S_182proceed', $retree) }
sub term__S_182proceed {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_182proceed");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proceed";
$self->_MATCHIFYr($S, "term__S_182proceed", do {
if (my ($C) = ($C->_PATTERN(qr/\Gproceed\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<time>
sub term__S_183time__PEEK { $_[0]->_AUTOLEXpeek('term__S_183time', $retree) }
sub term__S_183time {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_183time");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "time";
$self->_MATCHIFYr($S, "term__S_183time", do {
if (my ($C) = ($C->_PATTERN(qr/\Gtime\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<now>
sub term__S_184now__PEEK { $_[0]->_AUTOLEXpeek('term__S_184now', $retree) }
sub term__S_184now {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_184now");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "now";
$self->_MATCHIFYr($S, "term__S_184now", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnow\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<self> {
sub term__S_185self__PEEK { $_[0]->_AUTOLEXpeek('term__S_185self', $retree) }
sub term__S_185self {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_185self");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "self";
$self->_MATCHIFYr($S, "term__S_185self", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gself\b/))
and ($C) = (scalar(do {
$::HAS_SELF || $C->sorry("'self' used where no object is available") }, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<defer>
sub term__S_186defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_186defer', $retree) }
sub term__S_186defer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_186defer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "defer";
$self->_MATCHIFYr($S, "term__S_186defer", do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefer\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:rand {
sub term__S_187rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_187rand', $retree) }
sub term__S_187rand {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_187rand");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rand";
$self->_MATCHIFYr($S, "term__S_187rand", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grand\b/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\(?+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_187rand_0') {
$C->deb("Fate passed to term__S_187rand_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_187rand_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_187rand_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_187rand_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_187rand_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_EXACT("\$")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand(N)', 'N.rand or (1..N).pick'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(\)")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand()', 'rand'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<*>
sub term__S_188Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_188Star', $retree) }
sub term__S_188Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_188Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "term__S_188Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token term:sym<**>
sub term__S_189StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_189StarStar', $retree) }
sub term__S_189StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_189StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "term__S_189StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token infix:lambda {
sub infix__S_190lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_190lambda', $retree) }
sub infix__S_190lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_190lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "infix__S_190lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_190lambda_0') {
$C->deb("Fate passed to infix__S_190lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_190lambda_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_190lambda_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_190lambda_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_190lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\-\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = (scalar(do {
my $needparens = 0;
my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'given', 'when', 'loop', 'sub', 'method') {
$needparens++ if $_ eq 'loop';
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
if ($m->{'ctx'} eq '(') {
$C->panic("Word '$_' interpreted as '$_" . "()' function call; please use whitespace " .
($needparens ? 'around the parens' : 'instead of parens') . $m->{'token'}->locmess .
"\nUnexpected block in infix position (two terms in a row)")}
else {
$C->panic("Word '$_' interpreted as a listop; please use 'do $_' to introduce the statement control word" . $m->{'token'}->cursor($m->{'token'}->from)->locmess .
"\nUnexpected block in infix position (two terms in a row)")}};
}
;
return () if $::IN_REDUCE;
my $endpos = $C->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$C->panic("Unexpected block in infix position (previous line missing its semicolon?)")}
elsif ($::MEMOS[$startpos]->{'baremeth'}) {
$C->cursor($startpos)->panic("Unexpected block in infix position (method call with args needs colon or parens without whitespace)")}
else {
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)")};
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sigil
sub circumfix__S_191sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_191sigil', $retree) }
sub circumfix__S_191sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_191sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "circumfix__S_191sigil", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'contextualizer', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$::LEFTSIGIL ||= $M->{'sigil'}->Str }, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<( )>
sub circumfix__S_192Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_192Paren_Thesis', $retree) }
sub circumfix__S_192Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_192Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "circumfix__S_192Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'parenthesized expression', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<[ ]>
sub circumfix__S_193Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_193Bra_Ket', $retree) }
sub circumfix__S_193Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_193Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "circumfix__S_193Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'array composer', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'arraycomp'} = 1}, $C)
} else { () }

});
}
;
## token PRE {
sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE', $retree) }
sub PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "PRE", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_0') {
$C->deb("Fate passed to PRE_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT PRE_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM PRE_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'PRE_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("PRE_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'prefix'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'prefix'}->{'sym'}})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'prefix_circumfix_meta_operator'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'prefix_circumfix_meta_operator'}->Str})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token infixish ($in_meta = $*IN_META) {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;

my $in_meta = @_ ? shift() : $::IN_META;
my $infix;local $::IN_META = $in_meta;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_0') {
$C->deb("Fate passed to infixish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C;
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}->{'prec'} = $item_assignment{'prec'};
$M->{'O'}->{'assoc'} = 'unary';
$M->{'O'}->{'dba'} = 'adverb';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_1') {
$C->deb("Fate passed to infixish_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixish_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed infix', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) {
scalar(do {
$self->worry("Useless use of [] around infix op") unless $::IN_META}, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'twigil'} = [];
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\[[&\$]/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_2') {
$C->deb("Fate passed to infixish_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixish_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixish_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixish_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixish_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->variable
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'infixed function', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'} // {
%additive};
$M->{'sym'} = $M->{'infix'};
}, $C))) {
scalar(do {
my $M = $C;
$C->check_variable($M->{'infix'}) }, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$in_meta })
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dotty)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Method call found where infix expected (change whitespace?)"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->postfix)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Postfix found where infix expected (change whitespace?)"))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$infix = $M->{'infix'}})
}))
and ($C) = ($C->_SUBSUMEr(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix_postfix_meta_operator'}->[0]->{'O'};
$M->{'sym'} = $M->{'infix_postfix_meta_operator'}->[0]->{'sym'};
}, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token dotty:sym<.*> {
sub dotty__S_194DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_194DotStar', $retree) }
sub dotty__S_194DotStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_194DotStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\*";
$self->_MATCHIFYr($S, "dotty__S_194DotStar", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_194DotStar_0') {
$C->deb("Fate passed to dotty__S_194DotStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dotty__S_194DotStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dotty__S_194DotStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dotty__S_194DotStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dotty__S_194DotStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\^\!?+/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};

})
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
and ($C) = ($C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{0}->Str}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token dotty:sym<.> {
sub dotty__S_195Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_195Dot', $retree) }
sub dotty__S_195Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_195Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "dotty__S_195Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token privop {
sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop', $retree) }
sub privop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE privop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "privop", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token dottyopish {
sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish', $retree) }
sub dottyopish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyopish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyopish", $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->dottyop
}));
}
;
## token dottyop {
sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop', $retree) }
sub dottyop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyop", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_0') {
$C->deb("Fate passed to dottyop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dottyop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dottyop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dottyop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dottyop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'postop'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'postop'}->{'sym'}})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token POST {
sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST', $retree) }
sub POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];
$self->_MATCHIFYr($S, "POST", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]->{'ws'} })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_0') {
$C->deb("Fate passed to POST_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("POST_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_1') {
$C->deb("Fate passed to POST_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT POST_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM POST_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'POST_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("POST_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'dotty'}->{'O'};
$M->{'sym'} = $M->{'dotty'}->{'sym'};
$M->{'~CAPS'} = $M->{'dotty'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'privop'}->{'O'};
$M->{'sym'} = $M->{'privop'}->{'sym'};
$M->{'~CAPS'} = $M->{'privop'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postop'}->{'O'};
$M->{'sym'} = $M->{'postop'}->{'sym'};
$M->{'~CAPS'} = $M->{'postop'}->{'~CAPS'};
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
$::LEFTSIGIL = '@'}, $C)
} else { () }

});
}
;
## method can_meta ($op, $meta)
sub can_meta {
no warnings 'recursion';
my $self = shift;
die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;
die 'Required argument meta omitted' unless @_;
my $meta = @_ ? shift() : undef;
!$op->{'O'}->{'fiddly'} ||
$self->sorry("Cannot " . $meta . " " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are too fiddly");
$self;
};
## regex term:reduce {
sub term__S_196reduce__PEEK { $_[0]->_AUTOLEXpeek('term__S_196reduce', $retree) }
sub term__S_196reduce {
no warnings 'recursion';
my $self = shift;

local $::IN_REDUCE = 1;my $op;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_196reduce");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "reduce";
$self->_MATCHIFY($S, "term__S_196reduce", LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = (scalar(do {
my $M = $C;
$op = $M->{'s'}->{'op'};
$::MEMOS[$C->{'_pos'}]->{'listop'} = 1;
}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'s'}->Str}, $C)
},
$C->_SUBSUME(['O'], sub {
my $C = shift;
$C->O(%term)
}))
},
$C->_SUBSUME(['args'], sub {
my $C = shift;
$C->args(0)
}))
},
$C->_BRACKET(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'assoc'} eq 'chain' })
})
}
or $xact->[-2] or
do {
push @gather, $C->sorry("Cannot reduce with " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy and not chaining")
};
@gather;
}
}))
},
$C->can_meta($op, "reduce with"))
} else { () }
},
$C->_SUBSUME(['s'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_196reduce_0') {
$C->deb("Fate passed to term__S_196reduce_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_196reduce_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_196reduce_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_196reduce_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_196reduce_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
} else { () }
},
$C->_BRACKET(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('red')
}))
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\\"))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('tri')
}))
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
$C
})
};
@gather;
}
}))
} else { () }

})
}))
},
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\]")
},
$C->_PLUSg(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))
} else { () }
})));
}
;
## token prefix_postfix_meta_operator:sym< « >    { <sym> | '<<' }
sub prefix_postfix_meta_operator__S_197Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_197Fre', $retree) }
sub prefix_postfix_meta_operator__S_197Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix_postfix_meta_operator__S_197Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_197Fre", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_197Fre_0') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_197Fre_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT prefix_postfix_meta_operator__S_197Fre_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM prefix_postfix_meta_operator__S_197Fre_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'prefix_postfix_meta_operator__S_197Fre_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_197Fre_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token postfix_prefix_meta_operator:sym< » >    {
sub postfix_prefix_meta_operator__S_198Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_198Nch', $retree) }
sub postfix_prefix_meta_operator__S_198Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix_prefix_meta_operator__S_198Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_198Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_198Nch_0') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_198Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix_prefix_meta_operator__S_198Nch_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix_prefix_meta_operator__S_198Nch_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix_prefix_meta_operator__S_198Nch_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_198Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("»")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<!> {
sub infix_prefix_meta_operator__S_199Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_199Bang', $retree) }
sub infix_prefix_meta_operator__S_199Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_199Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_199Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\!")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('neg')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Negation metaoperator not followed by valid infix"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->{'O'}->{'iffy'} })
}))) {
$C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'infixish'}->{'O'}})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
my $M = $C;
$C->panic("Cannot negate " . $M->{'infixish'}->Str . " because " . $M->{'infixish'}->{'O'}->{'dba'} . " operators are not iffy enough")
})) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<R> {
sub infix_prefix_meta_operator__S_200R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_200R', $retree) }
sub infix_prefix_meta_operator__S_200R {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_200R");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "R";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_200R", do {
my $C = $C;
if (($C) = ($C->_EXACT("R"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('R')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse the args of")
})) {
$C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'infixish'}->{'O'}})
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<S> {
sub infix_prefix_meta_operator__S_201S__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_201S', $retree) }
sub infix_prefix_meta_operator__S_201S {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_201S");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "S";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_201S", do {
my $C = $C;
if (($C) = ($C->_EXACT("S"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('S')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "sequence the args of")
})) {
$C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'infixish'}->{'O'}})
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<X> {
sub infix_prefix_meta_operator__S_202X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_202X', $retree) }
sub infix_prefix_meta_operator__S_202X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_202X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_202X", do {
my $C = $C;
if (($C) = ($C->_EXACT("X"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('X')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "cross with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }

});
}
;
## token infix_prefix_meta_operator:sym<Z> {
sub infix_prefix_meta_operator__S_203Z__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_203Z', $retree) }
sub infix_prefix_meta_operator__S_203Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_203Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_203Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('Z')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "zip with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }

});
}
;
## token infix_circumfix_meta_operator:sym<« »> {
sub infix_circumfix_meta_operator__S_204Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_204Fre_Nch', $retree) }
sub infix_circumfix_meta_operator__S_204Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_204Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_204Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_0') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('hyper')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_1') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing « or »"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})) {
$C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'infixish'}->{'O'}})
} else { () }

});
}
;
## token infix_circumfix_meta_operator:sym«<< >>» {
sub infix_circumfix_meta_operator__S_205LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_205LtLt_GtGt', $retree) }
sub infix_circumfix_meta_operator__S_205LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_205LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_205LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('HYPER')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing << or >>"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})) {
$C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'infixish'}->{'O'}})
} else { () }

});
}
;
## token infix_postfix_meta_operator:sym<=> ($op) {
sub infix_postfix_meta_operator__S_206Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_206Equal', $retree) }
sub infix_postfix_meta_operator__S_206Equal {
no warnings 'recursion';
my $self = shift;

die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;
my %prec;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_postfix_meta_operator__S_206Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_206Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->can_meta($op, "make assignment out of"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Cannot make assignment out of " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy"))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $op->{'sym'} . '=';
if ($op->{'O'}->{'prec'} gt $comma{'prec'}) {
%prec = %item_assignment}
else {
%prec = %list_assignment};
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O($op->Opairs, %prec, dba => 'assignment operator', iffy => 0)
})
} else { () }

});
}
;
## token postcircumfix:sym<( )>
sub postcircumfix__S_207Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_207Paren_Thesis', $retree) }
sub postcircumfix__S_207Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_207Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "postcircumfix__S_207Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym<[ ]> { :dba('subscript') '[' ~ ']' <semilist> <O(|%methodcall)> 
sub postcircumfix__S_208Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_208Bra_Ket', $retree) }
sub postcircumfix__S_208Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_208Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "postcircumfix__S_208Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))) {
scalar(do {
my $M = $C;
my $innards = $M->{'semilist'}->Str;
$innards =~ s/^\s+//;
$innards =~ s/\s+$//;
if ($innards =~ /^\-\d+$/) {
$C->obs("[$innards] subscript to access from end of array","[*$innards]")};
}, $C)
} else { () }

});
}
;
## token postcircumfix:sym<{ }> {
sub postcircumfix__S_209Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_209Cur_Ly', $retree) }
sub postcircumfix__S_209Cur_Ly {
no warnings 'recursion';
my $self = shift;

local $::CURLEX = $::CURLEX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_209Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "postcircumfix__S_209Cur_Ly", do {
my $C = $C;
if (($C) = ($C->newlex)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->curlycheck(0))) {
$C
} else { () }

});
}
;
## token postcircumfix:sym«< >» {
sub postcircumfix__S_210Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_210Lt_Gt', $retree) }
sub postcircumfix__S_210Lt_Gt {
no warnings 'recursion';
my $self = shift;

my $pos;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_210Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "postcircumfix__S_210Lt_Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
$pos = $C->{'_pos'} }, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT("\>")
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postcircumfix__S_210Lt_Gt_0') {
$C->deb("Fate passed to postcircumfix__S_210Lt_Gt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postcircumfix__S_210Lt_Gt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postcircumfix__S_210Lt_Gt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postcircumfix__S_210Lt_Gt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postcircumfix__S_210Lt_Gt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
},
sub {
my $C=shift;
$C->_EXACT("\:")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
scalar(do {
$C->cursor_force($pos)->panic("Whitespace required before < operator") }, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->cursor_force($pos)->panic("Unable to parse quote-words subscript; couldn't find right angle quote") }, $C)
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym«<< >>»
sub postcircumfix__S_211LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_211LtLt_GtGt', $retree) }
sub postcircumfix__S_211LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_211LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "postcircumfix__S_211LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postcircumfix:sym<« »>
sub postcircumfix__S_212Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_212Fre_Nch', $retree) }
sub postcircumfix__S_212Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_212Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "postcircumfix__S_212Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_EXACT("«"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token postop {
sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop', $retree) }
sub postop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "postop", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_0') {
$C->deb("Fate passed to postop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'postfix'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'postfix'}->{'sym'}})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'postcircumfix'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'postcircumfix'}->{'sym'}})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token methodop {
sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop', $retree) }
sub methodop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE methodop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];
$self->_MATCHIFYr($S, "methodop", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_0') {
$C->deb("Fate passed to methodop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_1') {
$C->deb("Fate passed to methodop_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\$")
},
sub {
my $C=shift;
$C->_EXACT("\@")
},
sub {
my $C=shift;
$C->_EXACT("\&")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) }, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL})
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_EXACT("\""))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
} else { () }

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))
and ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_2') {
$C->deb("Fate passed to methodop_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_2';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_2'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_2', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('. to concatenate strings or to call a quoted method', '~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses'))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
my $t = $M->{'quote'}->{'nibble'}->Str;
$t =~ /\W/ or $t eq '' or $t =~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $C->worry("Useless use of quotes") ;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_3') {
$C->deb("Fate passed to methodop_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_3';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_3'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_3', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_4') {
$C->deb("Fate passed to methodop_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT methodop_4';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM methodop_4'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'methodop_4', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("methodop_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
} else { () }
},
sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'baremeth'} = 1 }, $C)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token semiarglist {
sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist', $retree) }
sub semiarglist {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semiarglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "semiarglist", do {
my $C = $C;
if (($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\;")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }

});
}
;
## token arglist {
sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist', $retree) }
sub arglist {
no warnings 'recursion';
my $self = shift;

my $inv_ok = $::INVOCANT_OK;local $::endargs = 0;local $::GOAL = 'endargs';local $::QSIGIL = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE arglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "arglist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_0') {
$C->deb("Fate passed to arglist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT arglist_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM arglist_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'arglist_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("arglist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
}))) {
scalar(do {
my $M = $C;
my $delims = $M->{'EXPR'}->{'delims'};
for (@$delims) {
if ($_->{'infix'}->{'wascolon'} // '') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}->{'list'}->[0]}}}
;
}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token term:lambda {
sub term__S_213lambda__PEEK { $_[0]->_AUTOLEXpeek('term__S_213lambda', $retree) }
sub term__S_213lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_213lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "term__S_213lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token circumfix:sym<{ }> {
sub circumfix__S_214Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_214Cur_Ly', $retree) }
sub circumfix__S_214Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_214Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "circumfix__S_214Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token postfix:sym<i>
sub postfix__S_215i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_215i', $retree) }
sub postfix__S_215i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_215i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "i";
$self->_MATCHIFYr($S, "postfix__S_215i", do {
if (my ($C) = ($C->_PATTERN(qr/\Gi\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }

});
}
;
## token infix:sym<.> ()
sub infix__S_216Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_216Dot', $retree) }
sub infix__S_216Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_216Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "infix__S_216Dot", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\.[\]\)\},:\s\$"']/))
and ($C) = ($C->obs('. to concatenate strings', '~'))) {
$C
} else { () }

});
}
;
## token postfix:sym['->'] () {
sub postfix__S_217MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_217MinusGt', $retree) }
sub postfix__S_217MinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_217MinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\>";
$self->_MATCHIFYr($S, "postfix__S_217MinusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix__S_217MinusGt_0') {
$C->deb("Fate passed to postfix__S_217MinusGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT postfix__S_217MinusGt_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM postfix__S_217MinusGt_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'postfix__S_217MinusGt_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("postfix__S_217MinusGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['brack'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[\[\{\(]/)
}))
and ($C) = (do {
my $M = $C;
$C->obs("'->" . $M->{'brack'}->Str . "' as postfix dereferencer", "'." . $M->{'brack'}->Str . "' or just '" . $M->{'brack'}->Str . "' to deref, or whitespace to delimit a pointy block")
})) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->obs('-> as postfix', 'either . to call a method, or whitespace to delimit a pointy block'))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token postfix:sym<++>
sub postfix__S_218PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_218PlusPlus', $retree) }
sub postfix__S_218PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_218PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "postfix__S_218PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token postfix:sym«--» ()
sub postfix__S_219MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_219MinusMinus', $retree) }
sub postfix__S_219MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_219MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "postfix__S_219MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token prefix:sym<++>
sub prefix__S_220PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_220PlusPlus', $retree) }
sub prefix__S_220PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_220PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "prefix__S_220PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token prefix:sym«--» ()
sub prefix__S_221MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_221MinusMinus', $retree) }
sub prefix__S_221MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_221MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "prefix__S_221MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }

});
}
;
## token infix:sym<**>
sub infix__S_222StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_222StarStar', $retree) }
sub infix__S_222StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_222StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "infix__S_222StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%exponentiation)
})
} else { () }

});
}
;
## token prefix:sym<!>
sub prefix__S_223Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_223Bang', $retree) }
sub prefix__S_223Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_223Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "prefix__S_223Bang", do {
if (my ($C) = ($C->_EXACT("\!"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<+>
sub prefix__S_224Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_224Plus', $retree) }
sub prefix__S_224Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_224Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "prefix__S_224Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<->
sub prefix__S_225Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_225Minus', $retree) }
sub prefix__S_225Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_225Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "prefix__S_225Minus", do {
if (my ($C) = ($C->_EXACT("\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~~>
sub prefix__S_226TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_226TildeTilde', $retree) }
sub prefix__S_226TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_226TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "prefix__S_226TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->dupprefix('~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~>
sub prefix__S_227Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_227Tilde', $retree) }
sub prefix__S_227Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_227Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "prefix__S_227Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<??>
sub prefix__S_228QuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_228QuestionQuestion', $retree) }
sub prefix__S_228QuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_228QuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?";
$self->_MATCHIFYr($S, "prefix__S_228QuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->dupprefix('??'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<?>
sub prefix__S_229Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_229Question', $retree) }
sub prefix__S_229Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_229Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "prefix__S_229Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<~^>
sub prefix__S_230TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_230TildeCaret', $retree) }
sub prefix__S_230TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_230TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "prefix__S_230TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<+^>
sub prefix__S_231PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_231PlusCaret', $retree) }
sub prefix__S_231PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_231PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "prefix__S_231PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<?^>
sub prefix__S_232QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_232QuestionCaret', $retree) }
sub prefix__S_232QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_232QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "prefix__S_232QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<^^>
sub prefix__S_233CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_233CaretCaret', $retree) }
sub prefix__S_233CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_233CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "prefix__S_233CaretCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^\^"))
and ($C) = ($C->dupprefix('^^'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<^>
sub prefix__S_234Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_234Caret', $retree) }
sub prefix__S_234Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_234Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "prefix__S_234Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<||>
sub prefix__S_235VertVert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_235VertVert', $retree) }
sub prefix__S_235VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_235VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "prefix__S_235VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token prefix:sym<|>
sub prefix__S_236Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_236Vert', $retree) }
sub prefix__S_236Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_236Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "prefix__S_236Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }

});
}
;
## token infix:sym<*>
sub infix__S_237Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_237Star', $retree) }
sub infix__S_237Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_237Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "infix__S_237Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym</>
sub infix__S_238Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_238Slash', $retree) }
sub infix__S_238Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_238Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/";
$self->_MATCHIFYr($S, "infix__S_238Slash", do {
if (my ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<div>
sub infix__S_239div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_239div', $retree) }
sub infix__S_239div {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_239div");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "div";
$self->_MATCHIFYr($S, "infix__S_239div", do {
if (my ($C) = ($C->_EXACT("div"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<%>
sub infix__S_240Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_240Percent', $retree) }
sub infix__S_240Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_240Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "infix__S_240Percent", do {
if (my ($C) = ($C->_EXACT("\%"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<%%>
sub infix__S_241PercentPercent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_241PercentPercent', $retree) }
sub infix__S_241PercentPercent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_241PercentPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\%";
$self->_MATCHIFYr($S, "infix__S_241PercentPercent", do {
if (my ($C) = ($C->_EXACT("\%\%"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<mod>
sub infix__S_242mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_242mod', $retree) }
sub infix__S_242mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_242mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "infix__S_242mod", do {
if (my ($C) = ($C->_EXACT("mod"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<gcd>
sub infix__S_243gcd__PEEK { $_[0]->_AUTOLEXpeek('infix__S_243gcd', $retree) }
sub infix__S_243gcd {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_243gcd");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gcd";
$self->_MATCHIFYr($S, "infix__S_243gcd", do {
if (my ($C) = ($C->_EXACT("gcd"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<lcm>
sub infix__S_244lcm__PEEK { $_[0]->_AUTOLEXpeek('infix__S_244lcm', $retree) }
sub infix__S_244lcm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_244lcm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lcm";
$self->_MATCHIFYr($S, "infix__S_244lcm", do {
if (my ($C) = ($C->_EXACT("lcm"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<+&>
sub infix__S_245PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_245PlusAmp', $retree) }
sub infix__S_245PlusAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_245PlusAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\&";
$self->_MATCHIFYr($S, "infix__S_245PlusAmp", do {
if (my ($C) = ($C->_EXACT("\+\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« << »
sub infix__S_246LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_246LtLt', $retree) }
sub infix__S_246LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_246LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "infix__S_246LtLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('<< to do left shift', '+< or ~<'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« >> »
sub infix__S_247GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_247GtGt', $retree) }
sub infix__S_247GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_247GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "infix__S_247GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('>> to do right shift', '+> or ~>'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<~&>
sub infix__S_248TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_248TildeAmp', $retree) }
sub infix__S_248TildeAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_248TildeAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\&";
$self->_MATCHIFYr($S, "infix__S_248TildeAmp", do {
if (my ($C) = ($C->_EXACT("\~\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<?&>
sub infix__S_249QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_249QuestionAmp', $retree) }
sub infix__S_249QuestionAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_249QuestionAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\&";
$self->_MATCHIFYr($S, "infix__S_249QuestionAmp", do {
if (my ($C) = ($C->_EXACT("\?\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym« ~< »
sub infix__S_250TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_250TildeLt', $retree) }
sub infix__S_250TildeLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_250TildeLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\<";
$self->_MATCHIFYr($S, "infix__S_250TildeLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« ~> »
sub infix__S_251TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_251TildeGt', $retree) }
sub infix__S_251TildeGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_251TildeGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\>";
$self->_MATCHIFYr($S, "infix__S_251TildeGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« +< »
sub infix__S_252PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_252PlusLt', $retree) }
sub infix__S_252PlusLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_252PlusLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\<";
$self->_MATCHIFYr($S, "infix__S_252PlusLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym« +> »
sub infix__S_253PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_253PlusGt', $retree) }
sub infix__S_253PlusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_253PlusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\>";
$self->_MATCHIFYr($S, "infix__S_253PlusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }

});
}
;
## token infix:sym<+>
sub infix__S_254Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_254Plus', $retree) }
sub infix__S_254Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_254Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "infix__S_254Plus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<->
sub infix__S_255Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_255Minus', $retree) }
sub infix__S_255Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_255Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "infix__S_255Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<+|>
sub infix__S_256PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_256PlusVert', $retree) }
sub infix__S_256PlusVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_256PlusVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\|";
$self->_MATCHIFYr($S, "infix__S_256PlusVert", do {
if (my ($C) = ($C->_EXACT("\+\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<+^>
sub infix__S_257PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_257PlusCaret', $retree) }
sub infix__S_257PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_257PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "infix__S_257PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<~|>
sub infix__S_258TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_258TildeVert', $retree) }
sub infix__S_258TildeVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_258TildeVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\|";
$self->_MATCHIFYr($S, "infix__S_258TildeVert", do {
if (my ($C) = ($C->_EXACT("\~\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<~^>
sub infix__S_259TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_259TildeCaret', $retree) }
sub infix__S_259TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_259TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "infix__S_259TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<?|>
sub infix__S_260QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_260QuestionVert', $retree) }
sub infix__S_260QuestionVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_260QuestionVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\|";
$self->_MATCHIFYr($S, "infix__S_260QuestionVert", do {
if (my ($C) = ($C->_EXACT("\?\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<?^>
sub infix__S_261QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_261QuestionCaret', $retree) }
sub infix__S_261QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_261QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "infix__S_261QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }

});
}
;
## token infix:sym<x>
sub infix__S_262x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_262x', $retree) }
sub infix__S_262x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_262x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "infix__S_262x", do {
if (my ($C) = ($C->_EXACT("x"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }

});
}
;
## token infix:sym<xx>
sub infix__S_263xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_263xx', $retree) }
sub infix__S_263xx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_263xx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xx";
$self->_MATCHIFYr($S, "infix__S_263xx", do {
if (my ($C) = ($C->_EXACT("xx"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }

});
}
;
## token infix:sym<~>
sub infix__S_264Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_264Tilde', $retree) }
sub infix__S_264Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_264Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "infix__S_264Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%concatenation)
})
} else { () }

});
}
;
## token infix:sym<&>
sub infix__S_265Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_265Amp', $retree) }
sub infix__S_265Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_265Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "infix__S_265Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<|>
sub infix__S_266Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_266Vert', $retree) }
sub infix__S_266Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_266Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "infix__S_266Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<^>
sub infix__S_267Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_267Caret', $retree) }
sub infix__S_267Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_267Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "infix__S_267Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }

});
}
;
## token prefix:sleep
sub prefix__S_268sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_268sleep', $retree) }
sub prefix__S_268sleep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_268sleep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sleep";
$self->_MATCHIFYr($S, "prefix__S_268sleep", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gsleep\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:abs
sub prefix__S_269abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_269abs', $retree) }
sub prefix__S_269abs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_269abs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "abs";
$self->_MATCHIFYr($S, "prefix__S_269abs", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gabs\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:let
sub prefix__S_270let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_270let', $retree) }
sub prefix__S_270let {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_270let");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "let";
$self->_MATCHIFYr($S, "prefix__S_270let", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Glet\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token prefix:temp
sub prefix__S_271temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_271temp', $retree) }
sub prefix__S_271temp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_271temp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "temp";
$self->_MATCHIFYr($S, "prefix__S_271temp", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtemp\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }

});
}
;
## token infix:sym« <=> »
sub infix__S_272LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_272LtEqualGt', $retree) }
sub infix__S_272LtEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_272LtEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\>";
$self->_MATCHIFYr($S, "infix__S_272LtEqualGt", do {
if (my ($C) = ($C->_EXACT("\<\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:cmp
sub infix__S_273cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_273cmp', $retree) }
sub infix__S_273cmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_273cmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "cmp";
$self->_MATCHIFYr($S, "infix__S_273cmp", do {
if (my ($C) = ($C->_EXACT("cmp"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:leg
sub infix__S_274leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_274leg', $retree) }
sub infix__S_274leg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_274leg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "leg";
$self->_MATCHIFYr($S, "infix__S_274leg", do {
if (my ($C) = ($C->_EXACT("leg"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }

});
}
;
## token infix:but
sub infix__S_275but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_275but', $retree) }
sub infix__S_275but {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_275but");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "but";
$self->_MATCHIFYr($S, "infix__S_275but", do {
if (my ($C) = ($C->_EXACT("but"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:does
sub infix__S_276does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_276does', $retree) }
sub infix__S_276does {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_276does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "infix__S_276does", do {
if (my ($C) = ($C->_EXACT("does"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<..>
sub infix__S_277DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_277DotDot', $retree) }
sub infix__S_277DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_277DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "infix__S_277DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_277DotDot_0') {
$C->deb("Fate passed to infix__S_277DotDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_277DotDot_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_277DotDot_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_277DotDot_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_277DotDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use ..* for indefinite range"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<^..>
sub infix__S_278CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_278CaretDotDot', $retree) }
sub infix__S_278CaretDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_278CaretDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.";
$self->_MATCHIFYr($S, "infix__S_278CaretDotDot", do {
if (my ($C) = ($C->_EXACT("\^\.\."))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<..^>
sub infix__S_279DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_279DotDotCaret', $retree) }
sub infix__S_279DotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_279DotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\^";
$self->_MATCHIFYr($S, "infix__S_279DotDotCaret", do {
if (my ($C) = ($C->_EXACT("\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<^..^>
sub infix__S_280CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_280CaretDotDotCaret', $retree) }
sub infix__S_280CaretDotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_280CaretDotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.\^";
$self->_MATCHIFYr($S, "infix__S_280CaretDotDotCaret", do {
if (my ($C) = ($C->_EXACT("\^\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }

});
}
;
## token infix:sym<==>
sub infix__S_281EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_281EqualEqual', $retree) }
sub infix__S_281EqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_281EqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=";
$self->_MATCHIFYr($S, "infix__S_281EqualEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\="))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<!=>
sub infix__S_282BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_282BangEqual', $retree) }
sub infix__S_282BangEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_282BangEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\=";
$self->_MATCHIFYr($S, "infix__S_282BangEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« < »
sub infix__S_283Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_283Lt', $retree) }
sub infix__S_283Lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_283Lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<";
$self->_MATCHIFYr($S, "infix__S_283Lt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« <= »
sub infix__S_284LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_284LtEqual', $retree) }
sub infix__S_284LtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_284LtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=";
$self->_MATCHIFYr($S, "infix__S_284LtEqual", do {
if (my ($C) = ($C->_EXACT("\<\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« > »
sub infix__S_285Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_285Gt', $retree) }
sub infix__S_285Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_285Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "infix__S_285Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym« >= »
sub infix__S_286GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_286GtEqual', $retree) }
sub infix__S_286GtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_286GtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\=";
$self->_MATCHIFYr($S, "infix__S_286GtEqual", do {
if (my ($C) = ($C->_EXACT("\>\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<~~>
sub infix__S_287TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_287TildeTilde', $retree) }
sub infix__S_287TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_287TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "infix__S_287TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dumbsmart)) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token dumbsmart {
sub dumbsmart__PEEK { $_[0]->_AUTOLEXpeek('dumbsmart', $retree) }
sub dumbsmart {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dumbsmart");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$self->_MATCHIFYr($S, "dumbsmart", $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'dumbsmart_0') {
$C->deb("Fate passed to dumbsmart_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT dumbsmart_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM dumbsmart_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'dumbsmart_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("dumbsmart_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("True")
},
sub {
my $C=shift;
$C->_EXACT("False")
},
sub {
my $C=shift;
$C->_EXACT("Bool\:\:True")
},
sub {
my $C=shift;
$C->_EXACT("Bool\:\:False")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }

})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
my $litbool = $M->{0}->[0]->Str;
my $true = $litbool =~ /True/;
$self->worry("Smartmatch against $litbool always " .
($true ? 'matches' : 'fails') .
"; if you mean to test the topic for\n    truthiness, please use " .
($true ? ':so or *.so or ?*' : ':!so or *.not or !*') .
' instead');
}, $C)
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token infix:sym<!~>
sub infix__S_288BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_288BangTilde', $retree) }
sub infix__S_288BangTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_288BangTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\~";
$self->_MATCHIFYr($S, "infix__S_288BangTilde", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\!\~\s/))
and ($C) = ($C->obs('!~ to do negated pattern matching', '!~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<=~>
sub infix__S_289EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_289EqualTilde', $retree) }
sub infix__S_289EqualTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_289EqualTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\~";
$self->_MATCHIFYr($S, "infix__S_289EqualTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\~"))
and ($C) = ($C->obs('=~ to do pattern matching', '~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<eq>
sub infix__S_290eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_290eq', $retree) }
sub infix__S_290eq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_290eq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eq";
$self->_MATCHIFYr($S, "infix__S_290eq", do {
if (my ($C) = ($C->_EXACT("eq"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<ne>
sub infix__S_291ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_291ne', $retree) }
sub infix__S_291ne {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_291ne");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ne";
$self->_MATCHIFYr($S, "infix__S_291ne", do {
if (my ($C) = ($C->_EXACT("ne"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<lt>
sub infix__S_292lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_292lt', $retree) }
sub infix__S_292lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_292lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lt";
$self->_MATCHIFYr($S, "infix__S_292lt", do {
if (my ($C) = ($C->_EXACT("lt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<le>
sub infix__S_293le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_293le', $retree) }
sub infix__S_293le {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_293le");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "le";
$self->_MATCHIFYr($S, "infix__S_293le", do {
if (my ($C) = ($C->_EXACT("le"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<gt>
sub infix__S_294gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_294gt', $retree) }
sub infix__S_294gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_294gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gt";
$self->_MATCHIFYr($S, "infix__S_294gt", do {
if (my ($C) = ($C->_EXACT("gt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<ge>
sub infix__S_295ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_295ge', $retree) }
sub infix__S_295ge {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_295ge");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ge";
$self->_MATCHIFYr($S, "infix__S_295ge", do {
if (my ($C) = ($C->_EXACT("ge"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<=:=>
sub infix__S_296EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_296EqualColonEqual', $retree) }
sub infix__S_296EqualColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_296EqualColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\:\=";
$self->_MATCHIFYr($S, "infix__S_296EqualColonEqual", do {
if (my ($C) = ($C->_EXACT("\=\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<===>
sub infix__S_297EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_297EqualEqualEqual', $retree) }
sub infix__S_297EqualEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_297EqualEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\=";
$self->_MATCHIFYr($S, "infix__S_297EqualEqualEqual", do {
if (my ($C) = ($C->_EXACT("\=\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<eqv>
sub infix__S_298eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298eqv', $retree) }
sub infix__S_298eqv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_298eqv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eqv";
$self->_MATCHIFYr($S, "infix__S_298eqv", do {
if (my ($C) = ($C->_EXACT("eqv"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<before>
sub infix__S_299before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299before', $retree) }
sub infix__S_299before {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_299before");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "before";
$self->_MATCHIFYr($S, "infix__S_299before", do {
if (my ($C) = ($C->_EXACT("before"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<after>
sub infix__S_300after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300after', $retree) }
sub infix__S_300after {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_300after");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "after";
$self->_MATCHIFYr($S, "infix__S_300after", do {
if (my ($C) = ($C->_EXACT("after"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }

});
}
;
## token infix:sym<&&>
sub infix__S_301AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301AmpAmp', $retree) }
sub infix__S_301AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_301AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "infix__S_301AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<||>
sub infix__S_302VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302VertVert', $retree) }
sub infix__S_302VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_302VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "infix__S_302VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<^^>
sub infix__S_303CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303CaretCaret', $retree) }
sub infix__S_303CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_303CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "infix__S_303CaretCaret", do {
if (my ($C) = ($C->_EXACT("\^\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<//>
sub infix__S_304SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304SlashSlash', $retree) }
sub infix__S_304SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_304SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "infix__S_304SlashSlash", do {
if (my ($C) = ($C->_EXACT("\/\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<min>
sub infix__S_305min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305min', $retree) }
sub infix__S_305min {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_305min");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "min";
$self->_MATCHIFYr($S, "infix__S_305min", do {
if (my ($C) = ($C->_EXACT("min"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<max>
sub infix__S_306max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306max', $retree) }
sub infix__S_306max {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_306max");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "max";
$self->_MATCHIFYr($S, "infix__S_306max", do {
if (my ($C) = ($C->_EXACT("max"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token infix:sym<?? !!> {
sub infix__S_307QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307QuestionQuestion_BangBang', $retree) }
sub infix__S_307QuestionQuestion_BangBang {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '!!';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_307QuestionQuestion_BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\ \!\!";
$self->_MATCHIFYr($S, "infix__S_307QuestionQuestion_BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\!\!")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\:[^=]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use !! rather than ::"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
scalar(do {
my $M = $C;
my $b = $M->{'infixish'}->Str;
if ($b eq ':') {
$C->panic("Please use !! rather than $b")}
else {
$C->panic("Precedence of $b is too loose to use between ?? and !!; please use parens around inner expression")};
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\n"))) {
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) { ($C) } else { () }
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->sorry("Bogus code found before the !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->sorry("Found ?? but no !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional, _reducecheck => 'raise_middle')
})
} else { () }

});
}
;
## token infix:sym<!!> {
sub infix__S_308BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308BangBang', $retree) }
sub infix__S_308BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_308BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "infix__S_308BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))
and ($C) = ($C->panic("An infix may not start with !!"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' })
}))
and ($C) = ($C->panic("List operator is not allowed inside ??!!; please use parens"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Ternary !! seems to be missing its ??"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## method raise_middle
sub raise_middle {
no warnings 'recursion';
my $self = shift;
$self->{'middle'} = $self->{'infix'}->{'EXPR'};
$self;
};
## token infix:sym<?>
sub infix__S_309Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309Question', $retree) }
sub infix__S_309Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_309Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "infix__S_309Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\?")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\:")
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^;]/)
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('?: for the conditional operator', '??!!'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<ff>
sub infix__S_310ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310ff', $retree) }
sub infix__S_310ff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_310ff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff";
$self->_MATCHIFYr($S, "infix__S_310ff", do {
if (my ($C) = ($C->_EXACT("ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^ff>
sub infix__S_311Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311Caretff', $retree) }
sub infix__S_311Caretff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_311Caretff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff";
$self->_MATCHIFYr($S, "infix__S_311Caretff", do {
if (my ($C) = ($C->_EXACT("\^ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<ff^>
sub infix__S_312ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312ffCaret', $retree) }
sub infix__S_312ffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_312ffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff\^";
$self->_MATCHIFYr($S, "infix__S_312ffCaret", do {
if (my ($C) = ($C->_EXACT("ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^ff^>
sub infix__S_313CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313CaretffCaret', $retree) }
sub infix__S_313CaretffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_313CaretffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff\^";
$self->_MATCHIFYr($S, "infix__S_313CaretffCaret", do {
if (my ($C) = ($C->_EXACT("\^ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<fff>
sub infix__S_314fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314fff', $retree) }
sub infix__S_314fff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_314fff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff";
$self->_MATCHIFYr($S, "infix__S_314fff", do {
if (my ($C) = ($C->_EXACT("fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^fff>
sub infix__S_315Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315Caretfff', $retree) }
sub infix__S_315Caretfff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_315Caretfff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff";
$self->_MATCHIFYr($S, "infix__S_315Caretfff", do {
if (my ($C) = ($C->_EXACT("\^fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<fff^>
sub infix__S_316fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316fffCaret', $retree) }
sub infix__S_316fffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_316fffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff\^";
$self->_MATCHIFYr($S, "infix__S_316fffCaret", do {
if (my ($C) = ($C->_EXACT("fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<^fff^>
sub infix__S_317CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317CaretfffCaret', $retree) }
sub infix__S_317CaretfffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_317CaretfffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff\^";
$self->_MATCHIFYr($S, "infix__S_317CaretfffCaret", do {
if (my ($C) = ($C->_EXACT("\^fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }

});
}
;
## token infix:sym<=> ()
sub infix__S_318Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318Equal', $retree) }
sub infix__S_318Equal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_318Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix__S_318Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::LEFTSIGIL eq '$' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token infix:sym<:=>
sub infix__S_319ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319ColonEqual', $retree) }
sub infix__S_319ColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_319ColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\=";
$self->_MATCHIFYr($S, "infix__S_319ColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
} else { () }

});
}
;
## token infix:sym<::=>
sub infix__S_320ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_320ColonColonEqual', $retree) }
sub infix__S_320ColonColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_320ColonColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\=";
$self->_MATCHIFYr($S, "infix__S_320ColonColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
} else { () }

});
}
;
## token infix:sym<.=> {
sub infix__S_321DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_321DotEqual', $retree) }
sub infix__S_321DotEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_321DotEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\=";
$self->_MATCHIFYr($S, "infix__S_321DotEqual", do {
if (my ($C) = ($C->_EXACT("\.\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment,
nextterm => 'dottyopish',
_reducecheck => 'check_doteq'
)
})
} else { () }

});
}
;
## method check_doteq
sub check_doteq {
no warnings 'recursion';
my $self = shift;
return $self if $self->{'left'}->{'scope_declarator'};
my $ok = 0;
eval {
my $methop = $self->{'right'}->{'methodop'};
my $name = $methop->{'longname'}->Str;
if (grep {
$_ eq $name }  <new clone sort subst trans reverse uniq map samecase substr flip fmt pick>) {
$ok = 1}
elsif (not $methop->{'args'}->[0]) {
$ok = 1};
};
$self->cursor_force($self->{'infix'}->{'_pos'})->worryobs('.= as append operator', '~=') unless $ok;
$self;
};
## token infix:sym« => »
sub infix__S_322EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_322EqualGt', $retree) }
sub infix__S_322EqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_322EqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\>";
$self->_MATCHIFYr($S, "infix__S_322EqualGt", do {
if (my ($C) = ($C->_EXACT("\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, fiddly => 0)
})
} else { () }

});
}
;
## token prefix:sym<so>
sub prefix__S_323so__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_323so', $retree) }
sub prefix__S_323so {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_323so");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "so";
$self->_MATCHIFYr($S, "prefix__S_323so", do {
if (my ($C) = ($C->_PATTERN(qr/\Gso\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }

});
}
;
## token prefix:sym<not>
sub prefix__S_324not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_324not', $retree) }
sub prefix__S_324not {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_324not");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "not";
$self->_MATCHIFYr($S, "prefix__S_324not", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnot\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }

});
}
;
## token infix:sym<,> {
sub infix__S_325Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325Comma', $retree) }
sub infix__S_325Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_325Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "infix__S_325Comma", do {
my $C = $C;
if (($C) = ($C->_EXACT("\,"))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma, fiddly => 0)
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\.\.\./)
}))) { ($C) } else { () }
}))
and ($C) = ($C->worry("Comma found before apparent series operator; please remove comma (or put parens\n    around the ... listop, or use 'fail' instead of ...)"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token infix:sym<:> {
sub infix__S_326Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326Colon', $retree) }
sub infix__S_326Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_326Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "infix__S_326Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_326Colon_0') {
$C->deb("Fate passed to infix__S_326Colon_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infix__S_326Colon_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infix__S_326Colon_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infix__S_326Colon_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infix__S_326Colon_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
$C->sorry("Illegal use of colon as invocant marker") unless $::INVOCANT_OK-- or $::PRECLIM ge $item_assignment_prec}, $C))
and ($C) = ($C->_SUBSUMEblock('wascolon', sub {
my $C = shift;
1}))
and ($C) = ($C->_SUBSUMEblock('sym', sub {
my $C = shift;
','}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma)
})
} else { () }

});
}
;
## token infix:sym<X>
sub infix__S_327X__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327X', $retree) }
sub infix__S_327X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_327X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix__S_327X", do {
if (my ($C) = ($C->_EXACT("X"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<Z>
sub infix__S_328Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328Z', $retree) }
sub infix__S_328Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_328Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix__S_328Z", do {
if (my ($C) = ($C->_EXACT("Z"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<minmax>
sub infix__S_329minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329minmax', $retree) }
sub infix__S_329minmax {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_329minmax");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "minmax";
$self->_MATCHIFYr($S, "infix__S_329minmax", do {
if (my ($C) = ($C->_EXACT("minmax"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }

});
}
;
## token infix:sym<...>
sub infix__S_330DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330DotDotDot', $retree) }
sub infix__S_330DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_330DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "infix__S_330DotDotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\.\."))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
}))) {
$C->_PATTERN(qr/\G\^?+/)
} else { () }

});
}
;
## token term:sym<...>
sub term__S_331DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_331DotDotDot', $retree) }
sub term__S_331DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_331DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "term__S_331DotDotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
## token term:sym<???>
sub term__S_332QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_332QuestionQuestionQuestion', $retree) }
sub term__S_332QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_332QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "term__S_332QuestionQuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?\?"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
## token term:sym<!!!>
sub term__S_333BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_333BangBangBang', $retree) }
sub term__S_333BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_333BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "term__S_333BangBangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!\!"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }

});
}
;
my %deftrap = (
'say' => 1, 'print' => 1, 'abs' => 1, 'alarm' => 1, 'chomp' => 1, 'chop' => 1, 'chr' => 1, 'chroot' => 1, 'cos' => 1,
'defined' => 1, 'eval' => 1, 'exp' => 1, 'glob' => 1, 'lc' => 1, 'lcfirst' => 1, 'log' => 1, 'lstat' => 1, 'mkdir' => 1,
'ord' => 1, 'readlink' => 1, 'readpipe' => 1, 'require' => 1, 'reverse' => 1, 'rmdir' => 1, 'sin' => 1,
'split' => 1, 'sqrt' => 1, 'stat' => 1, 'uc' => 1, 'ucfirst' => 1, 'unlink' => 1,
'WHAT' => (2), 'WHICH' => (2), 'WHERE' => (2), 'HOW' => (2), 'WHENCE' => (2), 'WHO' => (2),
'VAR' => (2),
'any' => (2), 'all' => (2), 'none' => (2), 'one' => (2),
);
## token term:identifier
sub term__S_334identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_334identifier', $retree) }
sub term__S_334identifier {
no warnings 'recursion';
my $self = shift;

my $name;my $pos;my $isname = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_334identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "identifier";
$self->_MATCHIFYr($S, "term__S_334identifier", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'unsp'} = [];
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_334identifier_0') {
$C->deb("Fate passed to term__S_334identifier_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_334identifier_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_334identifier_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_334identifier_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_334identifier_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[:]/)
}))
and ($C) = (scalar(do {
my $M = $C;
$name = $M->{'identifier'}->Str;
$pos = $C->{'_pos'};
$isname = $C->is_name($name);
$C->check_nodecl($name) if $isname;
}, $C))
and ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args($isname)
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'identifier'},$pos,substr($self->orig,$pos,1)) unless $M->{'args'}->{'invocant'}}, $C))
and ($C) = (scalar(do {
my $M = $C;
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$::BORG->{'name'} = $name;
}};
if ($deftrap{$name}) {
my $al = $M->{'args'}->{'arglist'}->[0];
my $ok = 0;
$ok = 1 if $isname;
$ok = 1 if $al and $al->from != $al->to;
$ok = 1 if $M->{'args'}->{'semiarglist'};
if (not $ok) {
given (0+$deftrap{$name}) {
when (1) {
$M->{'identifier'}->sorryobs("bare '$name'", ".$name if you meant \$_, or use an explicit invocant or argument")}
;
when (2) {
$M->{'identifier'}->sorry("The '$name' listop may not be called without arguments (please use () or whitespace to clarify)")}
;
}
};
};
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## token args ($istype = 0) {
sub args__PEEK { $_[0]->_AUTOLEXpeek('args', $retree) }
sub args {
no warnings 'recursion';
my $self = shift;

my $istype = @_ ? shift() : 0;
my $listopish = 0;local $::GOAL = '';local $::INVOCANT_OK = 1;local $::INVOCANT_IS;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE args");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "args", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_0') {
$C->deb("Fate passed to args_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT args_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM args_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'args_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("args_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->unsp)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (scalar(do {
$listopish = 1;
$::MEMOS[$C->{'_pos'}]->{'listop'} = 1;
}, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$istype })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_SUBSUMEblock('invocant', sub {
my $C = shift;
$::INVOCANT_IS}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$listopish })
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['moreargs'], sub {
my $C = shift;
$C->arglist
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEblock('O', sub {
my $C = shift;
{
} })
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token term:name
sub term__S_335name__PEEK { $_[0]->_AUTOLEXpeek('term__S_335name', $retree) }
sub term__S_335name {
no warnings 'recursion';
my $self = shift;

my $name;my $pos;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_335name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "term__S_335name", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$C->is_name($name) or substr($name,0,2) eq '::'
})
}))
and ($C) = (scalar(do {
$C->check_nodecl($name)}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\:\:)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_335name_0') {
$C->deb("Fate passed to term__S_335name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT term__S_335name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM term__S_335name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'term__S_335name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("term__S_335name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
$::VAR = $C->cursor_all($self->{'_pos'}, $C->{'_pos'}) }, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'longname'},$pos,'termish') unless $M->{'args'}->{'invocant'}}, $C))) {
scalar(do {
my $M = $C;
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$::BORG->{'name'} //= $name;
}}}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }

});
}
;
## method check_nodecl($name)
sub check_nodecl {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
if ($name lt 'a') {
$::MEMOS[$self->{'_pos'}]->{'nodecl'} = $name}};
## token infix:sym<and>
sub infix__S_336and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336and', $retree) }
sub infix__S_336and {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_336and");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "and";
$self->_MATCHIFYr($S, "infix__S_336and", do {
if (my ($C) = ($C->_EXACT("and"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<andthen>
sub infix__S_337andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337andthen', $retree) }
sub infix__S_337andthen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_337andthen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "andthen";
$self->_MATCHIFYr($S, "infix__S_337andthen", do {
if (my ($C) = ($C->_EXACT("andthen"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and)
})
} else { () }

});
}
;
## token infix:sym<or>
sub infix__S_338or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338or', $retree) }
sub infix__S_338or {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_338or");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "or";
$self->_MATCHIFYr($S, "infix__S_338or", do {
if (my ($C) = ($C->_EXACT("or"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym<orelse>
sub infix__S_339orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339orelse', $retree) }
sub infix__S_339orelse {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_339orelse");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "orelse";
$self->_MATCHIFYr($S, "infix__S_339orelse", do {
if (my ($C) = ($C->_EXACT("orelse"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or)
})
} else { () }

});
}
;
## token infix:sym<xor>
sub infix__S_340xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340xor', $retree) }
sub infix__S_340xor {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_340xor");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xor";
$self->_MATCHIFYr($S, "infix__S_340xor", do {
if (my ($C) = ($C->_EXACT("xor"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }

});
}
;
## token infix:sym« <== »
sub infix__S_341LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341LtEqualEqual', $retree) }
sub infix__S_341LtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_341LtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\=";
$self->_MATCHIFYr($S, "infix__S_341LtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« ==> »
sub infix__S_342EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342EqualEqualGt', $retree) }
sub infix__S_342EqualEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_342EqualEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>";
$self->_MATCHIFYr($S, "infix__S_342EqualEqualGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« <<== »
sub infix__S_343LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343LtLtEqualEqual', $retree) }
sub infix__S_343LtLtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_343LtLtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\=\=";
$self->_MATCHIFYr($S, "infix__S_343LtLtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token infix:sym« ==>> »
sub infix__S_344EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344EqualEqualGtGt', $retree) }
sub infix__S_344EqualEqualGtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_344EqualEqualGtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>\>";
$self->_MATCHIFYr($S, "infix__S_344EqualEqualGtGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }

});
}
;
## token terminator:sym<;>
sub terminator__S_345Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_345Semi', $retree) }
sub terminator__S_345Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_345Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "terminator__S_345Semi", do {
if (my ($C) = ($C->_EXACT("\;"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<if>
sub terminator__S_346if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_346if', $retree) }
sub terminator__S_346if {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_346if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "terminator__S_346if", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gif\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<unless>
sub terminator__S_347unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_347unless', $retree) }
sub terminator__S_347unless {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_347unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "terminator__S_347unless", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gunless\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<while>
sub terminator__S_348while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_348while', $retree) }
sub terminator__S_348while {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_348while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "terminator__S_348while", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhile\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<until>
sub terminator__S_349until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_349until', $retree) }
sub terminator__S_349until {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_349until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "terminator__S_349until", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Guntil\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<for>
sub terminator__S_350for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_350for', $retree) }
sub terminator__S_350for {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_350for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "terminator__S_350for", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<given>
sub terminator__S_351given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_351given', $retree) }
sub terminator__S_351given {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_351given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "terminator__S_351given", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Ggiven\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<when>
sub terminator__S_352when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_352when', $retree) }
sub terminator__S_352when {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_352when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "terminator__S_352when", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhen\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym« --> »
sub terminator__S_353MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_353MinusMinusGt', $retree) }
sub terminator__S_353MinusMinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_353MinusMinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-\>";
$self->_MATCHIFYr($S, "terminator__S_353MinusMinusGt", do {
if (my ($C) = ($C->_EXACT("\-\-\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## token terminator:sym<!!>
sub terminator__S_354BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_354BangBang', $retree) }
sub terminator__S_354BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_354BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "terminator__S_354BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }

});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
$C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
})
},
$C->before(sub {
my $C=shift;
$C->_EXACT("\!\!")
}))
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]->{'ws'} })
})
},
$C->before(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_1') {
$C->deb("Fate passed to infixstopper_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::P6', 'infixstopper_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}]->{'endargs'} })
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
1; };
{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::Q', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::b1', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape/ ],
backslash => [ qw/backslash__S_001qq__PEEK backslash__S_002Back__PEEK backslash__S_003stopper__PEEK backslash__S_004a__PEEK backslash__S_005b__PEEK backslash__S_006c__PEEK backslash__S_007e__PEEK backslash__S_008f__PEEK backslash__S_009n__PEEK backslash__S_010o__PEEK backslash__S_011r__PEEK backslash__S_012t__PEEK backslash__S_013x__PEEK backslash__S_0140__PEEK/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: q
    - !!perl/hash:RE_block {}
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_004a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: a
backslash__S_005b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: b
backslash__S_006c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
backslash__S_007e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: e
backslash__S_008f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: f
backslash__S_009n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: n
backslash__S_010o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_010o_0
        dba: octal character
        dic: STD::Q::b1
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_010o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_010o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_010o_0: *1
backslash__S_011r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: r
backslash__S_012t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: t
backslash__S_013x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_013x_0
        dba: hex character
        dic: STD::Q::b1
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_013x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_013x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_013x_0: *2
backslash__S_0140: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::b1
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '0'
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::b1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
RETREE_END
## token escape:sym<\\> { <sym> {} <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }

});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }

});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { <sym> }
sub backslash__S_004a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004a', $retree) }
sub backslash__S_004a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_004a", $C->_EXACT("a"));
}
;
## token backslash:b { <sym> }
sub backslash__S_005b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_005b', $retree) }
sub backslash__S_005b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_005b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_005b", $C->_EXACT("b"));
}
;
## token backslash:c { <sym> <charspec> }
sub backslash__S_006c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006c', $retree) }
sub backslash__S_006c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_006c", do {
if (my ($C) = ($C->_EXACT("c"))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }

});
}
;
## token backslash:e { <sym> }
sub backslash__S_007e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007e', $retree) }
sub backslash__S_007e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_007e", $C->_EXACT("e"));
}
;
## token backslash:f { <sym> }
sub backslash__S_008f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008f', $retree) }
sub backslash__S_008f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_008f", $C->_EXACT("f"));
}
;
## token backslash:n { <sym> }
sub backslash__S_009n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009n', $retree) }
sub backslash__S_009n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_009n", $C->_EXACT("n"));
}
;
## token backslash:o { :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_010o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010o', $retree) }
sub backslash__S_010o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_010o", do {
my $C = $C;
if (($C) = ($C->_EXACT("o"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_010o_0') {
$C->deb("Fate passed to backslash__S_010o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_010o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_010o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_010o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_010o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:r { <sym> }
sub backslash__S_011r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011r', $retree) }
sub backslash__S_011r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_011r", $C->_EXACT("r"));
}
;
## token backslash:t { <sym> }
sub backslash__S_012t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012t', $retree) }
sub backslash__S_012t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_012t", $C->_EXACT("t"));
}
;
## token backslash:x { :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_013x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013x', $retree) }
sub backslash__S_013x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_013x", do {
my $C = $C;
if (($C) = ($C->_EXACT("x"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_013x_0') {
$C->deb("Fate passed to backslash__S_013x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_013x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_013x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_013x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_013x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0140__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0140', $retree) }
sub backslash__S_0140 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0140");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0140", $C->_EXACT("0"));
}
;
1; };
{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::b0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::b0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<\\> { <!> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::c1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Cur_Ly__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::c1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: embeddedblock
          rest: ''
RETREE_END
## token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <embeddedblock> ] }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::c0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Cur_Ly__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::c0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<{ }> { <!> }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::s1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Dollar__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::s1
  re: !!perl/hash:RE_first
    zyg:
    - !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_assertion
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_string
            i: 0
            text: $
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      name: panic
      rest: 1
RETREE_END
## token escape:sym<$> {
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '$';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Non-variable \$ must be backslashed"))) { ($C) } else { () }

}
};
@gather;
});
}
1; };
{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::s0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Dollar__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::s0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<$> { <!> }
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::a1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000At__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::a1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '@'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000At_0
        dba: escape
        dic: STD::Q::a1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000At_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000At_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000At_0: *1
RETREE_END
## token escape:sym<@> {
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '@';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\@")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000At_0') {
$C->deb("Fate passed to escape__S_000At_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000At_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000At_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_000At_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000At_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::a0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000At__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::a0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<@> { <!> }
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::h1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Percent__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::h1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '%'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Percent_0
        dba: escape
        dic: STD::Q::h1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Percent_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Percent_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000Percent_0: *1
RETREE_END
## token escape:sym<%> {
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '%';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\%")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Percent_0') {
$C->deb("Fate passed to escape__S_000Percent_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000Percent_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000Percent_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_000Percent_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000Percent_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::h0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Percent__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::h0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<%> { <!> }
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::f1', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Amp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::f1
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '&'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Amp_0
        dba: escape
        dic: STD::Q::f1
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Amp_0 0
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Amp_0 1
          assert: '!'
          re: !!perl/hash:RE_noop
            nobind: 1
escape__S_000Amp_0: *1
RETREE_END
## token escape:sym<&> {
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '&';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\&")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Amp_0') {
$C->deb("Fate passed to escape__S_000Amp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT escape__S_000Amp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM escape__S_000Amp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_000Amp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("escape__S_000Amp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})

})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
1; };
{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::f0', 1 };
our $REGEXES = {
ALL => [ qw/escape/ ],
escape => [ qw/escape__S_000Amp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::f0
  re: !!perl/hash:RE_assertion
    assert: '!'
    re: !!perl/hash:RE_noop
      nobind: 1
RETREE_END
## token escape:sym<&> { <!> }
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
1; };
{ package STD::Q::p1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'path' }  1; };
{ package STD::Q::p0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'null' }  1; };
{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::w1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'words' }  1; };
{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::w0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'null' }  1; };
{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::ww1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'quotewords' }  1; };
{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::ww0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'null' }  1; };
{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::x1', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'run' }  1; };
{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::x0', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocessor ()
sub postprocessor {
no warnings 'recursion';
my $self = shift;
'null' }  1; };
{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::q', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape stopper/ ],
backslash => [ qw/backslash__S_001qq__PEEK backslash__S_002Back__PEEK backslash__S_003stopper__PEEK backslash__S_004misc__PEEK/ ],
escape => [ qw/escape__S_000Back__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: q
    - !!perl/hash:RE_block {}
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_004misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_meta
          min: 1
          text: .
    - !!perl/hash:RE_block {}
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::q
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::q
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## token escape:sym<\\> { <sym> <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }

});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }

});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }
sub backslash__S_004misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004misc', $retree) }
sub backslash__S_004misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_004misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->cursor_incr()

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = "\\" . $M->{0}->Str}, $C)
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
moose_with('STD::Q::b1');
moose_with('STD::Q::c1');
moose_with('STD::Q::s1');
moose_with('STD::Q::a1');
moose_with('STD::Q::h1');
moose_with('STD::Q::f1');
our $REGEXES = {
ALL => [ qw/backslash stopper/ ],
backslash => [ qw/backslash__S_000misc__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_000misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::qq
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_000misc_0
        dba: backslash
        dic: STD::Q::qq
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
backslash__S_000misc_0: *1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::qq
  re: !!perl/hash:RE_meta
    min: 1
    text: \"
RETREE_END
## token stopper { \" }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\""));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_000misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_000misc', $retree) }
sub backslash__S_000misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_000misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_000misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_000misc_0') {
$C->deb("Fate passed to backslash__S_000misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_000misc_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_000misc_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_000misc_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_000misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::cc;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::cc', 1 };
our $REGEXES = {
ALL => [ qw/backslash escape stopper/ ],
backslash => [ qw/backslash__S_006stopper__PEEK backslash__S_007a__PEEK backslash__S_008b__PEEK backslash__S_009c__PEEK backslash__S_010d__PEEK backslash__S_011e__PEEK backslash__S_012f__PEEK backslash__S_013h__PEEK backslash__S_014n__PEEK backslash__S_015o__PEEK backslash__S_016r__PEEK backslash__S_017s__PEEK backslash__S_018t__PEEK backslash__S_019v__PEEK backslash__S_020w__PEEK backslash__S_021x__PEEK backslash__S_0220__PEEK backslash__S_023misc__PEEK/ ],
escape => [ qw/escape__S_000ws__PEEK escape__S_001Sharp__PEEK escape__S_002Back__PEEK escape__S_003DotDot__PEEK escape__S_004Minus__PEEK escape__S_005ch__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_006stopper: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      name: stopper
      rest: ''
backslash__S_007a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: a
backslash__S_008b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: b
backslash__S_009c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
backslash__S_010d: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: d
    - !!perl/hash:RE_block {}
backslash__S_011e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: e
backslash__S_012f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: f
backslash__S_013h: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: h
    - !!perl/hash:RE_block {}
backslash__S_014n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: n
backslash__S_015o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_015o_0
        dba: octal character
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_015o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_015o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_015o_0: *1
backslash__S_016r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: r
backslash__S_017s: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_block {}
backslash__S_018t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 1
    name: sym
    rest: ''
    sym: t
backslash__S_019v: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: v
    - !!perl/hash:RE_block {}
backslash__S_020w: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: w
    - !!perl/hash:RE_block {}
backslash__S_021x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_021x_0
        dba: hex character
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_021x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_021x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
backslash__S_021x_0: *2
backslash__S_0220: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '0'
backslash__S_023misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: backslash__S_023misc_0
        dba: backslash
        dic: STD::Q::cc
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 0
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 1
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
backslash__S_023misc_0: *3
escape__S_000ws: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                text: '#'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
escape__S_001Sharp: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '#'
    - !!perl/hash:RE_method
      name: panic
      rest: 1
escape__S_002Back: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        name: backslash
        rest: ''
    - !!perl/hash:RE_method
      name: ccstate
      rest: 1
escape__S_003DotDot: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \s
                quant:
                - '*'
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method
                  name: stopper
                  rest: ''
              - !!perl/hash:RE_assertion
                assert: '!'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    text: ..
              - !!perl/hash:RE_meta
                min: 1
                text: \S
        - !!perl/hash:RE_method
          name: sorry
          rest: 1
    - !!perl/hash:RE_block {}
escape__S_004Minus: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_meta
      min: 1
      text: \S
    - !!perl/hash:RE_method
      name: obs
      rest: 1
escape__S_005ch: !!perl/hash:RE_ast
  dba: escape
  dic: STD::Q::cc
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_method
      name: ccstate
      rest: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  dic: STD::Q::cc
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## method ccstate ($s)
sub ccstate {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
if ($::CCSTATE eq '..') {
$::CCSTATE = ''}
else {
$::CCSTATE = $s};
$self;
};
## token escape:ws { \s+ [ <?before '#'> <.ws> ]? }
sub escape__S_000ws__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000ws', $retree) }
sub escape__S_000ws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ws";
$self->_MATCHIFYr($S, "escape__S_000ws", do {
if (my ($C) = ($C->_PATTERN(qr/\G\s++/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\#")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token escape:sym<#> { '#' <.panic: "Please backslash # for literal char or put whitespace in front f
sub escape__S_001Sharp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_001Sharp', $retree) }
sub escape__S_001Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_001Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "escape__S_001Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->panic("Please backslash # for literal char or put whitespace in front for comment"))) {
$C
} else { () }

});
}
;
## token escape:sym<\\> { <sym> <item=.backslash>  <.ccstate('\\' ~ $<item>.Str)> }
sub escape__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_002Back', $retree) }
sub escape__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_002Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
}))
and ($C) = (do {
my $M = $C;
$C->ccstate('\\' . $M->{'item'}->Str)
})) {
$C
} else { () }

});
}
;
## token escape:sym<..> { <sym>
sub escape__S_003DotDot__PEEK { $_[0]->_AUTOLEXpeek('escape__S_003DotDot', $retree) }
sub escape__S_003DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_003DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "escape__S_003DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE eq '' or $::CCSTATE eq '..' })
}))
and ($C) = ($C->sorry("Range missing start character on the left"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\.\.")
}))) { ($C) } else { () }
}))) {
$C->_PATTERN(qr/\G\S/)
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Range missing stop character on the right"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
scalar(do {
$::CCSTATE = '..'}, $C)
} else { () }

});
}
;
## token escape:sym<-> { '-' <?{ $*CCSTATE ne '' }> \s* <!stopper> \S <.obs('- as character range','..'
sub escape__S_004Minus__PEEK { $_[0]->_AUTOLEXpeek('escape__S_004Minus', $retree) }
sub escape__S_004Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_004Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "escape__S_004Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE ne '' })
}))
and ($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G\S/))
and ($C) = ($C->obs('- as character range','..'))) {
$C
} else { () }

});
}
;
## token escape:ch { $<ch> = [\S] <.ccstate($<ch>.Str)> }
sub escape__S_005ch__PEEK { $_[0]->_AUTOLEXpeek('escape__S_005ch', $retree) }
sub escape__S_005ch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_005ch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ch";
$self->_MATCHIFYr($S, "escape__S_005ch", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['ch'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
})
}))
and ($C) = (do {
my $M = $C;
$C->ccstate($M->{'ch'}->Str)
})) {
$C
} else { () }

});
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_006stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006stopper', $retree) }
sub backslash__S_006stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_006stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { :i <sym> }
sub backslash__S_007a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007a', $retree) }
sub backslash__S_007a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_007a", $C->_PATTERN(qr/\G(?i:a)/));
}
;
## token backslash:b { :i <sym> }
sub backslash__S_008b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008b', $retree) }
sub backslash__S_008b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_008b", $C->_PATTERN(qr/\G(?i:b)/));
}
;
## token backslash:c { :i <sym> <charspec> }
sub backslash__S_009c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009c', $retree) }
sub backslash__S_009c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_009c", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }

});
}
;
## token backslash:d { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_010d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010d', $retree) }
sub backslash__S_010d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_010d", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:d)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:e { :i <sym> }
sub backslash__S_011e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011e', $retree) }
sub backslash__S_011e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_011e", $C->_PATTERN(qr/\G(?i:e)/));
}
;
## token backslash:f { :i <sym> }
sub backslash__S_012f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012f', $retree) }
sub backslash__S_012f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_012f", $C->_PATTERN(qr/\G(?i:f)/));
}
;
## token backslash:h { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_013h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013h', $retree) }
sub backslash__S_013h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_013h", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:h)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:n { :i <sym> }
sub backslash__S_014n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_014n', $retree) }
sub backslash__S_014n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_014n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_014n", $C->_PATTERN(qr/\G(?i:n)/));
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_015o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_015o', $retree) }
sub backslash__S_015o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_015o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_015o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_015o_0') {
$C->deb("Fate passed to backslash__S_015o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_015o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_015o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_015o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_015o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:r { :i <sym> }
sub backslash__S_016r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_016r', $retree) }
sub backslash__S_016r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_016r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_016r", $C->_PATTERN(qr/\G(?i:r)/));
}
;
## token backslash:s { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_017s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_017s', $retree) }
sub backslash__S_017s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_017s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_017s", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:s)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:t { :i <sym> }
sub backslash__S_018t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_018t', $retree) }
sub backslash__S_018t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_018t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_018t", $C->_PATTERN(qr/\G(?i:t)/));
}
;
## token backslash:v { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_019v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_019v', $retree) }
sub backslash__S_019v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_019v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_019v", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:v)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:w { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_020w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_020w', $retree) }
sub backslash__S_020w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_020w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_020w", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:w)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }

});
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_021x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_021x', $retree) }
sub backslash__S_021x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_021x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_021x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_021x_0') {
$C->deb("Fate passed to backslash__S_021x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_021x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_021x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_021x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_021x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0220__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0220', $retree) }
sub backslash__S_0220 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0220");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0220", $C->_EXACT("0"));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_023misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_023misc', $retree) }
sub backslash__S_023misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_023misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_023misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_023misc_0') {
$C->deb("Fate passed to backslash__S_023misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_023misc_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_023misc_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_023misc_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_023misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
$orig->(@_);
};

1; };
{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
use Encode;
our $ALLROLES = { 'STD::Q::p5', 1 };
our $REGEXES = {
ALL => [ qw// ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method tweak (:$g!)
;
## method tweak (:$i!)
;
## method tweak (:$m!)
;
## method tweak (:$s!)
;
## method tweak (:$x!)
;
## method tweak (:$p!)
;
## method tweak (:$c!)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{g};
my $g = exists $args{g} ? delete $args{g} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{i};
my $i = exists $args{i} ? delete $args{i} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{m};
my $m = exists $args{m} ? delete $args{m} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{s};
my $s = exists $args{s} ? delete $args{s} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{p};
my $p = exists $args{p} ? delete $args{p} : undef;
$self     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{c};
my $c = exists $args{c} ? delete $args{c} : undef;
$self     };
}
$orig->(@_);
};

1; };
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
## method tweak (:backslash(:$b)!)
;
## method tweak (:scalar(:$s)!)
;
## method tweak (:array(:$a)!)
;
## method tweak (:hash(:$h)!)
;
## method tweak (:function(:$f)!)
;
## method tweak (:closure(:$c)!)
;
## method tweak (:path(:$p)!)
;
## method tweak (:exec(:$x)!)
;
## method tweak (:words(:$w)!)
;
## method tweak (:quotewords(:$ww)!)
;
## method tweak (:heredoc(:$to)!)
;
## method tweak (:$regex!)
;
## method tweak (*%x)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->truly($q,':q');
$self->mixin( 'STD::Q::q' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->truly($qq, ':qq');
$self->mixin( 'STD::Q::qq' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->truly($cc, ':cc');
$self->mixin( 'STD::Q::cc' );
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{backslash} || exists $args{b};
my $b = exists $args{backslash} ? delete $args{backslash} : exists $args{b} ? delete $args{b} : undef;
$self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{scalar} || exists $args{s};
my $s = exists $args{scalar} ? delete $args{scalar} : exists $args{s} ? delete $args{s} : undef;
$self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{array} || exists $args{a};
my $a = exists $args{array} ? delete $args{array} : exists $args{a} ? delete $args{a} : undef;
$self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{hash} || exists $args{h};
my $h = exists $args{hash} ? delete $args{hash} : exists $args{h} ? delete $args{h} : undef;
$self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{function} || exists $args{f};
my $f = exists $args{function} ? delete $args{function} : exists $args{f} ? delete $args{f} : undef;
$self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{closure} || exists $args{c};
my $c = exists $args{closure} ? delete $args{closure} : exists $args{c} ? delete $args{c} : undef;
$self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{path} || exists $args{p};
my $p = exists $args{path} ? delete $args{path} : exists $args{p} ? delete $args{p} : undef;
$self->mixin($p ? 'STD::Q::p1' : 'STD::Q::p0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{exec} || exists $args{x};
my $x = exists $args{exec} ? delete $args{exec} : exists $args{x} ? delete $args{x} : undef;
$self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{words} || exists $args{w};
my $w = exists $args{words} ? delete $args{words} : exists $args{w} ? delete $args{w} : undef;
$self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{quotewords} || exists $args{ww};
my $ww = exists $args{quotewords} ? delete $args{quotewords} : exists $args{ww} ? delete $args{ww} : undef;
$self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0')     };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{heredoc} || exists $args{to};
my $to = exists $args{heredoc} ? delete $args{heredoc} : exists $args{to} ? delete $args{to} : undef;
$self->truly($to, ':to');
$self->cursor_herelang;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{regex};
my $regex = exists $args{regex} ? delete $args{regex} : undef;
return $::LANG{'Regex'}    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quote modifier: " . join('',@k));
};
}
$orig->(@_);
};

1; };
{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD::P6');
our $ALLROLES = { 'STD::Quasi', 1 };
our $REGEXES = {
ALL => [ qw/term/ ],
term => [ qw/term__S_000unquote__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
term__S_000unquote: !!perl/hash:RE_ast
  dba: term
  dic: STD::Quasi
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            name: stopper
            rest: ''
        - !!perl/hash:RE_method
          name: panic
          rest: 1
RETREE_END
## token term:unquote {
sub term__S_000unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_000unquote', $retree) }
sub term__S_000unquote {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_000unquote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'starter'} = [];
$C->{'stopper'} = [];
$C->{sym} = "unquote";
$self->_MATCHIFYr($S, "term__S_000unquote", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## method tweak (:$ast!)
;
## method tweak (:$lang!)
;
## method tweak (:$unquote!)
;
## method tweak (:$COMPILING!)
;
## method tweak (*%x)
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ast};
my $ast = exists $args{ast} ? delete $args{ast} : undef;
$self    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{lang};
my $lang = exists $args{lang} ? delete $args{lang} : undef;
$self->cursor_fresh( $lang )    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{unquote};
my $unquote = exists $args{unquote} ? delete $args{unquote} : undef;
$self    };
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{COMPILING};
my $COMPILING = exists $args{COMPILING} ? delete $args{COMPILING} : undef;
$::QUASIMODO = 1;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quasiquote modifier: " . join('',@k));
};
}
$orig->(@_);
};

1; };
## method EXPR ($preclvl?)
sub EXPR {
no warnings 'recursion';
my $self = shift;
my $preclvl = @_ ? shift() : undef;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::LEFTSIGIL = '';
local $::PRECLIM = $preclim;
my @termstack;
my @opstack;
my $termish = 'termish';
push @opstack, {
'O' => \%terminator, 'sym' => '' };
my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;
my $reduce = sub{
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}->{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}->{'prec'} ne $opstack[-1]->{'O'}->{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
;
push @chain, pop(@termstack);
my $endpos = $chain[0]->{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]->from;
my $nop = $op->cursor_fresh();
$nop->prepbind(@chain);
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->from = $startpos;
$nop->{'_pos'} = $endpos;
my @caps;
my $i = 0;
for (@chain) {
push(@caps, $i++ % 2 ? 'op' : 'term' );
push(@caps, $_);
}
;
$nop->{'~CAPS'} = \@caps;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]->{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]->{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing term in " . $sym . " list")};
push @delims, pop(@opstack);
}
;
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing final term in '" . $sym . "' list")};
my $endpos = $list[0]->{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]->from;
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->prepbind(@list,@delims);
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->from = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, 'elem', $list[0] if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, 'delim', $d;
push @caps, 'elem', $l if $l;
}
;
$nop->{'~CAPS'} = \@caps;
};
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $arg = pop @termstack;
$op->prepbind($arg);
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->from < $op->from) {
$op->from = $arg->from;
unshift @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->from, 'POSTFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {
$op->{'_pos'} = $arg->{'_pos'};
push @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->from, 'PREFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
};
}
;
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
my $right = pop @termstack;
my $left = pop @termstack;
$op->prepbind($left,$right);
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->from = $left->from;
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';
my $a = $op->{'~CAPS'};
unshift @$a, 'left', $left;
push @$a, 'right', $right;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $ck;
if ($ck = $op->{'O'}->{'_reducecheck'}) {
$op = $op->$ck};
push @termstack, $op->_REDUCE($op->from, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
;
}
;
};
TERM:
for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::LEFTSIGIL = $opstack[-1]->{'O'}->{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;
if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
$here->panic("Bogus term") if @opstack > 1;
return ();
};
$termish = 'termish';
my $PRE = (delete $here->{'PRE'}) // [];
my $POST = (delete $here->{'POST'}) // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;
my $M = $here;
while (@PRE and @POST) {
my $postO = $POST[0]->{'O'};
my $preO = $PRE[0]->{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE}
else {
$here->sorry('"' . $PRE[0]->{'sym'} . '" and "' . $POST[0]->{'sym'} . '" are not associative')};
}
;
push @opstack, @PRE,@POST;
push @termstack, $here->{'term'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;
last TERM if $preclim eq $methodcall_prec;
for (;;) {
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]->{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;
if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR};
my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
};
if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
%$h = ();
$h->{"an infix operator with precedence tighter than $dba"} = 1;
};
last TERM;
};
$here = $infix->cursor_fresh->ws();
while ($opstack[-1]->{'O'}->{'prec'} gt $inprec) {
$reduce->()}

# Not much point in reducing the sentinels...
;
last if $inprec lt $LOOSEST;
if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;
};
if ($opstack[-1]->{'O'}->{'prec'} eq $inprec) {
my $assoc = 1;
given ($inO->{'assoc'}) {
when ('non')   {
$assoc = 0}
;
when ('left')  {
$reduce->() }
;
when ('right') {
}
;
when ('chain') {
}
;
when ('unary') {
}
;
when ('list')  {
$assoc = 0 unless $infix->{'sym'} eq $opstack[-1]->{'sym'}}
;
default {
$here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
;
}
;
if (not $assoc) {
$here->sorry('"' . $opstack[-1]->{'sym'} . '" and "' . $infix->Str . '" are non-associative and require parens')};
};
$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;
last;
}
;
}
;
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]->from = $self->{'_pos'};
$termstack[0]->{'_pos'} = $here->{'_pos'};
};
$self->_MATCHIFYr($S, "EXPR", @termstack);
};
{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
use Encode;
moose_extends('STD');
our $ALLROLES = { 'STD::Regex', 1 };
our $REGEXES = {
ALL => [ qw/assertion atom backslash category cclass_add cclass_elem cclass_expr cclass_union infixish infixstopper metachar mod_arg mod_internal nibbler normspace quant_atom_list quantified_atom quantifier quantmod regex_infix separator sigmaybe sign termish unsp/ ],
assertion => [ qw/assertion__S_082DotDotDot__PEEK assertion__S_083QuestionQuestionQuestion__PEEK assertion__S_084BangBangBang__PEEK assertion__S_085Vert__PEEK assertion__S_086Question__PEEK assertion__S_087Bang__PEEK assertion__S_088Star__PEEK assertion__S_089Cur_Ly__PEEK assertion__S_090variable__PEEK assertion__S_091method__PEEK assertion__S_092name__PEEK assertion__S_093Colon__PEEK assertion__S_094Bra__PEEK assertion__S_095Plus__PEEK assertion__S_096Minus__PEEK assertion__S_097Dot__PEEK assertion__S_098Comma__PEEK assertion__S_099TildeTilde__PEEK assertion__S_100bogus__PEEK/ ],
backslash => [ qw/backslash__S_056unspace__PEEK backslash__S_0570__PEEK backslash__S_058A__PEEK backslash__S_059a__PEEK backslash__S_060B__PEEK backslash__S_061b__PEEK backslash__S_062c__PEEK backslash__S_063d__PEEK backslash__S_064e__PEEK backslash__S_065f__PEEK backslash__S_066h__PEEK backslash__S_067n__PEEK backslash__S_068o__PEEK backslash__S_069p__PEEK backslash__S_070Q__PEEK backslash__S_071r__PEEK backslash__S_072s__PEEK backslash__S_073t__PEEK backslash__S_074v__PEEK backslash__S_075w__PEEK backslash__S_076x__PEEK backslash__S_077z__PEEK backslash__S_078Z__PEEK backslash__S_079misc__PEEK backslash__S_080oldbackref__PEEK backslash__S_081oops__PEEK/ ],
category => [ qw/category__S_000metachar__PEEK category__S_001sigmaybe__PEEK category__S_002backslash__PEEK category__S_003assertion__PEEK category__S_004quantifier__PEEK category__S_005cclass_elem__PEEK category__S_006mod_internal__PEEK/ ],
cclass_elem => [ qw/cclass_elem__S_101name__PEEK cclass_elem__S_102Bra_Ket__PEEK cclass_elem__S_103Paren_Thesis__PEEK cclass_elem__S_104property__PEEK cclass_elem__S_105quote__PEEK/ ],
metachar => [ qw/metachar__S_015Gt__PEEK metachar__S_016AmpAmp__PEEK metachar__S_017Amp__PEEK metachar__S_018VertVert__PEEK metachar__S_019Vert__PEEK metachar__S_020Ket__PEEK metachar__S_021Thesis__PEEK metachar__S_022Semi__PEEK metachar__S_023CurStarLy__PEEK metachar__S_024quant__PEEK metachar__S_025Cur_Ly__PEEK metachar__S_026mod__PEEK metachar__S_027Minus__PEEK metachar__S_028Colon__PEEK metachar__S_029ColonColon__PEEK metachar__S_030ColonColonGt__PEEK metachar__S_031ColonColonColon__PEEK metachar__S_032Bra_Ket__PEEK metachar__S_033ParenQuestionColon_Thesis__PEEK metachar__S_034ParenQuestionEqual_Thesis__PEEK metachar__S_035ParenQuestionBang_Thesis__PEEK metachar__S_036ParenQuestionBackLtEqual_Thesis__PEEK metachar__S_037ParenQuestionBackLtBang_Thesis__PEEK metachar__S_038Paren_Thesis__PEEK metachar__S_039LtParen__PEEK metachar__S_040ThesisGt__PEEK metachar__S_041LtLt__PEEK metachar__S_042GtGt__PEEK metachar__S_043Fre__PEEK metachar__S_044Nch__PEEK metachar__S_045qw__PEEK metachar__S_046Lt_Gt__PEEK metachar__S_047Back__PEEK metachar__S_048Dot__PEEK metachar__S_049CaretCaret__PEEK metachar__S_050Caret__PEEK metachar__S_051DollarDollar__PEEK metachar__S_052Dollar__PEEK metachar__S_053Single_Single__PEEK metachar__S_054Double_Double__PEEK metachar__S_055var__PEEK/ ],
mod_internal => [ qw/mod_internal__S_106Colonmy__PEEK mod_internal__S_107Coloni__PEEK mod_internal__S_108ColonBangi__PEEK mod_internal__S_109ColoniParen_Thesis__PEEK mod_internal__S_110Colon0i__PEEK mod_internal__S_111Colonm__PEEK mod_internal__S_112ColonBangm__PEEK mod_internal__S_113ColonmParen_Thesis__PEEK mod_internal__S_114Colon0m__PEEK mod_internal__S_115Colons__PEEK mod_internal__S_116ColonBangs__PEEK mod_internal__S_117ColonsParen_Thesis__PEEK mod_internal__S_118Colon0s__PEEK mod_internal__S_119Colonr__PEEK mod_internal__S_120ColonBangr__PEEK mod_internal__S_121ColonrParen_Thesis__PEEK mod_internal__S_122Colon0r__PEEK mod_internal__S_123ColonPerl5__PEEK mod_internal__S_124p6adv__PEEK mod_internal__S_125oops__PEEK/ ],
quantifier => [ qw/quantifier__S_126Star__PEEK quantifier__S_127Plus__PEEK quantifier__S_128Question__PEEK quantifier__S_129Colon__PEEK quantifier__S_130StarStar__PEEK quantifier__S_131Tilde__PEEK quantifier__S_132TildeTilde__PEEK quantifier__S_133CurNCommaMLy__PEEK/ ],
regex_infix => [ qw/regex_infix__S_007VertVert__PEEK regex_infix__S_008AmpAmp__PEEK regex_infix__S_009Vert__PEEK regex_infix__S_010Amp__PEEK/ ],
sigmaybe => [ qw/sigmaybe__S_011normspace__PEEK sigmaybe__S_012sigwhite__PEEK sigmaybe__S_013unsp__PEEK sigmaybe__S_014nosp__PEEK/ ],
};


no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
assertion:*:
  dic: STD::Regex
assertion__S_082DotDotDot: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '...'
assertion__S_083QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ???
assertion__S_084BangBangBang: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '!!!'
assertion__S_085Vert: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_bracket
      re: &1 !!perl/hash:RE_any
        altname: assertion__S_085Vert_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_085Vert_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_sequence
          alt: assertion__S_085Vert_0 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_method
            name: assertion
            rest: ''
assertion__S_085Vert_0: *1
assertion__S_086Question: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_bracket
      re: &2 !!perl/hash:RE_any
        altname: assertion__S_086Question_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_086Question_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_086Question_0 1
          name: assertion
          rest: ''
assertion__S_086Question_0: *2
assertion__S_087Bang: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_bracket
      re: &3 !!perl/hash:RE_any
        altname: assertion__S_087Bang_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_087Bang_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_087Bang_0 1
          name: assertion
          rest: ''
assertion__S_087Bang_0: *3
assertion__S_088Star: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_bracket
      re: &4 !!perl/hash:RE_any
        altname: assertion__S_088Star_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_088Star_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_sequence
          alt: assertion__S_088Star_0 1
          zyg:
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: nibbler
            rest: ''
assertion__S_088Star_0: *4
assertion__S_089Cur_Ly: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: embeddedblock
    rest: ''
assertion__S_090variable: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            name: EXPR
            rest: 1
assertion__S_091method: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: .
    - !!perl/hash:RE_bracket
      re: &5 !!perl/hash:RE_any
        altname: assertion__S_091method_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: assertion__S_091method_0 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                name: alpha
                rest: ''
          - !!perl/hash:RE_method
            name: assertion
            rest: ''
        - !!perl/hash:RE_bracket
          alt: assertion__S_091method_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_decl {}
            - !!perl/hash:RE_method
              name: dottyop
              rest: ''
assertion__S_091method_0: *5
assertion__S_092name: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: longname
          rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &6 !!perl/hash:RE_any
          altname: assertion__S_092name_0
          dba: assertion
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_sequence
            alt: assertion__S_092name_0 0
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              re: !!perl/hash:RE_method_re
                name: before
                nobind: 1
                re: !!perl/hash:RE_string
                  i: 0
                  text: '>'
            - !!perl/hash:RE_block {}
          - !!perl/hash:RE_sequence
            alt: assertion__S_092name_0 1
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_method
                name: normspace
                rest: ''
              quant:
              - '?'
            - !!perl/hash:RE_method
              name: nibbler
              rest: ''
            - !!perl/hash:RE_method
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_092name_0 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: =
            - !!perl/hash:RE_method
              name: assertion
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_092name_0 3
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ':'
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_decl {}
                - !!perl/hash:RE_method
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_092name_0 4
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: (
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_decl {}
                - !!perl/hash:RE_method
                  name: arglist
                  rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: )
                - !!perl/hash:RE_method
                  name: panic
                  rest: 1
      quant:
      - '?'
assertion__S_092name_0: *6
assertion__S_093Colon: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: ':'
    - !!perl/hash:RE_method
      name: cclass_expr
      rest: ''
assertion__S_094Bra: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '['
    - !!perl/hash:RE_method
      name: cclass_expr
      rest: ''
assertion__S_095Plus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: +
    - !!perl/hash:RE_method
      name: cclass_expr
      rest: ''
assertion__S_096Minus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '-'
    - !!perl/hash:RE_method
      name: cclass_expr
      rest: ''
assertion__S_097Dot: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: .
assertion__S_098Comma: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ','
assertion__S_099TildeTilde: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_bracket
      re: &7 !!perl/hash:RE_any
        altname: assertion__S_099TildeTilde_0
        dba: assertion
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_099TildeTilde_0 0
          assert: '?'
          re: !!perl/hash:RE_method_re
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              text: '>'
        - !!perl/hash:RE_quantified_atom
          alt: assertion__S_099TildeTilde_0 1
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
        - !!perl/hash:RE_method
          alt: assertion__S_099TildeTilde_0 2
          name: desigilname
          rest: ''
assertion__S_099TildeTilde_0: *7
assertion__S_100bogus: !!perl/hash:RE_ast
  dba: assertion
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: panic
    rest: 1
atom: !!perl/hash:RE_ast
  dba: regex atom
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: &8 !!perl/hash:RE_any
      altname: atom_0
      dba: regex atom
      dic: STD::Regex
      zyg:
      - !!perl/hash:RE_sequence
        alt: atom_0 0
        zyg:
        - !!perl/hash:RE_meta
          min: 1
          text: \w
        - !!perl/hash:RE_method
          name: SIGOK
          rest: ''
      - !!perl/hash:RE_sequence
        alt: atom_0 1
        zyg:
        - !!perl/hash:RE_method
          name: metachar
          rest: ''
        - !!perl/hash:RE_meta
          text: '::'
atom_0: *8
backslash:*:
  dic: STD::Regex
backslash__S_056unspace: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: ws
          rest: ''
backslash__S_0570: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '0'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          text: '[0..7]'
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_058A: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: A
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_059a: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: a
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
backslash__S_060B: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: B
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_061b: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: b
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_062c: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      name: charspec
      rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_063d: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: d
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_064e: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: e
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_065f: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: f
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_066h: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: h
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_067n: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: n
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_068o: !!perl/hash:RE_ast
  dba: octal character
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      re: &9 !!perl/hash:RE_any
        altname: backslash__S_068o_0
        dba: octal character
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_068o_0 0
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_068o_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_068o_0: *9
backslash__S_069p: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_cclass
        i: 0
        text: '[pP]'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_string
            i: 0
            text: '}'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_meta
            min: 1
            text: \=
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  text: -[\}]
                quant:
                - '*'
          - !!perl/hash:RE_string
            i: 0
            text: '}'
          - !!perl/hash:RE_block {}
backslash__S_070Q: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Q
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_071r: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: r
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_072s: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_073t: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: t
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_074v: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: v
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_075w: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: w
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_076x: !!perl/hash:RE_ast
  dba: hex character
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 1
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      re: &10 !!perl/hash:RE_any
        altname: backslash__S_076x_0
        dba: hex character
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_076x_0 0
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_076x_0 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 1
              text: '['
            - !!perl/hash:RE_block {}
            - !!perl/hash:RE_method
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              re: !!perl/hash:RE_first
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  text: ']'
                - !!perl/hash:RE_method
                  name: FAILGOAL
                  rest: 1
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_076x_0: *10
backslash__S_077z: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: z
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_078Z: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      name: obs
      rest: 1
backslash__S_079misc: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_meta
          min: 1
          text: \W
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
backslash__S_080oldbackref: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_cclass
            i: 0
            text: '[1..9]'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - '*'
    - !!perl/hash:RE_block {}
backslash__S_081oops: !!perl/hash:RE_ast
  dba: backslash
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
    - !!perl/hash:RE_meta
      min: 1
      text: .
category__S_000metachar: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: metachar
category__S_001sigmaybe: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: sigmaybe
category__S_002backslash: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: backslash
category__S_003assertion: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: assertion
category__S_004quantifier: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: quantifier
category__S_005cclass_elem: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: cclass_elem
category__S_006mod_internal: !!perl/hash:RE_ast
  dba: category
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: mod_internal
cclass_add: !!perl/hash:RE_ast
  dba: cclass_add
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_elem
        rest: ''
      quant:
      - +
cclass_add_0: !!perl/hash:RE_any
  a: 0
  altname: cclass_add_0
  dba: cclass_add
  dba_needed: 1
  dic: STD::Regex
  i: 0
  r: 1
  s: 0
  zyg:
  - !!perl/hash:RE_sequence
    a: 0
    alt: cclass_add_0 0
    dba: cclass_add
    dic: STD::Regex
    i: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: cclass_add
      dic: STD::Regex
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: +
  - !!perl/hash:RE_sequence
    a: 0
    alt: cclass_add_0 1
    dba: cclass_add
    dic: STD::Regex
    i: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: cclass_add
      dic: STD::Regex
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: '-'
cclass_elem:*:
  dic: STD::Regex
cclass_elem__S_101name: !!perl/hash:RE_ast
  dba: character class element
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: name
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem__S_102Bra_Ket: !!perl/hash:RE_ast
  dba: character class element
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_double
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: nibble
          rest: 1
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem__S_103Paren_Thesis: !!perl/hash:RE_ast
  dba: character class element
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: cclass_expr
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem__S_104property: !!perl/hash:RE_ast
  dba: character class element
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: colonpair
          rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem__S_105quote: !!perl/hash:RE_ast
  dba: cclass_elem
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &11 !!perl/hash:RE_any
          altname: cclass_elem__S_105quote_0
          dba: cclass_elem
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: cclass_elem__S_105quote_0 0
            i: 0
            text: '"'
          - !!perl/hash:RE_double
            alt: cclass_elem__S_105quote_0 1
            i: 0
            text: ''''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quote
          rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
cclass_elem__S_105quote_0: *11
cclass_expr: !!perl/hash:RE_ast
  dba: cclass_expr
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: sign
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_union
        rest: ''
      quant:
      - +
cclass_expr_0: !!perl/hash:RE_any
  a: 0
  altname: cclass_expr_0
  dba: cclass_expr
  dba_needed: 1
  dic: STD::Regex
  i: 0
  r: 1
  s: 0
  zyg:
  - !!perl/hash:RE_sequence
    a: 0
    alt: cclass_expr_0 0
    dba: cclass_expr
    dic: STD::Regex
    i: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: cclass_expr
      dic: STD::Regex
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: '|'
  - !!perl/hash:RE_sequence
    a: 0
    alt: cclass_expr_0 1
    dba: cclass_expr
    dic: STD::Regex
    i: 0
    r: 1
    s: 0
    zyg:
    - !!perl/hash:RE_string
      a: 0
      dba: cclass_expr
      dic: STD::Regex
      i: 0
      i_needed: 1
      r: 1
      s: 0
      text: ^
cclass_union: !!perl/hash:RE_ast
  dba: cclass_union
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: cclass_add
        rest: ''
      quant:
      - +
infixish: !!perl/hash:RE_ast
  dba: infixish
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_method
      name: regex_infix
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: &12 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      dic: STD::Regex
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_cclass
            i: 0
            text: '[\) \} \]]'
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 1
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '>'
            - !!perl/hash:RE_cclass
              i: 0
              text: -[>]
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 2
        assert: '?'
        re: !!perl/hash:RE_method_re
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            name: stopper
            rest: ''
infixstopper_0: *12
metachar:*:
  dic: STD::Regex
metachar__S_015Gt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '>'
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '>'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_016AmpAmp: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '&&'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_017Amp: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '&'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_018VertVert: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '||'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_019Vert: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '|'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_020Ket: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ']'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_021Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: )
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: fail
      rest: ''
metachar__S_022Semi: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ;
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: stopper
                  rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: .
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
metachar__S_023CurStarLy: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        i: 0
        name: sym
        rest: ''
        sym: '{*}'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
metachar__S_024quant: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      name: quantifier
      rest: ''
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
metachar__S_025Cur_Ly: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '{'
    - !!perl/hash:RE_method
      name: embeddedblock
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
metachar__S_026mod: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: ':'
    - !!perl/hash:RE_method
      name: mod_internal
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
metachar__S_027Minus: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
metachar__S_028Colon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      name: panic
      rest: 1
metachar__S_029ColonColon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: '::'
metachar__S_030ColonColonGt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ::>
metachar__S_031ColonColonColon: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_method
    i: 0
    name: sym
    rest: ''
    sym: ':::'
metachar__S_032Bra_Ket: !!perl/hash:RE_ast
  dba: bracketed regex
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: '['
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: ']'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
metachar__S_033ParenQuestionColon_Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '(?:'
    - !!perl/hash:RE_method
      name: obs
      rest: 1
metachar__S_034ParenQuestionEqual_Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: (?=
    - !!perl/hash:RE_method
      name: obs
      rest: 1
metachar__S_035ParenQuestionBang_Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: (?!
    - !!perl/hash:RE_method
      name: obs
      rest: 1
metachar__S_036ParenQuestionBackLtEqual_Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: (?<=
    - !!perl/hash:RE_method
      name: obs
      rest: 1
metachar__S_037ParenQuestionBackLtBang_Thesis: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: (?<!
    - !!perl/hash:RE_method
      name: obs
      rest: 1
metachar__S_038Paren_Thesis: !!perl/hash:RE_ast
  dba: capture parens
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: (
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: )
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
metachar__S_039LtParen: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <(
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_040ThesisGt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: )>
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_041LtLt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: <<
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_042GtGt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '>>'
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_043Fre: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: «
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_044Nch: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: »
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_045qw: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: <
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_method
      name: circumfix
      rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_046Lt_Gt: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_string
          i: 0
          text: <
        - !!perl/hash:RE_block {}
        - !!perl/hash:RE_method
          name: assertion
          rest: ''
        - !!perl/hash:RE_bracket
          re: !!perl/hash:RE_first
            zyg:
            - !!perl/hash:RE_string
              i: 0
              text: '>'
            - !!perl/hash:RE_method
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_047Back: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_method
      name: backslash
      rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_048Dot: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_049CaretCaret: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_050Caret: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_051DollarDollar: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                quant:
                - +
          - !!perl/hash:RE_method
            name: obs
            rest: 1
      quant:
      - '?'
metachar__S_052Dollar: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: $
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &13 !!perl/hash:RE_any
          altname: metachar__S_052Dollar_0
          dba: metachar
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: metachar__S_052Dollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: metachar__S_052Dollar_0 1
            i: 0
            text: '|'
          - !!perl/hash:RE_string
            alt: metachar__S_052Dollar_0 2
            i: 0
            text: '&'
          - !!perl/hash:RE_string
            alt: metachar__S_052Dollar_0 3
            i: 0
            text: )
          - !!perl/hash:RE_string
            alt: metachar__S_052Dollar_0 4
            i: 0
            text: ']'
          - !!perl/hash:RE_string
            alt: metachar__S_052Dollar_0 5
            i: 0
            text: '>'
          - !!perl/hash:RE_meta
            alt: metachar__S_052Dollar_0 6
            text: $
          - !!perl/hash:RE_method
            alt: metachar__S_052Dollar_0 7
            name: stopper
            rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_052Dollar_0: *13
metachar__S_053Single_Single: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_double
          i: 0
          text: ''''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quote
          rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_054Double_Double: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: '"'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quote
          rest: ''
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
metachar__S_055var: !!perl/hash:RE_ast
  dba: metachar
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          text: $$
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: variable
          rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  name: quantified_atom
                  rest: ''
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  re: !!perl/hash:RE_method_re
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          text: .
                        quant:
                        - '?'
                      - !!perl/hash:RE_cclass
                        i: 0
                        text: '[ \[ \{ \< ]'
                - !!perl/hash:RE_method
                  name: worry
                  rest: 1
            quant:
            - '?'
    - !!perl/hash:RE_method
      name: SIGOK
      rest: ''
mod_arg: !!perl/hash:RE_ast
  dba: modifier argument
  dic: STD::Regex
  re: !!perl/hash:RE_bracket
    re: !!perl/hash:RE_sequence
      zyg:
      - !!perl/hash:RE_string
        i: 0
        text: (
      - !!perl/hash:RE_block {}
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_decl {}
          - !!perl/hash:RE_method
            name: semilist
            rest: ''
      - !!perl/hash:RE_bracket
        re: !!perl/hash:RE_first
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: )
          - !!perl/hash:RE_method
            name: FAILGOAL
            rest: 1
mod_internal:*:
  dic: STD::Regex
mod_internal__S_106Colonmy: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bracket
            re: &14 !!perl/hash:RE_any
              altname: mod_internal__S_106Colonmy_0
              dba: mod_internal
              dic: STD::Regex
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 0
                i: 0
                text: my
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 1
                i: 0
                text: state
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 2
                i: 0
                text: our
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 3
                i: 0
                text: anon
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 4
                i: 0
                text: constant
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 5
                i: 0
                text: temp
              - !!perl/hash:RE_string
                alt: mod_internal__S_106Colonmy_0 6
                i: 0
                text: let
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: statement
          rest: ''
        - !!perl/hash:RE_method
          name: eat_terminator
          rest: ''
mod_internal__S_106Colonmy_0: *14
mod_internal__S_107Coloni: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &15 !!perl/hash:RE_any
          altname: mod_internal__S_107Coloni_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_107Coloni_0 0
            i: 0
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_107Coloni_0 1
            i: 0
            text: :ignorecase
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_107Coloni_0: *15
mod_internal__S_108ColonBangi: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &16 !!perl/hash:RE_any
          altname: mod_internal__S_108ColonBangi_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_108ColonBangi_0 0
            i: 0
            text: :!i
          - !!perl/hash:RE_string
            alt: mod_internal__S_108ColonBangi_0 1
            i: 0
            text: :!ignorecase
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_108ColonBangi_0: *16
mod_internal__S_109ColoniParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &17 !!perl/hash:RE_any
          altname: mod_internal__S_109ColoniParen_Thesis_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_109ColoniParen_Thesis_0 0
            i: 0
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_109ColoniParen_Thesis_0 1
            i: 0
            text: :ignorecase
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_109ColoniParen_Thesis_0: *17
mod_internal__S_110Colon0i: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bracket
      re: &18 !!perl/hash:RE_any
        altname: mod_internal__S_110Colon0i_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_110Colon0i_0 0
          i: 0
          text: i
        - !!perl/hash:RE_string
          alt: mod_internal__S_110Colon0i_0 1
          i: 0
          text: ignorecase
    - !!perl/hash:RE_block {}
mod_internal__S_110Colon0i_0: *18
mod_internal__S_111Colonm: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &19 !!perl/hash:RE_any
          altname: mod_internal__S_111Colonm_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_111Colonm_0 0
            i: 0
            text: :m
          - !!perl/hash:RE_string
            alt: mod_internal__S_111Colonm_0 1
            i: 0
            text: :ignoremark
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_111Colonm_0: *19
mod_internal__S_112ColonBangm: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &20 !!perl/hash:RE_any
          altname: mod_internal__S_112ColonBangm_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_112ColonBangm_0 0
            i: 0
            text: :!m
          - !!perl/hash:RE_string
            alt: mod_internal__S_112ColonBangm_0 1
            i: 0
            text: :!ignoremark
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_112ColonBangm_0: *20
mod_internal__S_113ColonmParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: &21 !!perl/hash:RE_any
          altname: mod_internal__S_113ColonmParen_Thesis_0
          dba: mod_internal
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_113ColonmParen_Thesis_0 0
            i: 0
            text: :m
          - !!perl/hash:RE_string
            alt: mod_internal__S_113ColonmParen_Thesis_0 1
            i: 0
            text: :ignoremark
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_113ColonmParen_Thesis_0: *21
mod_internal__S_114Colon0m: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bracket
      re: &22 !!perl/hash:RE_any
        altname: mod_internal__S_114Colon0m_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_114Colon0m_0 0
          i: 0
          text: m
        - !!perl/hash:RE_string
          alt: mod_internal__S_114Colon0m_0 1
          i: 0
          text: ignoremark
    - !!perl/hash:RE_block {}
mod_internal__S_114Colon0m_0: *22
mod_internal__S_115Colons: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_116ColonBangs: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :!s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_117ColonsParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_118Colon0s: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_string
      i: 0
      text: s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: igspace
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_119Colonr: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_120ColonBangr: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :!r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_121ColonrParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_method
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block {}
mod_internal__S_122Colon0r: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_string
      i: 0
      text: r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: atchet
      quant:
      - '?'
    - !!perl/hash:RE_meta
      text: »
    - !!perl/hash:RE_block {}
mod_internal__S_123ColonPerl5: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &23 !!perl/hash:RE_any
        altname: mod_internal__S_123ColonPerl5_0
        dba: mod_internal
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_123ColonPerl5_0 0
          i: 0
          text: :Perl5
        - !!perl/hash:RE_string
          alt: mod_internal__S_123ColonPerl5_0 1
          i: 0
          text: :P5
    - !!perl/hash:RE_method
      name: require_P5
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: nibbler
          rest: ''
mod_internal__S_123ColonPerl5_0: *23
mod_internal__S_124p6adv: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_bracket
            re: &24 !!perl/hash:RE_any
              altname: mod_internal__S_124p6adv_0
              dba: mod_internal
              dic: STD::Regex
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_124p6adv_0 0
                i: 0
                text: dba
              - !!perl/hash:RE_string
                alt: mod_internal__S_124p6adv_0 1
                i: 0
                text: lang
          - !!perl/hash:RE_meta
            text: »
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: quotepair
          rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_block {}
mod_internal__S_124p6adv_0: *24
mod_internal__S_125oops: !!perl/hash:RE_ast
  dba: mod_internal
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: ':'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \w
            quant:
            - +
    - !!perl/hash:RE_method
      name: sorry
      rest: 1
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: normspace
              rest: ''
            quant:
            - '?'
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_qw
            min: 1
            text: < || | && & >
          - !!perl/hash:RE_method
            name: ws
            rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          re: !!perl/hash:RE_method
            name: infixstopper
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_meta
            text: $$
          - !!perl/hash:RE_method
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            name: ws
            rest: ''
normspace: !!perl/hash:RE_ast
  dba: normspace
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &25 !!perl/hash:RE_any
          altname: normspace_0
          dba: normspace
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: normspace_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: normspace_0 1
            i: 0
            text: '#'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_sequence
        zyg:
        - !!perl/hash:RE_decl {}
        - !!perl/hash:RE_method
          name: ws
          rest: ''
normspace_0: *25
quant_atom_list: !!perl/hash:RE_ast
  dba: quant_atom_list
  dic: STD::Regex
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
    quant:
    - +
quantified_atom: !!perl/hash:RE_ast
  dba: quantified_atom
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: stopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_method
        name: regex_infix
        rest: ''
    - !!perl/hash:RE_method
      name: atom
      rest: ''
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_method
      name: sigmaybe
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_method
            name: quantifier
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: sigmaybe
              rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              name: separator
              rest: ''
            quant:
            - '?'
      quant:
      - '?'
quantifier:*:
  dic: STD::Regex
quantifier__S_126Star: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_127Plus: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_128Question: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
quantifier__S_129Colon: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
quantifier__S_130StarStar: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: '**'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantmod
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: &26 !!perl/hash:RE_any
        altname: quantifier__S_130StarStar_0
        dba: quantifier
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_130StarStar_0 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            quant:
            - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \s
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            text: ..
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quantifier__S_130StarStar_0 1
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                quant:
                - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              re: !!perl/hash:RE_sequence
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  text: ..
                - !!perl/hash:RE_bracket
                  re: &27 !!perl/hash:RE_any
                    altname: quantifier__S_130StarStar_1
                    dba: quantifier
                    dic: STD::Regex
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: quantifier__S_130StarStar_1 0
                      zyg:
                      - !!perl/hash:RE_bindpos
                        atom: !!perl/hash:RE_paren
                          re: !!perl/hash:RE_quantified_atom
                            atom: !!perl/hash:RE_meta
                              min: 1
                              text: \d
                            quant:
                            - +
                      - !!perl/hash:RE_block {}
                    - !!perl/hash:RE_string
                      alt: quantifier__S_130StarStar_1 1
                      i: 0
                      text: '*'
                    - !!perl/hash:RE_method
                      alt: quantifier__S_130StarStar_1 2
                      name: panic
                      rest: 1
            quant:
            - '?'
        - !!perl/hash:RE_method
          alt: quantifier__S_130StarStar_0 2
          name: embeddedblock
          rest: ''
        - !!perl/hash:RE_sequence
          alt: quantifier__S_130StarStar_0 3
          zyg:
          - !!perl/hash:RE_block {}
          - !!perl/hash:RE_method
            name: quantified_atom
            rest: ''
          - !!perl/hash:RE_block {}
quantifier__S_130StarStar_0: *26
quantifier__S_130StarStar_1: *27
quantifier__S_131Tilde: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_meta
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
quantifier__S_132TildeTilde: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bracket
      re: &28 !!perl/hash:RE_any
        altname: quantifier__S_132TildeTilde_0
        dba: quantifier
        dic: STD::Regex
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_132TildeTilde_0 0
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '!'
          - !!perl/hash:RE_method
            i: 0
            name: sym
            rest: ''
            sym: ~~
        - !!perl/hash:RE_method
          alt: quantifier__S_132TildeTilde_0 1
          i: 0
          name: sym
          rest: ''
          sym: ~~
    - !!perl/hash:RE_method
      name: normspace
      rest: ''
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
quantifier__S_132TildeTilde_0: *28
quantifier__S_133CurNCommaMLy: !!perl/hash:RE_ast
  dba: quantifier
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_block {}
    - !!perl/hash:RE_string
      i: 0
      text: '{'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - +
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_string
            i: 0
            text: ','
          quant:
          - '?'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          quant:
          - '*'
    - !!perl/hash:RE_string
      i: 0
      text: '}'
    - !!perl/hash:RE_block {}
quantmod: !!perl/hash:RE_ast
  dba: quantmod
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        text: ':'
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        re: &29 !!perl/hash:RE_any
          altname: quantmod_0
          dba: quantmod
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_string
            alt: quantmod_0 0
            i: 0
            text: '?'
          - !!perl/hash:RE_string
            alt: quantmod_0 1
            i: 0
            text: '!'
          - !!perl/hash:RE_string
            alt: quantmod_0 2
            i: 0
            text: +
      quant:
      - '?'
quantmod_0: *29
regex_infix:*:
  dic: STD::Regex
regex_infix__S_007VertVert: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_008AmpAmp: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_009Vert: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      name: O
      rest: 1
regex_infix__S_010Amp: !!perl/hash:RE_ast
  dba: regex_infix
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_method
      i: 0
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      name: O
      rest: 1
separator: !!perl/hash:RE_ast
  dba: separator
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        re: !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_string
            i: 0
            text: '%'
          - !!perl/hash:RE_bracket
            re: &30 !!perl/hash:RE_any
              altname: separator_0
              dba: separator
              dic: STD::Regex
              zyg:
              - !!perl/hash:RE_string
                alt: separator_0 0
                i: 0
                text: '%'
              - !!perl/hash:RE_assertion
                alt: separator_0 1
                assert: '!'
                re: !!perl/hash:RE_method_re
                  name: before
                  nobind: 1
                  re: &31 !!perl/hash:RE_any
                    altname: separator_1
                    dba: separator
                    dic: STD::Regex
                    zyg:
                    - !!perl/hash:RE_cclass
                      alt: separator_1 0
                      i: 0
                      text: '[ \< * . ! ^ : ]'
                    - !!perl/hash:RE_meta
                      alt: separator_1 1
                      min: 1
                      text: \w
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_method
      name: quantified_atom
      rest: ''
separator_0: *30
separator_1: *31
sigmaybe:*:
  dic: STD::Regex
sigmaybe__S_011normspace: !!perl/hash:RE_ast
  dba: sigmaybe
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: normspace
      rest: ''
sigmaybe__S_012sigwhite: !!perl/hash:RE_ast
  dba: sigmaybe
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_block
        nobind: 1
    - !!perl/hash:RE_method
      name: normspace
      rest: ''
    - !!perl/hash:RE_block {}
sigmaybe__S_013unsp: !!perl/hash:RE_ast
  dba: sigmaybe
  dic: STD::Regex
  re: !!perl/hash:RE_method
    name: unsp
    rest: ''
sigmaybe__S_014nosp: !!perl/hash:RE_ast
  dba: sigmaybe
  dic: STD::Regex
  re: !!perl/hash:RE_assertion
    assert: '?'
    re: !!perl/hash:RE_method_re
      name: before
      nobind: 1
      re: !!perl/hash:RE_meta
        min: 1
        text: \S
sign: !!perl/hash:RE_ast
  dba: sign
  dic: STD::Regex
  re: &32 !!perl/hash:RE_any
    altname: sign_0
    dba: sign
    dic: STD::Regex
    zyg:
    - !!perl/hash:RE_string
      alt: sign_0 0
      i: 0
      text: +
    - !!perl/hash:RE_string
      alt: sign_0 1
      i: 0
      text: '-'
    - !!perl/hash:RE_assertion
      alt: sign_0 2
      assert: '?'
      re: !!perl/hash:RE_noop
        nobind: 1
sign_0: *32
termish: !!perl/hash:RE_ast
  dba: termish
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        name: normspace
        rest: ''
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      re: !!perl/hash:RE_first
        zyg:
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              name: quant_atom_list
              rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_block
              nobind: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: &33 !!perl/hash:RE_any
                altname: termish_0
                dba: termish
                dic: STD::Regex
                zyg:
                - !!perl/hash:RE_method
                  alt: termish_0 0
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_cclass
                  alt: termish_0 1
                  i: 0
                  text: '[&|~]'
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            re: !!perl/hash:RE_method_re
              name: before
              nobind: 1
              re: !!perl/hash:RE_cclass
                i: 0
                text: '[ \] \) \> ]'
          - !!perl/hash:RE_block {}
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_meta
            text: $$
          - !!perl/hash:RE_method
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
          - !!perl/hash:RE_method
            name: sorry
            rest: 1
        - !!perl/hash:RE_method
          name: panic
          rest: 1
termish_0: *33
unsp: !!perl/hash:RE_ast
  dba: unsp
  dic: STD::Regex
  re: !!perl/hash:RE_sequence
    zyg:
    - !!perl/hash:RE_string
      i: 0
      text: \
    - !!perl/hash:RE_assertion
      assert: '?'
      re: !!perl/hash:RE_method_re
        name: before
        nobind: 1
        re: &34 !!perl/hash:RE_any
          altname: unsp_0
          dba: unsp
          dic: STD::Regex
          zyg:
          - !!perl/hash:RE_meta
            alt: unsp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: unsp_0 1
            i: 0
            text: '#'
    - !!perl/hash:RE_method
      name: panic
      rest: 1
unsp_0: *34
RETREE_END
## method tweak (:Perl5(:$P5)!)
;
## method tweak (:overlap(:$ov)!)
;
## method tweak (:exhaustive(:$ex)!)
;
## method tweak (:continue(:$c)!)
;
## method tweak (:pos(:$p)!)
;
## method tweak (:sigspace(:$s)!)
;
## method tweak (:ratchet(:$r)!)
;
## method tweak (:global(:$g)!)
;
## method tweak (:ignorecase(:$i)!)
;
## method tweak (:ignoremark(:$m)!)
;
## method tweak (:samecase(:$ii)!)
;
## method tweak (:samemark(:$mm)!)
;
## method tweak (:$nth!)
;
## method tweak (:st(:$nd)!)
;
## method tweak (:rd(:$th)!)
;
## method tweak (:$x!)
;
## method tweak (:$bytes!)
;
## method tweak (:$codes!)
;
## method tweak (:$graphs!)
;
## method tweak (:$chars!)
;
## method tweak (:$rw!)
;
## token category:metachar { <sym> }
sub category__S_000metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_000metachar', $retree) }
sub category__S_000metachar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000metachar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "metachar";
$self->_MATCHIFYr($S, "category__S_000metachar", $C->_EXACT("metachar"));
}
;
## token metachar {*}
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE metachar');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar';
}
else {
$x = 'ALTLTM metachar';
}
}
else {
$x = 'ALTLTM metachar';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "metachar", @gather);
};
@result;
}
;
## token category:sigmaybe { <sym> }
sub category__S_001sigmaybe__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigmaybe', $retree) }
sub category__S_001sigmaybe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001sigmaybe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigmaybe";
$self->_MATCHIFYr($S, "category__S_001sigmaybe", $C->_EXACT("sigmaybe"));
}
;
## token sigmaybe {*}
sub sigmaybe__PEEK { $_[0]->_AUTOLEXpeek('sigmaybe:*',$retree); }
sub sigmaybe {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE sigmaybe');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'sigmaybe') {
$C->deb("Fate passed to sigmaybe: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sigmaybe';
}
else {
$x = 'ALTLTM sigmaybe';
}
}
else {
$x = 'ALTLTM sigmaybe';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'sigmaybe:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("sigmaybe trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "sigmaybe", @gather);
};
@result;
}
;
## token category:backslash { <sym> }
sub category__S_002backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_002backslash', $retree) }
sub category__S_002backslash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002backslash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "backslash";
$self->_MATCHIFYr($S, "category__S_002backslash", $C->_EXACT("backslash"));
}
;
## token backslash {*}
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE backslash');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash';
}
else {
$x = 'ALTLTM backslash';
}
}
else {
$x = 'ALTLTM backslash';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "backslash", @gather);
};
@result;
}
;
## token category:assertion { <sym> }
sub category__S_003assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_003assertion', $retree) }
sub category__S_003assertion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003assertion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "assertion";
$self->_MATCHIFYr($S, "category__S_003assertion", $C->_EXACT("assertion"));
}
;
## token assertion {*}
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE assertion');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion';
}
else {
$x = 'ALTLTM assertion';
}
}
else {
$x = 'ALTLTM assertion';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "assertion", @gather);
};
@result;
}
;
## token category:quantifier { <sym> }
sub category__S_004quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_004quantifier', $retree) }
sub category__S_004quantifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004quantifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quantifier";
$self->_MATCHIFYr($S, "category__S_004quantifier", $C->_EXACT("quantifier"));
}
;
## token quantifier {*}
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE quantifier');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier';
}
else {
$x = 'ALTLTM quantifier';
}
}
else {
$x = 'ALTLTM quantifier';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "quantifier", @gather);
};
@result;
}
;
## token category:cclass_elem { <sym> }
sub category__S_005cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('category__S_005cclass_elem', $retree) }
sub category__S_005cclass_elem {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_005cclass_elem");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "cclass_elem";
$self->_MATCHIFYr($S, "category__S_005cclass_elem", $C->_EXACT("cclass_elem"));
}
;
## token cclass_elem {*}
sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem:*',$retree); }
sub cclass_elem {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE cclass_elem');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'cclass_elem') {
$C->deb("Fate passed to cclass_elem: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_elem';
}
else {
$x = 'ALTLTM cclass_elem';
}
}
else {
$x = 'ALTLTM cclass_elem';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("cclass_elem trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "cclass_elem", @gather);
};
@result;
}
;
## token category:mod_internal { <sym> }
sub category__S_006mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_006mod_internal', $retree) }
sub category__S_006mod_internal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_006mod_internal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod_internal";
$self->_MATCHIFYr($S, "category__S_006mod_internal", $C->_EXACT("mod_internal"));
}
;
## token mod_internal {*}
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE mod_internal');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal';
}
else {
$x = 'ALTLTM mod_internal';
}
}
else {
$x = 'ALTLTM mod_internal';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "mod_internal", @gather);
};
@result;
}
;
## token regex_infix {*}
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
my $self = shift;
my $subs;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact('RULE regex_infix');
my $S = $C->{'_pos'};

my @result = do {
my ($tag, $try);
my @try;
my $relex;
my $x;
if (my $fate = $C->{'_fate'}) {
if ($fate->[1] eq 'regex_infix') {
$C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT regex_infix';
}
else {
$x = 'ALTLTM regex_infix';
}
}
else {
$x = 'ALTLTM regex_infix';
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'regex_infix:*', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
}

$C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
last if $xact->[-2];  # committed?
}
$self->_MATCHIFYr($S, "regex_infix", @gather);
};
@result;
}
;
## token normspace {
sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace', $retree) }
sub normspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE normspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "normspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_0') {
$C->deb("Fate passed to normspace_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT normspace_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM normspace_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'normspace_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("normspace_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->ws)) { ($C) } else { () }

}
}))) {
$C
} else { () }

});
}
;
## token unsp { '\\' <?before \s | '#'> <.panic: "No unspace allowed in regex; if you meant to match th
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
$C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT unsp_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM unsp_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'unsp_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('" . substr($self->orig,$C->{'_pos'},1) . "') or use a backslashed form like \\x" . sprintf('%02x', ord(substr($self->orig,$C->{'_pos'},1)))))) {
$C
} else { () }

});
}
;
## rule nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

local %::RX = %::RX;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_ARRAY( qw< || | && & > ))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) { ($C) } else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->ws)
and ($C) = ($C->panic("Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex metacharacter " . $M->{0}->Str . " (must be quoted to match literally)")
})
and ($C) = ($C->ws)) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic("Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->quant_atom_list
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$::RX{'s'} or $M->{'term'}->Str =~ /\S/ })
}))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
$C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT termish_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM termish_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'termish_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[&|~]/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Null pattern not allowed"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\]\)\>]/)
}))) { ($C) } else { () }
}))) {
scalar(do {
my $c = substr($self->orig,$C->{'_pos'},1);
if ($::GOAL eq $c) {
$C->panic("Null pattern not allowed")}
else {
$C->panic("Unmatched closing $c")};
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->panic("Regex not terminated"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex metacharacter " . $M->{0}->Str . " (must be quoted to match literally)")
})) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex not terminated"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token quant_atom_list {
sub quant_atom_list__PEEK { $_[0]->_AUTOLEXpeek('quant_atom_list', $retree) }
sub quant_atom_list {
no warnings 'recursion';
my $self = shift;

local $::SIGOK = 0;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quant_atom_list");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];
$self->_MATCHIFYr($S, "quant_atom_list", $C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
}));
}
;
## token infixish {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))
and ($C) = ($C->_SUBSUMEblock('O', sub {
my $C = shift;
my $M = $C;
$M->{'regex_infix'}->{'O'}}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'regex_infix'}->{'sym'}})
} else { () }

});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
$C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT infixstopper_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM infixstopper_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'infixstopper_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\}\]]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\>[^>]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token regex_infix:sym<||> { <sym> <O(|%tight_or)>  }
sub regex_infix__S_007VertVert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_007VertVert', $retree) }
sub regex_infix__S_007VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_007VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "regex_infix__S_007VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }

});
}
;
## token regex_infix:sym<&&> { <sym> <O(|%tight_and)>  }
sub regex_infix__S_008AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_008AmpAmp', $retree) }
sub regex_infix__S_008AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_008AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "regex_infix__S_008AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and)
})
} else { () }

});
}
;
## token regex_infix:sym<|> { <sym> <O(|%junctive_or)>  }
sub regex_infix__S_009Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_009Vert', $retree) }
sub regex_infix__S_009Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_009Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "regex_infix__S_009Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or)
})
} else { () }

});
}
;
## token regex_infix:sym<&> { <sym> <O(|%junctive_and)>  }
sub regex_infix__S_010Amp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_010Amp', $retree) }
sub regex_infix__S_010Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_010Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "regex_infix__S_010Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and)
})
} else { () }

});
}
;
## token quantified_atom {
sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom', $retree) }
sub quantified_atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantified_atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];
$C->{'separator'} = [];
$C->{'sigfinal'} = [];
$C->{'sigmaybe'} = [];
$self->_MATCHIFYr($S, "quantified_atom", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->regex_infix)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_SUBSUMEr(['sigmaybe'], sub {
my $C = shift;
$C->sigmaybe
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))
and ($C) = ($C->_SUBSUMEr(['sigfinal','sigmaybe'], sub {
my $C = shift;
$C->sigmaybe
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['separator'], sub {
my $C = shift;
$C->separator
})
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token separator {
sub separator__PEEK { $_[0]->_AUTOLEXpeek('separator', $retree) }
sub separator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE separator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$self->_MATCHIFYr($S, "separator", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['how'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\%"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'separator_0') {
$C->deb("Fate passed to separator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT separator_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM separator_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'separator_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("separator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\%")
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'separator_1') {
$C->deb("Fate passed to separator_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT separator_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM separator_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'separator_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("separator_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[\<*.!^:]/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

});
}
;
## token sigmaybe:normspace {
sub sigmaybe__S_011normspace__PEEK { $_[0]->_AUTOLEXpeek('sigmaybe__S_011normspace', $retree) }
sub sigmaybe__S_011normspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigmaybe__S_011normspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "normspace";
$self->_MATCHIFYr($S, "sigmaybe__S_011normspace", do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::SIGOK})
}))) {
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
} else { () }

});
}
;
## token sigmaybe:sigwhite {
sub sigmaybe__S_012sigwhite__PEEK { $_[0]->_AUTOLEXpeek('sigmaybe__S_012sigwhite', $retree) }
sub sigmaybe__S_012sigwhite {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigmaybe__S_012sigwhite");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigwhite";
$self->_MATCHIFYr($S, "sigmaybe__S_012sigwhite", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::SIGOK})
}))
and ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
scalar(do {
$::SIGOK = 0 }, $C)
} else { () }

});
}
;
## token sigmaybe:unsp { <unsp> }
sub sigmaybe__S_013unsp__PEEK { $_[0]->_AUTOLEXpeek('sigmaybe__S_013unsp', $retree) }
sub sigmaybe__S_013unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigmaybe__S_013unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unsp";
$self->_MATCHIFYr($S, "sigmaybe__S_013unsp", $C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
}));
}
;
## token sigmaybe:nosp { <?before \S> }
sub sigmaybe__S_014nosp__PEEK { $_[0]->_AUTOLEXpeek('sigmaybe__S_014nosp', $retree) }
sub sigmaybe__S_014nosp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigmaybe__S_014nosp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "nosp";
$self->_MATCHIFYr($S, "sigmaybe__S_014nosp", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}));
}
;
## method SIGOK
sub SIGOK {
no warnings 'recursion';
my $self = shift;
$::SIGOK = $::RX{'s'};
$self ;
};
## token atom {
sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom', $retree) }
sub atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "atom", $C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_0') {
$C->deb("Fate passed to atom_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT atom_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM atom_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("atom_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\w/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))) {
$C->_COMMITLTM()
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}));
}
;
## token metachar:sym« > » { '>'<!before '>'> :: <fail> }
sub metachar__S_015Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_015Gt', $retree) }
sub metachar__S_015Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_015Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "metachar__S_015Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<&&>  { '&&' :: <fail> }
sub metachar__S_016AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_016AmpAmp', $retree) }
sub metachar__S_016AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_016AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "metachar__S_016AmpAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<&>   { '&'  :: <fail> }
sub metachar__S_017Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_017Amp', $retree) }
sub metachar__S_017Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_017Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "metachar__S_017Amp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<||>  { '||' :: <fail> }
sub metachar__S_018VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_018VertVert', $retree) }
sub metachar__S_018VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_018VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "metachar__S_018VertVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<|>   { '|'  :: <fail> }
sub metachar__S_019Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_019Vert', $retree) }
sub metachar__S_019Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_019Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "metachar__S_019Vert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<]>   { ']'  :: <fail> }
sub metachar__S_020Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_020Ket', $retree) }
sub metachar__S_020Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_020Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "metachar__S_020Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\]"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<)>   { ')'  :: <fail> }
sub metachar__S_021Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_021Thesis', $retree) }
sub metachar__S_021Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_021Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "metachar__S_021Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\)"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }

});
}
;
## token metachar:sym<;>   {
sub metachar__S_022Semi__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_022Semi', $retree) }
sub metachar__S_022Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_022Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "metachar__S_022Semi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\;"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Semicolon must be quoted"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->cursor_incr()
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Regex missing terminator (or semicolon must be quoted?)"))) {
$C
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex missing terminator"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token metachar:sym<{*}> { <onlystar=.sym> <?{ $*MULTINESS eq 'proto' }> }
sub metachar__S_023CurStarLy__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_023CurStarLy', $retree) }
sub metachar__S_023CurStarLy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_023CurStarLy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\*\}";
$self->_MATCHIFYr($S, "metachar__S_023CurStarLy", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['onlystar'], sub {
my $C = shift;
$C->_EXACT("\{\*\}")
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::MULTINESS eq 'proto' })
}))) {
$C
} else { () }

});
}
;
## token metachar:quant { <quantifier> <.sorry: "Quantifier quantifies nothing"> }
sub metachar__S_024quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_024quant', $retree) }
sub metachar__S_024quant {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_024quant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quant";
$self->_MATCHIFYr($S, "metachar__S_024quant", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))
and ($C) = ($C->sorry("Quantifier quantifies nothing"))) {
$C
} else { () }

});
}
;
## token metachar:sym<{ }> {
sub metachar__S_025Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_025Cur_Ly', $retree) }
sub metachar__S_025Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_025Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "metachar__S_025Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
<{ }> })
} else { () }

});
}
;
## token metachar:mod {
sub metachar__S_026mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_026mod', $retree) }
sub metachar__S_026mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_026mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "metachar__S_026mod", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'mod_internal'}->{'sym'}})
} else { () }

});
}
;
## token metachar:sym<-> {
sub metachar__S_027Minus__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_027Minus', $retree) }
sub metachar__S_027Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_027Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "metachar__S_027Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq ']' })
}))
and ($C) = ($C->sorry("Invalid regex metacharacter (must be quoted to match literally)"))) {
$C
} else { () }

});
}
;
## token metachar:sym<:> {
sub metachar__S_028Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_028Colon', $retree) }
sub metachar__S_028Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_028Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "metachar__S_028Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Backtrack control ':' does not seem to have a preceding atom to control"))) {
$C
} else { () }

});
}
;
## token metachar:sym<::> {
sub metachar__S_029ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_029ColonColon', $retree) }
sub metachar__S_029ColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_029ColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:";
$self->_MATCHIFYr($S, "metachar__S_029ColonColon", $C->_EXACT("\:\:"));
}
;
## token metachar:sym«::>» {
sub metachar__S_030ColonColonGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_030ColonColonGt', $retree) }
sub metachar__S_030ColonColonGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_030ColonColonGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\>";
$self->_MATCHIFYr($S, "metachar__S_030ColonColonGt", $C->_EXACT("\:\:\>"));
}
;
## token metachar:sym<:::> {
sub metachar__S_031ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_031ColonColonColon', $retree) }
sub metachar__S_031ColonColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_031ColonColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\:";
$self->_MATCHIFYr($S, "metachar__S_031ColonColonColon", $C->_EXACT("\:\:\:"));
}
;
## token metachar:sym<[ ]> {
sub metachar__S_032Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_032Bra_Ket', $retree) }
sub metachar__S_032Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_032Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "metachar__S_032Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed regex', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->SIGOK)
and ($C) = (scalar(do {
my $M = $C;
$C->check_old_cclass($M->{'nibbler'}->Str)}, $C))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
<[ ]>})
} else { () }

});
}
;
## token metachar:sym<(?: )> { '(?:' <.obs("(?: ... ) for grouping", "[ ... ]")> }
sub metachar__S_033ParenQuestionColon_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_033ParenQuestionColon_Thesis', $retree) }
sub metachar__S_033ParenQuestionColon_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_033ParenQuestionColon_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\?\:\ \)";
$self->_MATCHIFYr($S, "metachar__S_033ParenQuestionColon_Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\(\?\:"))
and ($C) = ($C->obs("(?: ... ) for grouping", "[ ... ]"))) {
$C
} else { () }

});
}
;
## token metachar:sym<(?= )> { '(?=' <.obs("(?= ... ) for lookahead", "<?before ... >")> }
sub metachar__S_034ParenQuestionEqual_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_034ParenQuestionEqual_Thesis', $retree) }
sub metachar__S_034ParenQuestionEqual_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_034ParenQuestionEqual_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\?\=\ \)";
$self->_MATCHIFYr($S, "metachar__S_034ParenQuestionEqual_Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\(\?\="))
and ($C) = ($C->obs("(?= ... ) for lookahead", "<?before ... >"))) {
$C
} else { () }

});
}
;
## token metachar:sym<(?! )> { '(?!' <.obs("(?! ... ) for lookahead", "<!before ... >")> }
sub metachar__S_035ParenQuestionBang_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_035ParenQuestionBang_Thesis', $retree) }
sub metachar__S_035ParenQuestionBang_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_035ParenQuestionBang_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\?\!\ \)";
$self->_MATCHIFYr($S, "metachar__S_035ParenQuestionBang_Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\(\?\!"))
and ($C) = ($C->obs("(?! ... ) for lookahead", "<!before ... >"))) {
$C
} else { () }

});
}
;
## token metachar:sym<(?\<= )> { '(?<=' <.obs("(?<= ... ) for lookbehind", "<?after ... >")> }
sub metachar__S_036ParenQuestionBackLtEqual_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_036ParenQuestionBackLtEqual_Thesis', $retree) }
sub metachar__S_036ParenQuestionBackLtEqual_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_036ParenQuestionBackLtEqual_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\?\\\<\=\ \)";
$self->_MATCHIFYr($S, "metachar__S_036ParenQuestionBackLtEqual_Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\(\?\<\="))
and ($C) = ($C->obs("(?<= ... ) for lookbehind", "<?after ... >"))) {
$C
} else { () }

});
}
;
## token metachar:sym<(?\<! )> { '(?<!' <.obs("(?<! ... ) for lookbehind", "<!after ... >")> }
sub metachar__S_037ParenQuestionBackLtBang_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_037ParenQuestionBackLtBang_Thesis', $retree) }
sub metachar__S_037ParenQuestionBackLtBang_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_037ParenQuestionBackLtBang_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\?\\\<\!\ \)";
$self->_MATCHIFYr($S, "metachar__S_037ParenQuestionBackLtBang_Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\(\?\<\!"))
and ($C) = ($C->obs("(?<! ... ) for lookbehind", "<!after ... >"))) {
$C
} else { () }

});
}
;
## token metachar:sym<( )> {
sub metachar__S_038Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_038Paren_Thesis', $retree) }
sub metachar__S_038Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_038Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "metachar__S_038Paren_Thesis", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'capture parens', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->SIGOK)) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
<( )>})
} else { () }

});
}
;
## token metachar:sym« <( » { '<(' <.SIGOK> }
sub metachar__S_039LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_039LtParen', $retree) }
sub metachar__S_039LtParen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_039LtParen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\(";
$self->_MATCHIFYr($S, "metachar__S_039LtParen", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\("))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym« )> » { ')>' <.SIGOK> }
sub metachar__S_040ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_040ThesisGt', $retree) }
sub metachar__S_040ThesisGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_040ThesisGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)\>";
$self->_MATCHIFYr($S, "metachar__S_040ThesisGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\)\>"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym« << » { '<<' <.SIGOK> }
sub metachar__S_041LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_041LtLt', $retree) }
sub metachar__S_041LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_041LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "metachar__S_041LtLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym« >> » { '>>' <.SIGOK> }
sub metachar__S_042GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_042GtGt', $retree) }
sub metachar__S_042GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_042GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "metachar__S_042GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>\>"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym< « > { '«' <.SIGOK> }
sub metachar__S_043Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_043Fre', $retree) }
sub metachar__S_043Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_043Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "metachar__S_043Fre", do {
my $C = $C;
if (($C) = ($C->_EXACT("«"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym< » > { '»' <.SIGOK> }
sub metachar__S_044Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_044Nch', $retree) }
sub metachar__S_044Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_044Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "metachar__S_044Nch", do {
my $C = $C;
if (($C) = ($C->_EXACT("»"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:qw {
sub metachar__S_045qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_045qw', $retree) }
sub metachar__S_045qw {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_045qw");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qw";
$self->_MATCHIFYr($S, "metachar__S_045qw", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\<\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym«< >» {
sub metachar__S_046Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_046Lt_Gt', $retree) }
sub metachar__S_046Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_046Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "metachar__S_046Lt_Gt", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang));
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'metachar', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<\\> { <sym> <backslash> <.SIGOK> }
sub metachar__S_047Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_047Back', $retree) }
sub metachar__S_047Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_047Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "metachar__S_047Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<.>  { <sym> <.SIGOK> }
sub metachar__S_048Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_048Dot', $retree) }
sub metachar__S_048Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_048Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "metachar__S_048Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<^^> { <sym> <.SIGOK> }
sub metachar__S_049CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_049CaretCaret', $retree) }
sub metachar__S_049CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_049CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "metachar__S_049CaretCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^\^"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<^>  { <sym> <.SIGOK> }
sub metachar__S_050Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_050Caret', $retree) }
sub metachar__S_050Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_050Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "metachar__S_050Caret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^"))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<$$> {
sub metachar__S_051DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_051DollarDollar', $retree) }
sub metachar__S_051DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_051DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "metachar__S_051DollarDollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\$"))
and ($C) = ($C->SIGOK)) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$\$" . $M->{0}->Str . " to deref var inside a regex", "\$(\$" . $M->{0}->Str . ")")
})) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token metachar:sym<$>  {
sub metachar__S_052Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_052Dollar', $retree) }
sub metachar__S_052Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_052Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "metachar__S_052Dollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_052Dollar_0') {
$C->deb("Fate passed to metachar__S_052Dollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT metachar__S_052Dollar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM metachar__S_052Dollar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_052Dollar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("metachar__S_052Dollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\|")
},
sub {
my $C=shift;
$C->_EXACT("\&")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\>")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<' '> { <?before "'"> [:lang(%*LANG<MAIN>) <quote>] <.SIGOK> }
sub metachar__S_053Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_053Single_Single', $retree) }
sub metachar__S_053Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_053Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "metachar__S_053Single_Single", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\'")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:sym<" "> { <?before '"'> [:lang(%*LANG<MAIN>) <quote>] <.SIGOK> }
sub metachar__S_054Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_054Double_Double', $retree) }
sub metachar__S_054Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_054Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "metachar__S_054Double_Double", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\"")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token metachar:var {
sub metachar__S_055var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_055var', $retree) }
sub metachar__S_055var {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = substr($self->orig,$self->{'_pos'},1);
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_055var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "var";
$self->_MATCHIFYr($S, "metachar__S_055var", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
})
}))
and ($C) = ($C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
$M->{'variable'}->Str}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['binding'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\s*+\=\s*+/))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

})
}))) {
scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) unless substr($M->{'sym'},1,1) eq '<' }, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (scalar(do {
my $M = $C;
$C->check_variable($M->{'variable'}) }, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.?+[\[\{\<]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->worry("Apparent subscript will be treated as regex"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }

}
};
@gather;
}
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:unspace { <?before \s> [ :lang( %*LANG<MAIN> ) <.ws> ] }
sub backslash__S_056unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_056unspace', $retree) }
sub backslash__S_056unspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_056unspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unspace";
$self->_MATCHIFYr($S, "backslash__S_056unspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ( $::LANG{'MAIN'} );
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->ws)) { ($C) } else { () }

}
}))) {
$C
} else { () }

});
}
;
## token backslash:sym<0> { '0' <!before <[0..7]> > <.SIGOK> }
sub backslash__S_0570__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0570', $retree) }
sub backslash__S_0570 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0570");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0570", do {
my $C = $C;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }
sub backslash__S_058A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_058A', $retree) }
sub backslash__S_058A {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_058A");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "A";
$self->_MATCHIFYr($S, "backslash__S_058A", do {
my $C = $C;
if (($C) = ($C->_EXACT("A"))
and ($C) = ($C->obs('\\A as beginning-of-string matcher', '^'))) {
$C
} else { () }

});
}
;
## token backslash:a { <sym> <.sorry: "\\a is allowed only in strings, not regexes"> }
sub backslash__S_059a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_059a', $retree) }
sub backslash__S_059a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_059a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_059a", do {
my $C = $C;
if (($C) = ($C->_EXACT("a"))
and ($C) = ($C->sorry("\\a is allowed only in strings, not regexes"))) {
$C
} else { () }

});
}
;
## token backslash:B { <sym> <.obs('\\B as word non-boundary', '<!wb>')> }
sub backslash__S_060B__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_060B', $retree) }
sub backslash__S_060B {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_060B");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "B";
$self->_MATCHIFYr($S, "backslash__S_060B", do {
my $C = $C;
if (($C) = ($C->_EXACT("B"))
and ($C) = ($C->obs('\\B as word non-boundary', '<!wb>'))) {
$C
} else { () }

});
}
;
## token backslash:b { <sym> <.obs('\\b as word boundary', '<?wb> (or either of « or »)')> }
sub backslash__S_061b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_061b', $retree) }
sub backslash__S_061b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_061b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_061b", do {
my $C = $C;
if (($C) = ($C->_EXACT("b"))
and ($C) = ($C->obs('\\b as word boundary', '<?wb> (or either of « or »)'))) {
$C
} else { () }

});
}
;
## token backslash:c { :i <sym> <charspec> <.SIGOK> }
sub backslash__S_062c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_062c', $retree) }
sub backslash__S_062c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_062c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_062c", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:c)/))
and ($C) = ($C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:d { :i <sym> <.SIGOK> }
sub backslash__S_063d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_063d', $retree) }
sub backslash__S_063d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_063d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_063d", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:d)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:e { :i <sym> <.SIGOK> }
sub backslash__S_064e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_064e', $retree) }
sub backslash__S_064e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_064e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_064e", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:e)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:f { :i <sym> <.SIGOK> }
sub backslash__S_065f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_065f', $retree) }
sub backslash__S_065f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_065f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_065f", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:f)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:h { :i <sym> <.SIGOK> }
sub backslash__S_066h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_066h', $retree) }
sub backslash__S_066h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_066h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_066h", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:h)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:n { :i <sym> <.SIGOK> }
sub backslash__S_067n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_067n', $retree) }
sub backslash__S_067n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_067n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_067n", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:n)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] <.SIGOK> }
sub backslash__S_068o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_068o', $retree) }
sub backslash__S_068o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_068o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_068o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_068o_0') {
$C->deb("Fate passed to backslash__S_068o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_068o_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_068o_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_068o_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_068o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:p {
sub backslash__S_069p__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_069p', $retree) }
sub backslash__S_069p {
no warnings 'recursion';
my $self = shift;

my $s;my $m;my $p;
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_069p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p";
$self->_MATCHIFYr($S, "backslash__S_069p", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[pP]/)
}))
and ($C) = (scalar(do {
my $M = $C;
$s = $M->{'sym'}->Str;
$m = $s lt 'a' ? '-' : '';
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))) {
scalar(do {
my $M = $C;
$p = $M->{0}->Str;
$C->obs("\\$s$p", '<' . $m . ":$p>");
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)
})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
$p = $M->{'param'}->Str;
$C->obs("\\$s\{$p\}", '<' . $m . ":$p>");
}, $C)
} else { () }

}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)
})
}))
and ($C) = ($C->_EXACT("\="))
and ($C) = ($C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[^\}])*+/)
})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
$p = $M->{'param'}->Str;
my $v = $M->{'val'}->Str;
$C->obs("\\$s\{$p=$v\}", '<' . $m . ":$p\('$v')>");
}, $C)
} else { () }

}
};
@gather;
}
}))) {
$C
} else { () }

});
}
;
## token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }
sub backslash__S_070Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_070Q', $retree) }
sub backslash__S_070Q {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_070Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "backslash__S_070Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->obs('\\Q as quotemeta', 'quotes or literal variable match'))) {
$C
} else { () }

});
}
;
## token backslash:r { :i <sym> <.SIGOK> }
sub backslash__S_071r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_071r', $retree) }
sub backslash__S_071r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_071r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_071r", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:r)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:s { :i <sym> <.SIGOK> }
sub backslash__S_072s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_072s', $retree) }
sub backslash__S_072s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_072s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_072s", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:s)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:t { :i <sym> <.SIGOK> }
sub backslash__S_073t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_073t', $retree) }
sub backslash__S_073t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_073t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_073t", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:t)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:v { :i <sym> <.SIGOK> }
sub backslash__S_074v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_074v', $retree) }
sub backslash__S_074v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_074v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_074v", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:v)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:w { :i <sym> <.SIGOK> }
sub backslash__S_075w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_075w', $retree) }
sub backslash__S_075w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_075w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_075w", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:w)/))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] <.SIGOK> }
sub backslash__S_076x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_076x', $retree) }
sub backslash__S_076x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_076x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_076x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_076x_0') {
$C->deb("Fate passed to backslash__S_076x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT backslash__S_076x_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM backslash__S_076x_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_076x_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("backslash__S_076x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }
sub backslash__S_077z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_077z', $retree) }
sub backslash__S_077z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_077z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "z";
$self->_MATCHIFYr($S, "backslash__S_077z", do {
my $C = $C;
if (($C) = ($C->_EXACT("z"))
and ($C) = ($C->obs('\\z as end-of-string matcher', '$'))) {
$C
} else { () }

});
}
;
## token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }
sub backslash__S_078Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_078Z', $retree) }
sub backslash__S_078Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_078Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "backslash__S_078Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->obs('\\Z as end-of-string matcher', '\\n?$'))) {
$C
} else { () }

});
}
;
## token backslash:misc { $<litchar>=(\W) <.SIGOK> }
sub backslash__S_079misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_079misc', $retree) }
sub backslash__S_079misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_079misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_079misc", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))
and ($C) = ($C->SIGOK)) {
$C
} else { () }

});
}
;
## token backslash:oldbackref { (<[1..9]>\d*) { my $d = $0.Str; $¢.sorryobs("the 1-based special form '
sub backslash__S_080oldbackref__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_080oldbackref', $retree) }
sub backslash__S_080oldbackref {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_080oldbackref");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oldbackref";
$self->_MATCHIFYr($S, "backslash__S_080oldbackref", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G[1-9]\d*+/)

})
}))) {
scalar(do {
my $M = $C;
my $d = $M->{0}->Str;
$C->sorryobs("the 1-based special form '\\$d' as a backreference", "the 0-based variable '\$" . ($d - 1) . "' instead" );
}, $C)
} else { () }

});
}
;
## token backslash:oops { <.sorry: "Unrecognized regex backslash sequence"> . }
sub backslash__S_081oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_081oops', $retree) }
sub backslash__S_081oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_081oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "backslash__S_081oops", do {
if (my ($C) = ($C->sorry("Unrecognized regex backslash sequence"))) {
$C->cursor_incr()
} else { () }

});
}
;
## token assertion:sym<...> { <sym> }
sub assertion__S_082DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_082DotDotDot', $retree) }
sub assertion__S_082DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_082DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "assertion__S_082DotDotDot", $C->_EXACT("\.\.\."));
}
;
## token assertion:sym<???> { <sym> }
sub assertion__S_083QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_083QuestionQuestionQuestion', $retree) }
sub assertion__S_083QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_083QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "assertion__S_083QuestionQuestionQuestion", $C->_EXACT("\?\?\?"));
}
;
## token assertion:sym<!!!> { <sym> }
sub assertion__S_084BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_084BangBangBang', $retree) }
sub assertion__S_084BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_084BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "assertion__S_084BangBangBang", $C->_EXACT("\!\!\!"));
}
;
## token assertion:sym<|> { <sym> [ <?before '>'> | <?before \w> <assertion> ] }  # assertion-like synt
sub assertion__S_085Vert__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_085Vert', $retree) }
sub assertion__S_085Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_085Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "assertion__S_085Vert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_085Vert_0') {
$C->deb("Fate passed to assertion__S_085Vert_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_085Vert_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_085Vert_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_085Vert_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_085Vert_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_086Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_086Question', $retree) }
sub assertion__S_086Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_086Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "assertion__S_086Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_086Question_0') {
$C->deb("Fate passed to assertion__S_086Question_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_086Question_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_086Question_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_086Question_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_086Question_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_087Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_087Bang', $retree) }
sub assertion__S_087Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_087Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "assertion__S_087Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_087Bang_0') {
$C->deb("Fate passed to assertion__S_087Bang_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_087Bang_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_087Bang_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_087Bang_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_087Bang_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }
sub assertion__S_088Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_088Star', $retree) }
sub assertion__S_088Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_088Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "assertion__S_088Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_088Star_0') {
$C->deb("Fate passed to assertion__S_088Star_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_088Star_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_088Star_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_088Star_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_088Star_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:sym<{ }> { <embeddedblock> }
sub assertion__S_089Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_089Cur_Ly', $retree) }
sub assertion__S_089Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_089Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "assertion__S_089Cur_Ly", $C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}));
}
;
## token assertion:variable {
sub assertion__S_090variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_090variable', $retree) }
sub assertion__S_090variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_090variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "assertion__S_090variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
}))) {
$C
} else { () }

});
}
;
## token assertion:method {
sub assertion__S_091method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_091method', $retree) }
sub assertion__S_091method {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_091method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "assertion__S_091method", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_091method_0') {
$C->deb("Fate passed to assertion__S_091method_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_091method_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_091method_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_091method_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_091method_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:name { [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
sub assertion__S_092name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_092name', $retree) }
sub assertion__S_092name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_092name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'assertion'} = [];
$C->{'nibbler'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "assertion__S_092name", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_092name_0') {
$C->deb("Fate passed to assertion__S_092name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_092name_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_092name_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_092name_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_092name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
my $n = $M->{'longname'}->Str;
if ($n eq 'before' or $n eq 'after') {
$C->panic("$n requires an argument")};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\="))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }

}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Assertion call missing right parenthesis"))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token assertion:sym<:> { <?before ':'> <cclass_expr> }
sub assertion__S_093Colon__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_093Colon', $retree) }
sub assertion__S_093Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_093Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "assertion__S_093Colon", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['cclass_expr'], sub {
my $C = shift;
$C->cclass_expr
})
} else { () }

});
}
;
## token assertion:sym<[> { <?before '['> <cclass_expr> }
sub assertion__S_094Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_094Bra', $retree) }
sub assertion__S_094Bra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_094Bra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[";
$self->_MATCHIFYr($S, "assertion__S_094Bra", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['cclass_expr'], sub {
my $C = shift;
$C->cclass_expr
})
} else { () }

});
}
;
## token assertion:sym<+> { <?before '+'> <cclass_expr> }
sub assertion__S_095Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_095Plus', $retree) }
sub assertion__S_095Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_095Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "assertion__S_095Plus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['cclass_expr'], sub {
my $C = shift;
$C->cclass_expr
})
} else { () }

});
}
;
## token assertion:sym<-> { <?before '-'> <cclass_expr> }
sub assertion__S_096Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_096Minus', $retree) }
sub assertion__S_096Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_096Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "assertion__S_096Minus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['cclass_expr'], sub {
my $C = shift;
$C->cclass_expr
})
} else { () }

});
}
;
## token assertion:sym<.> { <sym> }
sub assertion__S_097Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_097Dot', $retree) }
sub assertion__S_097Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_097Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "assertion__S_097Dot", $C->_EXACT("\."));
}
;
## token assertion:sym<,> { <sym> }
sub assertion__S_098Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_098Comma', $retree) }
sub assertion__S_098Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_098Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "assertion__S_098Comma", $C->_EXACT("\,"));
}
;
## token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }
sub assertion__S_099TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_099TildeTilde', $retree) }
sub assertion__S_099TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_099TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "assertion__S_099TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_099TildeTilde_0') {
$C->deb("Fate passed to assertion__S_099TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT assertion__S_099TildeTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM assertion__S_099TildeTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_099TildeTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("assertion__S_099TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token assertion:bogus { <.panic: "Unrecognized regex assertion"> }
sub assertion__S_100bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_100bogus', $retree) }
sub assertion__S_100bogus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_100bogus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "bogus";
$self->_MATCHIFYr($S, "assertion__S_100bogus", $C->panic("Unrecognized regex assertion"));
}
;
## token sign { '+' | '-' | <?> }
sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign', $retree) }
sub sign {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sign");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sign", do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_0') {
$C->deb("Fate passed to sign_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT sign_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM sign_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'sign_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("sign_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\+")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

});
}
;
## token cclass_expr {
sub cclass_expr__PEEK { $_[0]->_AUTOLEXpeek('cclass_expr', $retree) }
sub cclass_expr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_expr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_union'} = [];
$C->{'op'} = [];
$self->_MATCHIFYr($S, "cclass_expr", do {
my $C = $C;
if (($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))) {
$C->_REPSEPr( sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['op'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_expr_0') {
$C->deb("Fate passed to cclass_expr_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_expr_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM cclass_expr_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_expr_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("cclass_expr_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\|")
},
sub {
my $C=shift;
$C->_EXACT("\^")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
})
}))) { ($C) } else { () }
}, sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_union'], sub {
my $C = shift;
$C->cclass_union
})
})
} else { () }

});
}
;
## token cclass_union {
sub cclass_union__PEEK { $_[0]->_AUTOLEXpeek('cclass_union', $retree) }
sub cclass_union {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_union");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_add'} = [];
$C->{'op'} = [];
$self->_MATCHIFYr($S, "cclass_union", do {
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))) {
$C->_REPSEPr( sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['op'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_EXACT("\&")
})
})
}))) { ($C) } else { () }
}, sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_add'], sub {
my $C = shift;
$C->cclass_add
})
})
} else { () }

});
}
;
## token cclass_add {
sub cclass_add__PEEK { $_[0]->_AUTOLEXpeek('cclass_add', $retree) }
sub cclass_add {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_add");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{'op'} = [];
$self->_MATCHIFYr($S, "cclass_add", do {
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))) {
$C->_REPSEPr( sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['op'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_add_0') {
$C->deb("Fate passed to cclass_add_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_add_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM cclass_add_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_add_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("cclass_add_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\+")
},
sub {
my $C=shift;
$C->_EXACT("\-")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}, sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }

});
}
;
## token cclass_elem:name {
sub cclass_elem__S_101name__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem__S_101name', $retree) }
sub cclass_elem__S_101name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem__S_101name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "name";
$self->_MATCHIFYr($S, "cclass_elem__S_101name", do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token cclass_elem:sym<[ ]> {
sub cclass_elem__S_102Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem__S_102Bra_Ket', $retree) }
sub cclass_elem__S_102Bra_Ket {
no warnings 'recursion';
my $self = shift;

local $::CCSTATE = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem__S_102Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "cclass_elem__S_102Bra_Ket", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1)->unbalanced("]"))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'character class element', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token cclass_elem:sym<( )> {
sub cclass_elem__S_103Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem__S_103Paren_Thesis', $retree) }
sub cclass_elem__S_103Paren_Thesis {
no warnings 'recursion';
my $self = shift;

local $::CCSTATE = '';
local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem__S_103Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "cclass_elem__S_103Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['cclass_expr'], sub {
my $C = shift;
$C->cclass_expr
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'character class element', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token cclass_elem:property {
sub cclass_elem__S_104property__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem__S_104property', $retree) }
sub cclass_elem__S_104property {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem__S_104property");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "property";
$self->_MATCHIFYr($S, "cclass_elem__S_104property", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token cclass_elem:quote {
sub cclass_elem__S_105quote__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem__S_105quote', $retree) }
sub cclass_elem__S_105quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem__S_105quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "cclass_elem__S_105quote", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem__S_105quote_0') {
$C->deb("Fate passed to cclass_elem__S_105quote_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT cclass_elem__S_105quote_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM cclass_elem__S_105quote_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem__S_105quote_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("cclass_elem__S_105quote_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\"")
},
sub {
my $C=shift;
$C->_EXACT("\'")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};

})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }

});
}
;
## token mod_arg { :dba('modifier argument') '(' ~ ')' [:lang(%*LANG<MAIN>) <semilist> ] }
sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg', $retree) }
sub mod_arg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_arg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "mod_arg", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {    my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'modifier argument', $goalpos))) { ($C) } else { () }

}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'anon'|'constant'|'temp'|'let'] \s
sub mod_internal__S_106Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_106Colonmy', $retree) }
sub mod_internal__S_106Colonmy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_106Colonmy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:my";
$self->_MATCHIFYr($S, "mod_internal__S_106Colonmy", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_106Colonmy_0') {
$C->deb("Fate passed to mod_internal__S_106Colonmy_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_106Colonmy_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_106Colonmy_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_106Colonmy_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_106Colonmy_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("my")
},
sub {
my $C=shift;
$C->_EXACT("state")
},
sub {
my $C=shift;
$C->_EXACT("our")
},
sub {
my $C=shift;
$C->_EXACT("anon")
},
sub {
my $C=shift;
$C->_EXACT("constant")
},
sub {
my $C=shift;
$C->_EXACT("temp")
},
sub {
my $C=shift;
$C->_EXACT("let")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_PATTERN(qr/\G\s/)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
})
} else { () }

}
}))) {
$C
} else { () }

});
}
;
## token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase'] » { %*RX<i> = 1 } }
sub mod_internal__S_107Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_107Coloni', $retree) }
sub mod_internal__S_107Coloni {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_107Coloni");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i";
$self->_MATCHIFYr($S, "mod_internal__S_107Coloni", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_107Coloni_0') {
$C->deb("Fate passed to mod_internal__S_107Coloni_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_107Coloni_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_107Coloni_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_107Coloni_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_107Coloni_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase'] » { %*RX<i> = 0 } }
sub mod_internal__S_108ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_108ColonBangi', $retree) }
sub mod_internal__S_108ColonBangi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_108ColonBangi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!i";
$self->_MATCHIFYr($S, "mod_internal__S_108ColonBangi", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_108ColonBangi_0') {
$C->deb("Fate passed to mod_internal__S_108ColonBangi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_108ColonBangi_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_108ColonBangi_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_108ColonBangi_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_108ColonBangi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!i")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { %*RX<i> = eval $<mod_arg>.St
sub mod_internal__S_109ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_109ColoniParen_Thesis', $retree) }
sub mod_internal__S_109ColoniParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_109ColoniParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_109ColoniParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_109ColoniParen_Thesis_0') {
$C->deb("Fate passed to mod_internal__S_109ColoniParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_109ColoniParen_Thesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_109ColoniParen_Thesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_109ColoniParen_Thesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_109ColoniParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { %*RX<i> = $0 } }
sub mod_internal__S_110Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_110Colon0i', $retree) }
sub mod_internal__S_110Colon0i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_110Colon0i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0i";
$self->_MATCHIFYr($S, "mod_internal__S_110Colon0i", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_110Colon0i_0') {
$C->deb("Fate passed to mod_internal__S_110Colon0i_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_110Colon0i_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_110Colon0i_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_110Colon0i_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_110Colon0i_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("i")
},
sub {
my $C=shift;
$C->_EXACT("ignorecase")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:m>    { $<sym>=[':m'|':ignoremark'] » { %*RX<m> = 1 } }
sub mod_internal__S_111Colonm__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_111Colonm', $retree) }
sub mod_internal__S_111Colonm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_111Colonm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:m";
$self->_MATCHIFYr($S, "mod_internal__S_111Colonm", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_111Colonm_0') {
$C->deb("Fate passed to mod_internal__S_111Colonm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_111Colonm_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_111Colonm_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_111Colonm_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_111Colonm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:m")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoremark")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'m'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!m>   { $<sym>=[':!m'|':!ignoremark'] » { %*RX<m> = 0 } }
sub mod_internal__S_112ColonBangm__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_112ColonBangm', $retree) }
sub mod_internal__S_112ColonBangm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_112ColonBangm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!m";
$self->_MATCHIFYr($S, "mod_internal__S_112ColonBangm", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_112ColonBangm_0') {
$C->deb("Fate passed to mod_internal__S_112ColonBangm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_112ColonBangm_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_112ColonBangm_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_112ColonBangm_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_112ColonBangm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!m")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignoremark")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'m'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:m( )> { $<sym>=[':m'|':ignoremark'] <mod_arg> { %*RX<m> = eval $<mod_arg>.St
sub mod_internal__S_113ColonmParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_113ColonmParen_Thesis', $retree) }
sub mod_internal__S_113ColonmParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_113ColonmParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:m\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_113ColonmParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_113ColonmParen_Thesis_0') {
$C->deb("Fate passed to mod_internal__S_113ColonmParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_113ColonmParen_Thesis_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_113ColonmParen_Thesis_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_113ColonmParen_Thesis_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_113ColonmParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:m")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoremark")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'m'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0m>   { ':' (\d+) ['m'|'ignoremark'] { %*RX<m> = $0 } }
sub mod_internal__S_114Colon0m__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_114Colon0m', $retree) }
sub mod_internal__S_114Colon0m {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_114Colon0m");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0m";
$self->_MATCHIFYr($S, "mod_internal__S_114Colon0m", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_114Colon0m_0') {
$C->deb("Fate passed to mod_internal__S_114Colon0m_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_114Colon0m_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_114Colon0m_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_114Colon0m_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_114Colon0m_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("m")
},
sub {
my $C=shift;
$C->_EXACT("ignoremark")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'m'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:s>    { ':s' 'igspace'? » { %*RX<s> = 1 } }
sub mod_internal__S_115Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_115Colons', $retree) }
sub mod_internal__S_115Colons {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_115Colons");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s";
$self->_MATCHIFYr($S, "mod_internal__S_115Colons", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!s>   { ':!s' 'igspace'? » { %*RX<s> = 0 } }
sub mod_internal__S_116ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_116ColonBangs', $retree) }
sub mod_internal__S_116ColonBangs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_116ColonBangs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!s";
$self->_MATCHIFYr($S, "mod_internal__S_116ColonBangs", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { %*RX<s> = eval $<mod_arg>.Str } }
sub mod_internal__S_117ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_117ColonsParen_Thesis', $retree) }
sub mod_internal__S_117ColonsParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_117ColonsParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_117ColonsParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'s'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'? » { %*RX<s> = $0 } }
sub mod_internal__S_118Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_118Colon0s', $retree) }
sub mod_internal__S_118Colon0s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_118Colon0s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0s";
$self->_MATCHIFYr($S, "mod_internal__S_118Colon0s", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gs(?:igspace)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'s'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:r>    { ':r' 'atchet'? » { %*RX<r> = 1 } }
sub mod_internal__S_119Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_119Colonr', $retree) }
sub mod_internal__S_119Colonr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_119Colonr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r";
$self->_MATCHIFYr($S, "mod_internal__S_119Colonr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 1 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:!r>   { ':!r' 'atchet'? » { %*RX<r> = 0 } }
sub mod_internal__S_120ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_120ColonBangr', $retree) }
sub mod_internal__S_120ColonBangr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_120ColonBangr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!r";
$self->_MATCHIFYr($S, "mod_internal__S_120ColonBangr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 0 }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:r( )> { ':r' 'atchet'? » <mod_arg> { %*RX<r> = eval $<mod_arg>.Str } }
sub mod_internal__S_121ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_121ColonrParen_Thesis', $retree) }
sub mod_internal__S_121ColonrParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_121ColonrParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_121ColonrParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'r'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'? » { %*RX<r> = $0 } }
sub mod_internal__S_122Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_122Colon0r', $retree) }
sub mod_internal__S_122Colon0r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_122Colon0r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0r";
$self->_MATCHIFYr($S, "mod_internal__S_122Colon0r", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gr(?:atchet)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'r'} = $M->{0} }, $C)
} else { () }

});
}
;
## token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] <.require_P5> [ :lang( $¢.cursor_fresh( %*LAN
sub mod_internal__S_123ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_123ColonPerl5', $retree) }
sub mod_internal__S_123ColonPerl5 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_123ColonPerl5");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:Perl5";
$self->_MATCHIFYr($S, "mod_internal__S_123ColonPerl5", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_123ColonPerl5_0') {
$C->deb("Fate passed to mod_internal__S_123ColonPerl5_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_123ColonPerl5_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_123ColonPerl5_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_123ColonPerl5_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_123ColonPerl5_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:Perl5")
},
sub {
my $C=shift;
$C->_EXACT("\:P5")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->require_P5)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
$C
} else { () }

});
}
;
## token mod_internal:p6adv {
sub mod_internal__S_124p6adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_124p6adv', $retree) }
sub mod_internal__S_124p6adv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_124p6adv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p6adv";
$self->_MATCHIFYr($S, "mod_internal__S_124p6adv", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_124p6adv_0') {
$C->deb("Fate passed to mod_internal__S_124p6adv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT mod_internal__S_124p6adv_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM mod_internal__S_124p6adv_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_124p6adv_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("mod_internal__S_124p6adv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("dba")
},
sub {
my $C=shift;
$C->_EXACT("lang")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C->_PATTERN(qr/\G\b/)
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
$C->_SUBSUMEblock('sym', sub {
my $C = shift;
my $M = $C;
':' . $M->{'quotepair'}->{'k'}})
} else { () }

});
}
;
## token mod_internal:oops { {} (':'\w+) <.sorry: "Unrecognized regex modifier " ~ $0.Str > }
sub mod_internal__S_125oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_125oops', $retree) }
sub mod_internal__S_125oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_125oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "mod_internal__S_125oops", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex modifier " . $M->{0}->Str )
})) {
$C
} else { () }

});
}
;
## token quantifier:sym<*>  { <sym> <quantmod> }
sub quantifier__S_126Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_126Star', $retree) }
sub quantifier__S_126Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_126Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "quantifier__S_126Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<+>  { <sym> <quantmod> }
sub quantifier__S_127Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_127Plus', $retree) }
sub quantifier__S_127Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_127Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "quantifier__S_127Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<?>  { <sym> <quantmod> }
sub quantifier__S_128Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_128Question', $retree) }
sub quantifier__S_128Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_128Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "quantifier__S_128Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }

});
}
;
## token quantifier:sym<:>  { <sym> {} <?before \s> }
sub quantifier__S_129Colon__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_129Colon', $retree) }
sub quantifier__S_129Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_129Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "quantifier__S_129Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }

});
}
;
## token quantifier:sym<**> { '**' :: <normspace>? <quantmod> <normspace>?
sub quantifier__S_130StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_130StarStar', $retree) }
sub quantifier__S_130StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_130StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'1'} = [];
$C->{'normspace'} = [];
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "quantifier__S_130StarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_130StarStar_0') {
$C->deb("Fate passed to quantifier__S_130StarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_130StarStar_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_130StarStar_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_130StarStar_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_130StarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\d++\s++\.\./))
and ($C) = ($C->panic("Spaces not allowed in bare range"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_130StarStar_1') {
$C->deb("Fate passed to quantifier__S_130StarStar_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_130StarStar_1';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_130StarStar_1'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_130StarStar_1', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_130StarStar_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['1'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))) {
scalar(do {
my $M = $C;
$C->panic("Empty range") if $M->{0}->Str > $M->{1}->[0]->Str }, $C)
} else { () }
},
sub {
my $C=shift;
$C->_EXACT("\*")
},
sub {
my $C=shift;
if (my ($C) = ($C->panic("Malformed range"))) { ($C) } else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
}))) {
scalar(do {
my $M = $C;
$C->worryobs("atom ** " . $M->{'quantified_atom'}->Str . " as separator", "atom +% " . $M->{'quantified_atom'}->Str, " nowadays")}, $C)
} else { () }
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) {
$C
} else { () }

});
}
;
## token quantifier:sym<~> {
sub quantifier__S_131Tilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_131Tilde', $retree) }
sub quantifier__S_131Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_131Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{'quantified_atom'} = [];
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "quantifier__S_131Tilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

});
}
;
## token quantifier:sym<~~> {
sub quantifier__S_132TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_132TildeTilde', $retree) }
sub quantifier__S_132TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_132TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "quantifier__S_132TildeTilde", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_132TildeTilde_0') {
$C->deb("Fate passed to quantifier__S_132TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantifier__S_132TildeTilde_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantifier__S_132TildeTilde_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_132TildeTilde_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantifier__S_132TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\!\~\~")
},
sub {
my $C=shift;
$C->_EXACT("\~\~")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))
and ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

});
}
;
## token quantmod { ':'? [ '?' | '!' | '+' ]? }
sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod', $retree) }
sub quantmod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantmod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quantmod", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:?+/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
my ($tag, $try);
my @try;
my $relex;

my $fate;
my $x;
if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_0') {
$C->deb("Fate passed to quantmod_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
($C->{'_fate'}, $tag, $try) = @$fate;
@try = ($try);
$x = 'ALT quantmod_0';    # some outer ltm is controlling us
}
else {
$x = 'ALTLTM quantmod_0'; # we are top level ltm
}
my $C = $C->cursor_xact($x);
my $xact = $C->{_xact};

my @gather = ();
for (;;) {
unless (@try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_0', $retree);
@try = $relex->($C) or last;
}
$try = shift(@try) // next;

if (ref $try) {
($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
}

$C->deb("quantmod_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\?")
},
sub {
my $C=shift;
$C->_EXACT("\!")
},
sub {
my $C=shift;
$C->_EXACT("\+")
}
)[$try])->($C);
last if @gather;
last if $xact->[-2];  # committed?
}
@gather;
};
}))) { ($C) } else { () }
})
} else { () }

});
}
;
## token quantifier:sym<{N,M}> {
sub quantifier__S_133CurNCommaMLy__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_133CurNCommaMLy', $retree) }
sub quantifier__S_133CurNCommaMLy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_133CurNCommaMLy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{N\,M\}";
$self->_MATCHIFYr($S, "quantifier__S_133CurNCommaMLy", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_SUBSUMEr(['1'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\,?+/)

})
}))
and ($C) = ($C->_SUBSUMEr(['2'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d*+/)

})
}))
and ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
my $all = substr($self->orig, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'});
my $repl = length($M->{1}->Str) ?
($M->{0}->Str . '..' . ($M->{2}->Str || '*')) : $M->{0}->Str;
$C->sorryobs($all . " as general quantifier", 'X**' . $repl);
}, $C)
} else { () }

});
}
;
moose_around tweak  => sub {
my $orig = shift;
no warnings 'recursion';
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{Perl5} || exists $args{P5};
my $P5 = exists $args{Perl5} ? delete $args{Perl5} : exists $args{P5} ? delete $args{P5} : undef;
$self->require_P5;
$self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) ;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{overlap} || exists $args{ov};
my $ov = exists $args{overlap} ? delete $args{overlap} : exists $args{ov} ? delete $args{ov} : undef;
$::RX{'ov'} = $ov;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{exhaustive} || exists $args{ex};
my $ex = exists $args{exhaustive} ? delete $args{exhaustive} : exists $args{ex} ? delete $args{ex} : undef;
$::RX{'ex'} = $ex;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{continue} || exists $args{c};
my $c = exists $args{continue} ? delete $args{continue} : exists $args{c} ? delete $args{c} : undef;
$::RX{'c'} = $c;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{pos} || exists $args{p};
my $p = exists $args{pos} ? delete $args{pos} : exists $args{p} ? delete $args{p} : undef;
$::RX{'p'} = $p;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{sigspace} || exists $args{s};
my $s = exists $args{sigspace} ? delete $args{sigspace} : exists $args{s} ? delete $args{s} : undef;
$::RX{'s'} = $s;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ratchet} || exists $args{r};
my $r = exists $args{ratchet} ? delete $args{ratchet} : exists $args{r} ? delete $args{r} : undef;
$::RX{'r'} = $r;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{global} || exists $args{g};
my $g = exists $args{global} ? delete $args{global} : exists $args{g} ? delete $args{g} : undef;
$::RX{'g'} = $g;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ignorecase} || exists $args{i};
my $i = exists $args{ignorecase} ? delete $args{ignorecase} : exists $args{i} ? delete $args{i} : undef;
$::RX{'i'} = $i;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{ignoremark} || exists $args{m};
my $m = exists $args{ignoremark} ? delete $args{ignoremark} : exists $args{m} ? delete $args{m} : undef;
$::RX{'m'} = $m;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{samecase} || exists $args{ii};
my $ii = exists $args{samecase} ? delete $args{samecase} : exists $args{ii} ? delete $args{ii} : undef;
$::RX{'ii'} = $ii;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{samemark} || exists $args{mm};
my $mm = exists $args{samemark} ? delete $args{samemark} : exists $args{mm} ? delete $args{mm} : undef;
$::RX{'mm'} = $mm;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{nth};
my $nth = exists $args{nth} ? delete $args{nth} : undef;
$::RX{'nth'} = $nth;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{st} || exists $args{nd};
my $nd = exists $args{st} ? delete $args{st} : exists $args{nd} ? delete $args{nd} : undef;
$::RX{'nth'} = $nd;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{rd} || exists $args{th};
my $th = exists $args{rd} ? delete $args{rd} : exists $args{th} ? delete $args{th} : undef;
$::RX{'nth'} = $th;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$::RX{'x'} = $x;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{bytes};
my $bytes = exists $args{bytes} ? delete $args{bytes} : undef;
$::RX{'bytes'} = $bytes;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{codes};
my $codes = exists $args{codes} ? delete $args{codes} : undef;
$::RX{'codes'} = $codes;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{graphs};
my $graphs = exists $args{graphs} ? delete $args{graphs} : undef;
$::RX{'graphs'} = $graphs;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{chars};
my $chars = exists $args{chars} ? delete $args{chars} : undef;
$::RX{'chars'} = $chars;
$self;
};
}
{
local @_ = @_;
return scalar do { # work around #38809
my $self = shift;
my %args = @_;
last unless exists $args{rw};
my $rw = exists $args{rw} ? delete $args{rw} : undef;
$::RX{'rw'} = $rw;
$self;
};
}
$orig->(@_);
};

1; };
## method require_P5
sub require_P5 {
no warnings 'recursion';
my $self = shift;
require STD_P5;
$self;
};
## method require_P6
sub require_P6 {
no warnings 'recursion';
my $self = shift;
require STD_P6;
$self;
};
## method newlex ($needsig = 0)
sub newlex {
no warnings 'recursion';
my $self = shift;
my $needsig = @_ ? shift() : 0;
my $oid = $::CURLEX->id;
$ALL->{$oid} == $::CURLEX or die "internal error: current lex id is invalid";
my $line = $self->lineof($self->{'_pos'});
my $id;
if ($::NEWLEX) {
$::NEWLEX->{'OUTER::'} = $::CURLEX->idref;
$::CURLEX = $::NEWLEX;
$::NEWLEX = 0;
$id = $::CURLEX->id;
}
else {
$id = 'MY:file<' . $::FILE->{'name'} . '>:line(' . $line . '):pos(' . $self->{'_pos'} . ')';
$::CURLEX = Stash->new(
'OUTER::' => [$oid],
'!file' => $::FILE, '!line' => $line,
'!id' => [$id],
);
};
$::CURLEX->{'!NEEDSIG'} = 1 if $needsig;
$::CURLEX->{'!IN_DECL'} = $::IN_DECL if $::IN_DECL;
$ALL->{$id} = $::CURLEX;
$self->{'LEX'} = $::CURLEX;
$::DECLARAND->{'curlex'} = $::CURLEX if $::DECLARAND;
$self;
};
## method finishlex
sub finishlex {
no warnings 'recursion';
my $self = shift;
my $line = $self->lineof($self->{'_pos'});
$::CURLEX->{'$_'} //= NAME->new( name => '$_', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::CURLEX->{'$/'} //= NAME->new( name => '$/', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::CURLEX->{'$!'} //= NAME->new( name => '$!', file => $::FILE, line => $line, dynamic => 1, scope => 'my' );
$::SIGNUM = 0;
$self;
};
## method getsig
sub getsig {
no warnings 'recursion';
my $self = shift;
my $pv = $::CURLEX->{'%?PLACEHOLDERS'};
my $sig;
if (delete $::CURLEX->{'!NEEDSIG'}) {
if ($pv) {
my $h_ = (delete $pv->{'%_'});
my $a_ = (delete $pv->{'@_'});
$sig = join ', ', sort {
substr($a,1) cmp substr($b,1) }  keys %$pv;
$sig .= ', *@_' if $a_;
$sig .= ', *%_' if $h_;
}
else {
$sig = '$_ is ref = OUTER::<$_>'};
$::CURLEX->{'$?SIGNATURE'} = $sig;
}
else {
$sig = $::CURLEX->{'$?SIGNATURE'}};
$self->{'sig'} = $self->makestr(TEXT => $sig);
$self->{'lex'} = $::CURLEX->idref;
if (($::DECLARAND->{'mult'}//'') ne 'proto') {
for (keys %$::CURLEX) {
my $desc = $::CURLEX->{$_};
next unless $_ =~ m/(\$|\@|\%|\&)\w/;
next if $_ eq '$_' or $_ eq '@_' or $_ eq '%_';
next if $desc->{'used'};
next if $desc->{'rebind'};
next if $desc->{'dynamic'};
my $scope = $desc->{'scope'} // 'my';
next if $scope eq 'our';
next if $scope eq 'state';
next if $desc->{'stub'};
my $pos = $desc->{'declaredat'} // $self->{'_pos'};
$self->cursor($pos)->worry("$_ is declared but not used");
}
};
$self;
};
## method getdecl
sub getdecl {
no warnings 'recursion';
my $self = shift;
$self->{'decl'} = $::DECLARAND;
$self;
};
## method is_name ($n, $curlex = $*CURLEX)
sub is_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("is_name $name") if $::DEBUG & DEBUG::symtab;
my $curpkg = $::CURPKG;
return 1 if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outlexid = $curpkg->[0];
return 0 unless $outlexid;
$curpkg = $ALL->{$outlexid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
$self->deb("Looking for $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
my $lex = $curlex;
while ($lex) {
$self->deb("Looking in ", $lex->id) if $::DEBUG & DEBUG::symtab;
if ($lex->{$name}) {
$self->deb("Found $name in ", $lex->id) if $::DEBUG & DEBUG::symtab;
$lex->{$name}->{'used'} = 1;
return 1;
};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return 1 if $curpkg->{$name};
return 1 if $::GLOBAL->{$name};
$self->deb("$name not found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method find_stash ($n, $curlex = $*CURLEX)
sub find_stash {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("find_stash $name") if $::DEBUG & DEBUG::symtab;
return () if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'COMPILING::';
return () if $components[0] eq 'CALLER::';
return () if $components[0] eq 'CONTEXT::';
if ($curlex = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curlex = $::GLOBAL;
};
while (@components > 1) {
my $lex = shift @components;
$curlex = $curlex->{$lex};
return () unless $curlex;
eval {
my $outlexid = $curlex->[0];
return 0 unless $outlexid;
$curlex = $ALL->{$outlexid};
return () unless $curlex;
};
$self->deb("Found $lex okay") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
return $curlex if $name eq '';
my $lex = $curlex;
while ($lex) {
return $_ if $_ = $lex->{$name};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return $_ if $_ = $curlex->{$name};
return $_ if $_ = $::GLOBAL->{$name};
return ();
};
## method find_top_pkg ($name)
sub find_top_pkg {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$self->deb("find_top_pkg $name") if $::DEBUG & DEBUG::symtab;
$name .= '::' unless $name =~ /\:\:$/;
if ($name eq 'OUR::') {
return $::CURPKG}
elsif ($name eq 'MY::') {
return $::CURLEX}
elsif ($name eq 'OUTER::') {
return $ALL->{$::CURLEX->{'OUTER::'}->[0]}}
elsif ($name eq 'CORE::') {
return $::CORE}
elsif ($name eq 'SETTING::') {
return $::SETTING}
elsif ($name eq 'UNIT::') {
return $::UNIT};
my $lex = $::CURLEX;
while ($lex) {
return $lex->{$name} if $lex->{$name};
my $oid = $lex->{'OUTER::'}->[0] || last;
$lex = $ALL->{$oid};
}
;
return 0;
};
## method add_name ($name)
sub add_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'my';
my $pkgdecl = $::PKGDECL || 'symbol';
return $self if $scope eq 'anon' or $pkgdecl eq 'slang';
$self->deb("Adding $scope $name") if $::DEBUG & DEBUG::symtab;
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or
$self->worry("Cannot $scope $pkgdecl $name because it doesn't exist");
$::MONKEY_TYPING or
$self->sorry("Cannot $scope $pkgdecl $name without MONKEY_TYPING");
}
else {
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)}};
$self;
};
## method add_my_name ($n, $d = Nil, $p = Nil)
sub add_my_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $d = @_ ? shift() : ();
my $p = @_ ? shift() : ();
my $name = $n;
$self->deb("add_my_name $name in ", $::CURLEX->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURLEX;
my @components = $self->canonicalize_name($name);
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$self->deb("Adding new package $pkg in ", $curstash->id) if $::DEBUG & DEBUG::symtab;
$curstash = $newstash;
}
;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';
return $self->add_categorical(substr($name,1)) if $name =~ /^\&\w+\:/;
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $d // NAME->new(
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
of   => $::OFTYPE,
scope => ($::SCOPE//'my'),
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
$self->deb("$name exists, curstash = ", $curstash->id) if $::DEBUG & DEBUG::symtab;
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto' and $::MULTINESS ne 'proto' and $::MULTINESS ne 'only') {
}
elsif ($::PKGDECL eq 'role') {
}
elsif ($::SIGNUM and $old->{'signum'} and $::SIGNUM != $old->{'signum'}) {
$old->{'signum'} = $::SIGNUM}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (see $oname line $oline)";
}
else {
$loc = " (see line $oline)"}};
if ($old->olex) {
my $rebind = $old->{'rebind'};
my $truename = $old->{'varbind'}->{'truename'};
$self->sorry("Lexical symbol '$name' is already bound to an outer symbol$loc;\n  the implicit outer binding at line $rebind must be rewritten as $truename\n  before you can unambiguously declare a new '$name' in this scope");
}
elsif ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$name'$loc")}
elsif ($name =~ s/^\&//) {
$self->sorry("Illegal redeclaration of routine '$name'$loc") unless $name eq ''}
else {
$self->worry("Useless redeclaration of variable $name$loc")};
return $self;
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} = $declaring unless $shortname eq $name;
$::DECLARAND->{'declaredat'} = $self->{'_pos'};
$::DECLARAND->{'inlex'} = $curstash->idref;
$::DECLARAND->{'signum'} = $::SIGNUM if $::SIGNUM;
$::DECLARAND->{'const'} ||= 1 if $::IN_DECL eq 'constant';
$::DECLARAND->{'used'} = 1 if substr($name,0,1) eq '&' and @::MYSTERY{substr($name,1)};
if (!$::DECLARAND->{'const'} and $shortname =~ /^\w+$/) {
$curstash->{"\&$shortname"} //= $curstash->{$shortname};
$curstash->{"\&$shortname"}->{'used'} = 1;
$sid .= "::$name";
if ($name !~ /\:\</) {
$::NEWPKG = $curstash->{$name . '::'} = ($p // Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] ))};
};
};
$self;
};
## method add_our_name ($n)
sub add_our_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $name = $n;
$self->deb("add_our_name $name in " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURPKG;
$self->deb("curstash $curstash global $::GLOBAL ", join ' ', %$::GLOBAL) if $::DEBUG & DEBUG::symtab;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curstash = $c;
};
};
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
'PARENT::' => $curstash->idref,
'!stub' => 1,
'!id' => [$sid] );
$curstash = $newstash;
$self->deb("Adding new package $pkg in $curstash ") if $::DEBUG & DEBUG::symtab;
}
;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $::DECLARAND // NAME->new(
name => $name,
file => $::FILE, line => $self->line,
mult => ($::MULTINESS||'only'),
of   => $::OFTYPE,
scope => ($::SCOPE//'our'),
);
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto' and $::MULTINESS ne 'proto' and $::MULTINESS ne 'only') {
}
elsif ($::PKGDECL eq 'role') {
}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)"}};
$sid = $self->clean_id($sid, $name);
if ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$sid'$loc")}
elsif ($name =~ s/^\&//) {
$self->sorry("Illegal redeclaration of routine '$sid'$loc") unless $name eq ''}
else {
};
return $self;
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} //= $declaring unless $shortname eq $name;
$::DECLARAND->{'inpkg'} = $curstash->idref;
if ($shortname =~ /^\w+$/ and $::IN_DECL ne 'constant') {
$curstash->{"\&$shortname"} //= $declaring;
$curstash->{"\&$shortname"}->{'used'} = 1;
$sid .= "::$name";
$::NEWPKG = $curstash->{$name . '::'} //= Stash->new(
'PARENT::' => $curstash->idref,
'!file' => $::FILE, '!line' => $self->line,
'!id' => [$sid] );
};
};
$self->add_my_name($n, $declaring, $curstash->{$name . '::'}) if $curstash == $::CURPKG;
$self;
};
## method add_mystery ($token,$pos,$ctx)
sub add_mystery {
no warnings 'recursion';
my $self = shift;
die 'Required argument token omitted' unless @_;
my $token = @_ ? shift() : undef;
die 'Required argument pos omitted' unless @_;
my $pos = @_ ? shift() : undef;
die 'Required argument ctx omitted' unless @_;
my $ctx = @_ ? shift() : undef;
return $self unless $token;
my $name = $token->Str;
return $self if $::IN_PANIC;
if ($self->is_known('&' . $name) or $self->is_known($name)) {
$self->deb("$name is known") if $::DEBUG & DEBUG::symtab}
else {
$self->deb("add_mystery $name $::CURLEX") if $::DEBUG & DEBUG::symtab;
$::MYSTERY{$name}->{'lex'} = $::CURLEX;
$::MYSTERY{$name}->{'token'} = $token;
$::MYSTERY{$name}->{'ctx'} = $ctx;
$::MYSTERY{$name}->{'line'} .= ',' if $::MYSTERY{$name}->{'line'};
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos);
};
$self;
};
## method explain_mystery()
sub explain_mystery {
no warnings 'recursion';
my $self = shift;
my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'lex'};
if ($self->is_name($_, $p)) {
$post_types{$_} = $::MYSTERY{$_};
next;
};
next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_}}
else {
$unk_routines{$_} = $::MYSTERY{$_}};
}
;
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $post_types{$_}->{'line'} . "\n"}
;
};
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_types{$_}->{'line'} . "\n";
$m .= "\t  (in Perl 6 please use Mu as the most universal type)\n" if $_ eq 'Object';
}
;
};
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
my $obs = {
y => "tr",
qr => "rx",
local => "temp (or dynamic var)",
new => "method call syntax",
foreach => "for",
}
;
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_routines{$_}->{'line'} . "\n";
$m .= "\t  (in Perl 6 please use " . $obs->{$_} . " instead)\n" if $obs->{$_};
}
;
};
$self->sorry($m) if $m;
$self;
};
## method load_setting ($setting)
sub load_setting {
no warnings 'recursion';
my $self = shift;
die 'Required argument setting omitted' unless @_;
my $setting = @_ ? shift() : undef;
$ALL = $self->load_lex($setting);
$::CORE = $ALL->{'CORE'};
$::CORE->{'!id'} //= ['CORE'];
$::SETTING = $ALL->{'SETTING'};
$::CURLEX = $::SETTING;
$::GLOBAL = $::CORE->{'GLOBAL::'} = Stash->new(
'!file' => $::FILE, '!line' => 1,
'!id' => ['GLOBAL'],
);
$::CURPKG = $::GLOBAL;
};
## method is_known ($n, $curlex = $*CURLEX)
sub is_known {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curlex = @_ ? shift() : $::CURLEX;
my $name = $n;
$self->deb("is_known $name") if $::DEBUG & DEBUG::symtab;
return 1 if $::QUASIMODO;
return 1 if $::CURPKG->{$name};
return 0 if $name =~ /\:\:\(/;
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$self->deb("Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg)) if $::DEBUG & DEBUG::symtab;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outlexid = $curpkg->[0];
return 0 unless $outlexid;
$curpkg = $ALL->{$outlexid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay, now in $curpkg ") if $::DEBUG & DEBUG::symtab;
}
;
};
$name = shift(@components)//'';
$self->deb("Final component is $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
if ($curpkg->{$name}) {
$self->deb("Found") if $::DEBUG & DEBUG::symtab;
$curpkg->{$name}->{'used'}++;
return 1;
};
return 0 if $curpkg != $::CURPKG and $curpkg->{'!id'}->[0] =~ /^GLOBAL($|\:\:)/;
my $varbind = {
truename => '???' };
return 1 if $n !~ /\:\:/ and $self->lex_can_find_name($curlex,$name,$varbind);
$self->deb("Not Found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method lex_can_find_name ($lex, $name, $varbind)
sub lex_can_find_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument lex omitted' unless @_;
my $lex = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument varbind omitted' unless @_;
my $varbind = @_ ? shift() : undef;
$self->deb("Looking in ", $lex->id) if $::DEBUG & DEBUG::symtab;
if ($lex->{$name}) {
$self->deb("Found $name in ", $lex->id) if $::DEBUG & DEBUG::symtab;
$lex->{$name}->{'used'}++;
return 1;
};
my $outlexid = $lex->{'OUTER::'}->[0];
return 0 unless $outlexid;
my $outlex = $ALL->{$outlexid};
if ($self->lex_can_find_name($outlex,$name,$varbind)) {
my $outname = $outlex->{$name}->{'name'};
my $outfile = $outlex->{$name}->{'file'};
my $outline = $outlex->{$name}->{'line'};
$outname = '<' . $outname . '>' unless $outname =~ /\:\:\</;
$outname = "OUTER::" . $outname;
$lex->{$name} = NAME->new(
olex => $lex->idref,
name => $outname,
file => $outfile, line => $outline,
rebind => $self->line,
varbind => $varbind,
mult => 'only',
scope => ($lex->{$name}->{'scope'}//'my'),
);
$varbind->{'truename'} = $outname;
return 1;
};
return 0;
};
## method add_routine ($name)
sub add_routine {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$::MEMOS[$self->{'_pos'}]->{'wasname'} = $name if $self->is_name($name);
my $vname = '&' . $name;
$self->add_name($vname);
$self;
};
## method add_variable ($name)
sub add_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'our';
return $self if $scope eq 'anon';
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)};
$self;
};
## method add_constant($name,$value)
sub add_constant {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument value omitted' unless @_;
my $value = @_ ? shift() : undef;
local $::IN_DECL = 'constant';
$self->deb("add_constant $name = $value in", $::CURLEX->id) if $::DEBUG & DEBUG::symtab;
local $::DECLARAND;
$self->add_my_name($name);
$::DECLARAND->{'value'} = $value;
$self;
};
## method add_placeholder($name)
sub add_placeholder {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $decl = $::CURLEX->{'!IN_DECL'} // '';
$decl = ' ' . $decl if $decl;
local $::IN_DECL = 'variable';
if ($::SIGNUM) {
return $self->sorry("Placeholder variable $name is not allowed in the$decl signature")}
elsif (my $siggy = $::CURLEX->{'$?SIGNATURE'}) {
return $self->sorry("Placeholder variable $name cannot override existing signature $siggy")};
if (not $::CURLEX->{'!NEEDSIG'}) {
if ($::CURLEX == $::UNIT) {
return $self->sorry("Placeholder variable $name may not be used outside of a block")};
return $self->sorry("Placeholder variable $name may not be used here because the surrounding$decl block takes no signature");
};
if ($name =~ /\:\:/) {
return $self->sorry("Placeholder variable $name may not be package qualified")};
my $varname = $name;
my $twigil;
my $signame;
$twigil = '^' if $varname =~ s/\^//;
$signame = $twigil = ':' if $varname =~ s/\://;
$signame .= $varname;
return $self if $::CURLEX->{'%?PLACEHOLDERS'}->{$signame}++;
if ($::CURLEX->{$varname}) {
return $self->sorry("$varname has already been used as a non-placeholder in the surrounding$decl block,\n  so you will confuse the reader if you suddenly declare $name here")};
$self->add_my_name($varname);
$::CURLEX->{$varname}->{'used'} = 1;
$self;
};
## method check_variable ($variable)
sub check_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument variable omitted' unless @_;
my $variable = @_ ? shift() : undef;
my $name = $variable->Str;
my $here = $self->cursor($variable->from);
$self->deb("check_variable $name") if $::DEBUG & DEBUG::symtab;
my ($sigil, $twigil, $first)= $name =~ /(\$|\@|\%|\&)(\W*)(.?)/;
($first,$twigil) = ($twigil, '') if $first eq '';
given ($twigil) {
when ('') {
my $ok = 0;
$ok ||= $::IN_DECL;
$ok ||= $first lt 'A';
$ok ||= $first eq '¢';
$ok ||= $self->is_known($name);
$ok ||= $name =~ /.\:\:/ && $name !~ /MY|UNIT|OUTER|SETTING|CORE/;
if (not $ok) {
my $id = $name;
$id =~ s/^\W\W?//;
if ($sigil eq '&') {
$here->add_mystery($variable->{'sublongname'}, $self->{'_pos'}, 'var')
}
elsif ($name eq '@_' or $name eq '%_') {
$here->add_placeholder($name)}
else {
if (my $scope = $::MEMOS[$variable->from]->{'declend'}) {
return $here->sorry("Variable $name is not predeclared (declarators are tighter than comma, so maybe your '$scope' signature needs parens?)")}
elsif ($id !~ /\:\:/) {
if ($self->is_known('@' . $id)) {
return $here->sorry("Variable $name is not predeclared (did you mean \@$id?)")}
elsif ($self->is_known('%' . $id)) {
return $here->sorry("Variable $name is not predeclared (did you mean \%$id?)")}};
return $here->sorry("Variable $name is not predeclared");
};
}
elsif ($::CURLEX->{$name}) {
$::CURLEX->{$name}->{'used'}++};
}
;
when ('!') {
if (not $::HAS_SELF) {
$here->sorry("Variable $name used where no 'self' is available")}}
;
when ('.') {
given ($::HAS_SELF) {
when ('complete') {
}
;
when ('partial') {
$here->sorry("Virtual call $name may not be used on partially constructed object")}
;
default {
$here->sorry("Variable $name used where no 'self' is available")}
;
}
}
;
when ('^') {
local $::MULTINESS = 'multi';
$here->add_placeholder($name);
}
;
when (':') {
local $::MULTINESS = 'multi';
$here->add_placeholder($name);
}
;
when ('~') {
return @::LANG{substr($name,2)}}
;
when ('?') {
if ($name =~ /\:\:/) {
my ($first)= $self->canonicalize_name($name);
$here->worry("Unrecognized variable: $name") unless $first =~ /^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)\:\:$/;
}
else {
my $v = $here->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}}
;
}
;
$self;
};
## method lookup_compiler_var($name, $default = Nil)
sub lookup_compiler_var {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $default = @_ ? shift() : ();
my $lex = $::CURLEX->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->()}
else {
return $lex->{'value'}}};
given ($name) {
when ('$?FILE')     {
return $::FILE->{'name'}}
;
when ('$?LINE')     {
return $self->lineof($self->{'_pos'})}
;
when ('$?POSITION') {
return $self->{'_pos'}}

;
when ('$?LANG')     {
return \%::LANG}

;
when ('$?LEXINFO')   {
return $::CURLEX}

;
when ('$?PACKAGE')  {
return $::CURPKG}
;
when ('$?MODULE')   {
return $::CURPKG}
;
when ('$?CLASS')    {
return $::CURPKG}
;
when ('$?ROLE')     {
return $::CURPKG}
;
when ('$?GRAMMAR')  {
return $::CURPKG}

;
when ('$?PACKAGENAME') {
return $::CURPKG->id }

;
when ('$?OS')       {
return 'unimpl'}
;
when ('$?DISTRO')   {
return 'unimpl'}
;
when ('$?VM')       {
return 'unimpl'}
;
when ('$?XVM')      {
return 'unimpl'}
;
when ('$?PERL')     {
return 'unimpl'}

;
when ('$?USAGE')    {
return 'unimpl'}

;
when ('&?ROUTINE')  {
return 'unimpl'}
;
when ('&?BLOCK')    {
return 'unimpl'}

;
when ('%?CONFIG')    {
return 'unimpl'}
;
when ('%?DEEPMAGIC') {
return 'unimpl'}

;
my $dynvar = $self->lookup_dynvar($name);
return $dynvar if defined $dynvar;
return $default if defined $default;
default {
$self->worry("Unrecognized variable: $name");
return 0;
}
;
}
;
};
## method panic (Str $s)
sub panic {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
die "Recursive panic" if $::IN_PANIC;
$::IN_PANIC++;
$self->deb("panic $s") if $::DEBUG;
my $m;
my $here = $self;
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;
$here = $self->cursor($::HIGHWATER) if $highvalid;
my $first = $here->lineof($::LAST_NIBBLE->from);
my $last = $here->lineof($::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "(Possible runaway string from line $first)\n"}
else {
$first = $here->lineof($::LAST_NIBBLE_MULTILINE->from);
$last = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_pos'});
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "(Possible runaway string from line $first to line $last)\n"};
}};
$m .= $s;
if (substr($self->orig,$here->{'_pos'},1) =~ /\)|\]|\}|\»/) {
$m =~ s|Confused|Unexpected closing bracket| and $highvalid = 0};
if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
$::HIGHMESS .= $s . "\n"};
my $x = '';
if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$x = "    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT) . "\n"}
else {
$x = "    expecting @keys\n" unless $keys[0] eq 'whitespace'};
};
if ($x =~ /infix|nofun/ and not $x =~ /regex/ and not $x =~ /infix_circumfix/) {
my @t = $here->suppose( sub {
$here->term } );
if (@t) {
my $endpos = $here->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$m =~ s|Confused|Two terms in a row (previous line missing its semicolon?)|}
elsif ($::MEMOS[$startpos]->{'listop'}) {
$m =~ s|Confused|Two terms in a row (listop with args requires whitespace or parens)|}
elsif ($::MEMOS[$startpos]->{'baremeth'}) {
$here = $here->cursor($startpos);
$m =~ s|Confused|Two terms in a row (method call with args requires colon or parens without whitespace)|;
}
elsif ($::MEMOS[$startpos]->{'arraycomp'}) {
$m =~ s|Confused|Two terms in a row (preceding is not a valid reduce operator)|}
else {
$m =~ s|Confused|Two terms in a row|};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'nodecl'}) {
my @t = $here->suppose( sub {
$here->variable } );
if (@t) {
my $variable = $t[0]->Str;
$m =~ s|Confused|Bare type $type cannot declare $variable without a preceding scope declarator such as 'my'|;
};
};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'wasname'}) {
my @t = $here->suppose( sub {
$here->identifier } );
my $name = $t[0]->Str;
my $s = $::SCOPE ? "'$::SCOPE'" : '(missing) scope declarator';
my $d = $::IN_DECL;
$d = "$::MULTINESS $d" if $::MULTINESS and $::MULTINESS ne $d;
$m =~ s|Malformed block|Return type $type is not allowed between '$d' and '$name'; please put it:\n  after the $s but before the '$d',\n  within the signature following the '-->' marker, or\n  as the argument of a 'returns' trait after the signature.|;
};
$m .= $here->locmess;
$m .= "\n" unless $m =~ /\n$/;
$m .= $x;
if (@::WORRIES) {
$m .= "Other potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
$::IN_PANIC--;
die $m if $::IN_SUPPOSE;
$::IN_PANIC++;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
unless $::FATALS++;
print STDERR $m;
$self->explain_mystery();
$::IN_PANIC--;
die "Parse failed\n";
};
## regex is_ok {
sub is_ok__PEEK { $_[0]->_AUTOLEXpeek('is_ok', $retree) }
sub is_ok {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE is_ok");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "is_ok", LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\#OK"))) {
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)/)
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
}))
},
$C->_SUBSUME(['okif'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
}))
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
}))
} else { () }
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})));
}
;
## method worry (Str $s)
sub worry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
my $m = $s . $self->locmess;
my ($okmaybe)= $self->suppose( sub {
$self->is_ok});
if ($okmaybe) {
my $okif = $okmaybe->{'okif'}->Str;
return $self if $okif eq '' or $s =~ /$okif/;
};
push @::WORRIES, $m unless $::WORRIES{$s}++;
$self;
};
## method sorry (Str $s)
sub sorry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$self->deb("sorry $s") if $::DEBUG;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
unless $::IN_SUPPOSE or $::FATALS++;
if ($s) {
my $m = $s;
$m .= $self->locmess . "\n" unless $m =~ /\n$/;
if ($::FATALS > 10 or $::IN_SUPPOSE) {
die $m}
else {
print STDERR $m unless $::WORRIES{$m}++};
};
$self;
};
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->panic("Unsupported use of $old;$when please use $new");
};
## method sorryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub sorryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->sorry("Unsupported use of $old;$when please use $new");
$self;
};
## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
$self->worry("Unsupported use of $old;$when please use $new");
$self;
};
## method dupprefix (Str $bad)
sub dupprefix {
no warnings 'recursion';
my $self = shift;
die 'Required argument bad omitted' unless @_;
my $bad = @_ ? shift() : undef;
my $c = substr($bad,0,1);
$self->panic("Expecting a term, but found either infix $bad or redundant prefix $c\n  (to suppress this message, please use space between $c $c)");
};
## method badinfix (Str $bad)
sub badinfix {
no warnings 'recursion';
my $self = shift;
die 'Required argument bad omitted' unless @_;
my $bad = @_ ? shift() : undef;
$self->panic("Preceding context expects a term, but found infix $bad instead")};
## token term:sym<miscbad> {
sub term__S_063miscbad__PEEK { $_[0]->_AUTOLEXpeek('term__S_063miscbad', $retree) }
sub term__S_063miscbad {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_063miscbad");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "miscbad";
$self->_MATCHIFYr($S, "term__S_063miscbad", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = (scalar(do {
my ($bad)= $C->suppose( sub {
$C->infixish});
$::HIGHWATER = -1;
$::HIGHMESS = '';
$self->badinfix($bad->Str) if $bad;
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }

});
}
;
1; }
